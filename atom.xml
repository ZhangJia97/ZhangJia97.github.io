<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随我的博客</title>
  
  <subtitle>记录学习的点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suiwo.xyz/"/>
  <updated>2023-01-07T16:03:07.872Z</updated>
  <id>http://suiwo.xyz/</id>
  
  <author>
    <name>随我</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java-NIO-缓冲区相关概念及源码梳理</title>
    <link href="http://suiwo.xyz/2023/01/07/Java-NIO-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%BA%90%E7%A0%81%E6%A2%B3%E7%90%86/"/>
    <id>http://suiwo.xyz/2023/01/07/Java-NIO-缓冲区相关概念及源码梳理/</id>
    <published>2023-01-07T12:57:09.000Z</published>
    <updated>2023-01-07T16:03:07.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、缓冲区基础"><a href="#一、缓冲区基础" class="headerlink" title="一、缓冲区基础"></a>一、缓冲区基础</h2><h3 id="1-常见概念"><a href="#1-常见概念" class="headerlink" title="1. 常见概念"></a>1. 常见概念</h3><ol><li><p>容量(Capacity)<br>缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能被改变。</p></li><li><p>上界(Limit)<br>缓冲区的第-一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。</p></li><li><p>位置(Position)<br>下一个要被读或写的元素的索引。位置会自动由相应的get()和put()函数更新。</p></li><li><p>标记(Mark)<br>一个备忘位置。调用mark()来设定mark = postion。 调用reset()设定position = mark。标记在设定前是未定义的(undefined)。</p></li></ol><p>这四个属性之间总是遵循以下关系:0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p><h3 id="2-Buffer类常见API"><a href="#2-Buffer类常见API" class="headerlink" title="2. Buffer类常见API"></a>2. Buffer类常见API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.nio;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span> <span class="params">(<span class="keyword">int</span> newPosition)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span> <span class="params">(<span class="keyword">int</span> newLimit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">( )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见常见的例如clear() 函数返回不是void而是返回this，也就是对象本身的引用。这种设计就允许级联调用的类设计方法。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark( );</span><br><span class="line">buffer.position(<span class="number">5</span>);</span><br><span class="line">buffer.reset( );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写为:</span></span><br><span class="line">buffer.mark().position(<span class="number">5</span>).reset( );</span><br></pre></td></tr></table></figure><h3 id="3-存取"><a href="#3-存取" class="headerlink" title="3. 存取"></a>3. 存取</h3><p>为什么Buffer对象中没有定义get以及put函数？</p><blockquote><p>Buffer API并没有包括get()或put()函数。每一个Buffer类都有这两个函数，但它们所采用的参数类型，以及它们返回的数据类型，对每个子类来说都是唯一的，所以它们不能在顶层 Buffer 类中被抽象地声明。它们的定义必须被特定类型的子类所遵从。</p></blockquote><p>执行get和put的注意事项</p><blockquote><p>对于put()，如果运算会导致位置超出上界，就会抛出BufferOverflowException异常。对于get()，如果位置不小于上界，就会抛出BufferUnderflowException异常。绝对存取不会影响缓冲区的位置属性，但是如果您所提供的索引超出范围(负数或不小于上界)，也将抛出IndexOutOfBoundsException异常。</p></blockquote><h3 id="4-写入"><a href="#4-写入" class="headerlink" title="4. 写入"></a>4. 写入</h3><p>写入到具体位置可以使用<code>buffer.put(0,(byte)&#39;M&#39;)</code>这种方式接入。而<code>buffer.put((byte)&#39;w&#39;)</code>方法不会收到影响，他总是在最后一个位置上写入数据。</p><h3 id="5-翻转"><a href="#5-翻转" class="headerlink" title="5. 翻转"></a>5. 翻转</h3><p>对于翻转我们可以使用<code>buffer.limit(buffer.position()).position(0);</code>来进行翻转，<br>他执行的逻辑就是先将buffer的上界设置为当前buffer的容量，同时将标记重置。然后将当前读/写的位置重置为起始位置。</p><p>其中<code>buffer.limit(int)</code>方法代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Sets this buffer's limit.  If the position is larger than the new limit</span></span><br><span class="line"><span class="comment">  * then it is set to the new limit.  If the mark is defined and larger than</span></span><br><span class="line"><span class="comment">  * the new limit then it is discarded.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  newLimit</span></span><br><span class="line"><span class="comment">  *         The new limit value; must be non-negative</span></span><br><span class="line"><span class="comment">  *         and no larger than this buffer's capacity</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">  *          If the preconditions on &lt;tt&gt;newLimit&lt;/tt&gt; do not hold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    limit = newLimit;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>buffer.position()</code>代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns this buffer's position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The position of this buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>buffer.position(int)</code>代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets this buffer's position.  If the mark is defined and larger than the</span></span><br><span class="line"><span class="comment"> * new position then it is discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  newPosition</span></span><br><span class="line"><span class="comment"> *         The new position value; must be non-negative</span></span><br><span class="line"><span class="comment"> *         and no larger than the current limit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          If the preconditions on &lt;tt&gt;newPosition&lt;/tt&gt; do not hold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    position = newPosition;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于这种翻转需求十分常见，所以Buffer类为我们提供了一个便利的翻转函数<code>Buffer.flip()</code><br>代码如下。将上界设置为当前读/写位置，读/写位置置0，标志位重置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flips this buffer.  The limit is set to the current position and then</span></span><br><span class="line"><span class="comment"> * the position is set to zero.  If the mark is defined then it is</span></span><br><span class="line"><span class="comment"> * discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke</span></span><br><span class="line"><span class="comment"> * this method to prepare for a sequence of channel-write or relative</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;get&lt;/i&gt; operations.  For example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * buf.put(magic);    // Prepend header</span></span><br><span class="line"><span class="comment"> * in.read(buf);      // Read data into rest of buffer</span></span><br><span class="line"><span class="comment"> * buf.flip();        // Flip buffer</span></span><br><span class="line"><span class="comment"> * out.write(buf);    // Write header + data to channel&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method is often used in conjunction with the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.nio.ByteBuffer#compact compact&#125; method when transferring data from</span></span><br><span class="line"><span class="comment"> * one place to another.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了翻转函数flip()，还有一个常用函数，用来初始化读/写位置<code>Buffer.rewind()</code><br>代码如下，他将当前读/写位置置0，将标记位重置。通过rewind()我们可以对已经读过得缓冲区数据进行重读<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rewinds this buffer.  The position is set to zero and the mark is</span></span><br><span class="line"><span class="comment"> * discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Invoke this method before a sequence of channel-write or &lt;i&gt;get&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * operations, assuming that the limit has already been set</span></span><br><span class="line"><span class="comment"> * appropriately.  For example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * out.write(buf);    // Write remaining data</span></span><br><span class="line"><span class="comment"> * buf.rewind();      // Rewind buffer</span></span><br><span class="line"><span class="comment"> * buf.get(array);    // Copy data into array&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-释放"><a href="#6-释放" class="headerlink" title="6. 释放"></a>6. 释放</h3><p>当我们接收到一个已经被填满的缓冲区的时候，我们可以通过通道的read()操作完成，当然我们需要在调用get()前对这个缓冲区进行翻转之后。<br>我们可以根据<code>hasRemaining()</code>方法来判断当前位置是否超出缓冲区的上界。我们可以通过下面这种方式来轮询获取缓冲区中的数据(在后续中，我们将学到进行批量传输的更高效的方法)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; buffer.hasRemaining(), i++) &#123;</span><br><span class="line">    myByteArray[i] = buffer.get(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>作为选择，<code>remaining()</code>函数将告知您从当前位置到上界还剩余的元素数目。您也可以通过下面的循环来释放缓冲区。<br>使用下面的好处就是不需要在每次循环的时候都进行重复检查。但是坏处就是这个无法在多线程的情况下同时从缓冲区中获取数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = buffer.remaining( );</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count, i++) &#123;</span><br><span class="line">    myByteArray[i] = buffer.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述两个函数的代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of elements between the current position and the</span></span><br><span class="line"><span class="comment"> * limit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The number of elements remaining in this buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> limit - position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tells whether there are any elements between the current position and</span></span><br><span class="line"><span class="comment"> * the limit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &lt;tt&gt;true&lt;/tt&gt; if, and only if, there is at least one element</span></span><br><span class="line"><span class="comment"> *          remaining in this buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在缓冲区中的对象完成读取释放后，他又可以进行重新使用。我们可以调用clear()函数将缓冲区重置为空的状态。<br>当然这个所谓的重置并不是真的将缓冲区中的数据进行删除，而是将数据的上界设置为容量值，同时将位置置0。<br>实际代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clears this buffer.  The position is set to zero, the limit is set to</span></span><br><span class="line"><span class="comment"> * the capacity, and the mark is discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Invoke this method before using a sequence of channel-read or</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;put&lt;/i&gt; operations to fill this buffer.  For example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * buf.clear();     // Prepare buffer for reading</span></span><br><span class="line"><span class="comment"> * in.read(buf);    // Read data&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method does not actually erase the data in the buffer, but it</span></span><br><span class="line"><span class="comment"> * is named as if it did because it will most often be used in situations</span></span><br><span class="line"><span class="comment"> * in which that might as well be the case. &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一段实例代码，演示如果写入以及释放缓冲区<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferFillDrain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] strings = &#123;</span><br><span class="line">            <span class="string">"A random string value"</span>,</span><br><span class="line">            <span class="string">"The product of an infinite number of monkeys"</span>,</span><br><span class="line">            <span class="string">"Hey hey we're the Monkees"</span>,</span><br><span class="line">            <span class="string">"Opening act for the Monkees: Jimi Hendrix"</span>,</span><br><span class="line">            <span class="string">"'Scuse me while I kiss this fly"</span>,</span><br><span class="line">            <span class="string">"Help Me! Help Me!"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CharBuffer buffer = CharBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">while</span> (fillBuffer(buffer)) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            drainBuffer(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drainBuffer</span><span class="params">(CharBuffer charBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (charBuffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.print(charBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">fillBuffer</span><span class="params">(CharBuffer charBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= strings.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String string = strings[index++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string.length(); i++) &#123;</span><br><span class="line">            charBuffer.put(string.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="7-压缩"><a href="#7-压缩" class="headerlink" title="7. 压缩"></a>7. 压缩</h3><p>当我们希望释放缓冲区的部分数据，然后保留剩余的数据继续进行填充。为了实现这一点，我们需要将未读的数据进行迁移，使未读的第一个数据索引为0。对此，Buffer类为我们提供了<code>compact()</code>函数来实现这一功能，尽管重复这样做会效率低下，但是相较于我们自己进行<code>get()</code>和<code>put()</code>函数来说，使用提供的<code>compact()</code>会高效得多。所以当需要的时候，建议使用<code>compact()</code>。</p><p>执行compact前<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/B207A94E-08FF-45E5-B883-DA7AD86D4D86_4_5005_c.jpeg" alt="img"></p><p>执行compact后<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/CC579E9E-23DC-466E-83E2-E051FE3E5AF4_4_5005_c.jpeg" alt="img"></p><p>我们可以发现执行方法会</p><ol><li>将2-5的元素复制到0-3的位置上，同时4-5不会有变动。</li><li>将postition移到4的位置也就是说，缓冲区现在被定位在缓冲区中最后一个“存活”元素后插入数据的位置。</li><li>将缓冲区的上界改为缓冲区的容量大小。</li></ol><p>下面我们已经<code>HeapByteBuffer</code>类举例，看看如果实现一个<code>compact()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 使用数组拷贝将未读数据拷贝</span></span><br><span class="line">    System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">    <span class="comment">// 2. 将缓冲区的位置放到缓冲区存活的数据后的数据的位置，也就是`limit - position`</span></span><br><span class="line">    <span class="comment">// remaining() 返回的值为limit - position</span></span><br><span class="line">    position(remaining());</span><br><span class="line">    <span class="comment">// 3. 将上界大小设置为缓冲区的容量大小</span></span><br><span class="line">    limit(capacity());</span><br><span class="line">    <span class="comment">// 重置mark为-1</span></span><br><span class="line">    discardMark();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="8-标记"><a href="#8-标记" class="headerlink" title="8. 标记"></a>8. 标记</h3><p>标记的作用是使缓冲区能够记住一个位置并在之后将其返回。<br>缓冲区的标记在调用mark()函数之前是未定义的。调用后会将当前位置赋值给标记。<br>函数代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets this buffer's mark at its position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而reset()方法则会将当前位置移动到标记值的位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resets this buffer's position to the previously-marked position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Invoking this method neither changes nor discards the mark's</span></span><br><span class="line"><span class="comment"> * value. &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InvalidMarkException</span></span><br><span class="line"><span class="comment"> *          If the mark has not been set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此处定义临时变量个人认为主要目的是防止多个线程同时执行时导致的异常</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 如果不用一个局部变量m存储，那就会存在以下这种可能性</span></span><br><span class="line"><span class="comment">     * 1. A线程判断 mark&gt;=0，参数合法</span></span><br><span class="line"><span class="comment">     * 2. B线程执行了类似于rewind()，clear()，flip()等可以将mark重置为-1的方法</span></span><br><span class="line"><span class="comment">     * 3. A线程将mark赋值给position</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 但是如果使用了局部变量m就可以避免由于多个线程修改导致的问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果新设定的值比当前的标记小，调用<code>limit(int)</code>或<code>position(int)</code>带有索引参数的版本会抛弃标记。<br>从代码中可以看到这两个函数在执行的时候都会对remark进行判断，如果不合法则置为-1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets this buffer's position.  If the mark is defined and larger than the</span></span><br><span class="line"><span class="comment"> * new position then it is discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  newPosition</span></span><br><span class="line"><span class="comment"> *         The new position value; must be non-negative</span></span><br><span class="line"><span class="comment"> *         and no larger than the current limit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          If the preconditions on &lt;tt&gt;newPosition&lt;/tt&gt; do not hold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    position = newPosition;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets this buffer's limit.  If the position is larger than the new limit</span></span><br><span class="line"><span class="comment"> * then it is set to the new limit.  If the mark is defined and larger than</span></span><br><span class="line"><span class="comment"> * the new limit then it is discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  newLimit</span></span><br><span class="line"><span class="comment"> *         The new limit value; must be non-negative</span></span><br><span class="line"><span class="comment"> *         and no larger than this buffer's capacity</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          If the preconditions on &lt;tt&gt;newLimit&lt;/tt&gt; do not hold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    limit = newLimit;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设我们执行下面这个函数，他会做什么操作？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.position(<span class="number">2</span>).mark().position(<span class="number">4</span>);</span><br></pre></td></tr></table></figure></p><ol><li>将缓冲区的位置置为2</li><li>将缓冲区的标记赋值为位置的值2</li><li>将缓冲区的位置置为4</li></ol><p>最终结果如下图<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/5FC42548-560C-4B9F-AD13-52F850F724F1_4_5005_c.jpeg" alt="img"></p><h3 id="9-比较"><a href="#9-比较" class="headerlink" title="9. 比较"></a>9. 比较</h3><p>以<code>ByteBuffer</code>类为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>他继承了Comparable接口，我们可以通过实现Comparable接口的compareTo()方法来实现两个Buffer的对比。<br>如果每个缓冲区中剩余的内容相同，那么equals()函数将返回true，否则返回false。因为这个测试是用于严格的相等而且是可换向的。前面的程序清单中的缓冲区名称可以颠倒，并会产生相同的结果。<br>与equals()相似，compareTo()不允许不同对象间进行比较。但compareTo()更为严格:如果您传递一个类型错误的对象，它会抛出ClassCastException异常，但equals()只会返回 false。<br>两个缓冲区被认为相等的充要条件是:</p><ul><li>两个对象类型相同。包含不同数据类型的buffer永远不会相等，而且buffer绝不会等于非buffer对象。</li><li>两个对象都剩余同样数量的元素。Buffer的容量不需要相同，而且缓冲区中剩余数据的索引也不必相同。但每个缓冲区中剩余元素的数目(也就是从位置到上界的元素数量)必须相同。</li><li>在每个缓冲区中应被Get()函数返回的剩余数据元素序列必须一致。<br>如果不满足以上任意条件，就会返回false。</li></ul><p>两个被认为是相等的缓冲区<br>可以看到在position到limit中的数据时一致的（limit位是还未存储的数据位）所以我们可以认为这两个Buffer相同。<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/F821CD63-1ED7-473E-AEBA-F1F8D80073D2_4_5005_c.jpeg" alt="img"></p><p>两个被认为不相等的缓冲区<br>虽然缓冲区中所存的数据是完全一致的，但是由于position到limit中的数据不一致，所以两个缓冲区不相等。<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/604B430D-5619-401D-B352-8125DA7F290C_4_5005_c.jpeg" alt="img"></p><h3 id="10-批量移动"><a href="#10-批量移动" class="headerlink" title="10. 批量移动"></a>10. 批量移动</h3><p>为了高效传输数据，Buffer类中提供了许多向缓冲区内外批量移动元素的函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">// This is a partial API listing</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span> <span class="params">(<span class="keyword">char</span> [] dst)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">public</span> ByteBuffer <span class="title">get</span> <span class="params">(<span class="keyword">char</span> [] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">char</span>[] src)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">public</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">char</span> [] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">public</span> ByteBuffer <span class="title">put</span> <span class="params">(ByteBuffer src)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>第一种形式的<code>get(char[] dst)</code>只是将缓冲区中的数据复制到传入的数组中。<br>代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Relative bulk &lt;i&gt;get&lt;/i&gt; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method transfers bytes from this buffer into the given</span></span><br><span class="line"><span class="comment"> * destination array.  An invocation of this method of the form</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;src.get(a)&lt;/tt&gt; behaves in exactly the same way as the invocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     src.get(a, 0, a.length) &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   dst</span></span><br><span class="line"><span class="comment"> *          The destination array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  BufferUnderflowException</span></span><br><span class="line"><span class="comment"> *          If there are fewer than &lt;tt&gt;length&lt;/tt&gt; bytes</span></span><br><span class="line"><span class="comment"> *          remaining in this buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 底层实际的调用方法就是第二种get函数</span></span><br><span class="line">    <span class="keyword">return</span> get(dst, <span class="number">0</span>, dst.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种形式<code>get (char [] dst, int offset, int length)</code>使用offset和length参数来指定目标数组的子区间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Relative bulk &lt;i&gt;get&lt;/i&gt; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method transfers bytes from this buffer into the given</span></span><br><span class="line"><span class="comment"> * destination array.  If there are fewer bytes remaining in the</span></span><br><span class="line"><span class="comment"> * buffer than are required to satisfy the request, that is, if</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;length&lt;/tt&gt;&amp;nbsp;&lt;tt&gt;&amp;gt;&lt;/tt&gt;&amp;nbsp;&lt;tt&gt;remaining()&lt;/tt&gt;, then no</span></span><br><span class="line"><span class="comment"> * bytes are transferred and a &#123;<span class="doctag">@link</span> BufferUnderflowException&#125; is</span></span><br><span class="line"><span class="comment"> * thrown.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Otherwise, this method copies &lt;tt&gt;length&lt;/tt&gt; bytes from this</span></span><br><span class="line"><span class="comment"> * buffer into the given array, starting at the current position of this</span></span><br><span class="line"><span class="comment"> * buffer and at the given offset in the array.  The position of this</span></span><br><span class="line"><span class="comment"> * buffer is then incremented by &lt;tt&gt;length&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; In other words, an invocation of this method of the form</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;src.get(dst,&amp;nbsp;off,&amp;nbsp;len)&lt;/tt&gt; has exactly the same effect as</span></span><br><span class="line"><span class="comment"> * the loop</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     for (int i = off; i &lt; off + len; i++)</span></span><br><span class="line"><span class="comment"> *         dst[i] = src.get():</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * except that it first checks that there are sufficient bytes in</span></span><br><span class="line"><span class="comment"> * this buffer and it is potentially much more efficient.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  dst</span></span><br><span class="line"><span class="comment"> *         The array into which bytes are to be written</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  offset</span></span><br><span class="line"><span class="comment"> *         The offset within the array of the first byte to be</span></span><br><span class="line"><span class="comment"> *         written; must be non-negative and no larger than</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;dst.length&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  length</span></span><br><span class="line"><span class="comment"> *         The maximum number of bytes to be written to the given</span></span><br><span class="line"><span class="comment"> *         array; must be non-negative and no larger than</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;dst.length - offset&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  BufferUnderflowException</span></span><br><span class="line"><span class="comment"> *          If there are fewer than &lt;tt&gt;length&lt;/tt&gt; bytes</span></span><br><span class="line"><span class="comment"> *          remaining in this buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> *          If the preconditions on the &lt;tt&gt;offset&lt;/tt&gt; and &lt;tt&gt;length&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *          parameters do not hold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, dst.length);</span><br><span class="line">    <span class="comment">// 判断获取的数据长度是否大于剩余的数据元素长度</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        dst[i] = get();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以我们为了避免获取的数据元素大于剩余的元素的长度可以使用下面这种方式来解决。先获取剩余数据的长度然后在批量移动。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> [] bigArray = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get count of chars remaining in the buffer </span></span><br><span class="line"><span class="keyword">int</span> length = buffer.remaining( );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Buffer is known to contain &lt; 1,000 chars</span></span><br><span class="line">buffer.get(bigArrray, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do something useful with the data</span></span><br><span class="line">processData (bigArray, length);</span><br></pre></td></tr></table></figure></p><p>如果缓冲区存有比数组能容纳的数量更多的数据，您可以重复利用如下文所示的程序块进行读取:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] smallArray = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = Math.min(buffer.remaining(), smallArray.length);</span><br><span class="line">    buffer.get(smallArray, <span class="number">0</span>, length);</span><br><span class="line">    processData(smallArray, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>批量移入的逻辑与批量移出类似<br>第一种方式<code>put(char[] src)</code>实际代码如下，底层实际调用的就是第二种put<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Relative bulk &lt;i&gt;put&lt;/i&gt; method&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method transfers the entire content of the given source</span></span><br><span class="line"><span class="comment"> * byte array into this buffer.  An invocation of this method of the</span></span><br><span class="line"><span class="comment"> * form &lt;tt&gt;dst.put(a)&lt;/tt&gt; behaves in exactly the same way as the</span></span><br><span class="line"><span class="comment"> * invocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     dst.put(a, 0, a.length) &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   src</span></span><br><span class="line"><span class="comment"> *          The source array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  BufferOverflowException</span></span><br><span class="line"><span class="comment"> *          If there is insufficient space in this buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ReadOnlyBufferException</span></span><br><span class="line"><span class="comment"> *          If this buffer is read-only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> put(src, <span class="number">0</span>, src.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种方式<code>put (char [] src, int offset, int length)</code>，实际代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Relative bulk &lt;i&gt;put&lt;/i&gt; method&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method transfers bytes into this buffer from the given</span></span><br><span class="line"><span class="comment"> * source array.  If there are more bytes to be copied from the array</span></span><br><span class="line"><span class="comment"> * than remain in this buffer, that is, if</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;length&lt;/tt&gt;&amp;nbsp;&lt;tt&gt;&amp;gt;&lt;/tt&gt;&amp;nbsp;&lt;tt&gt;remaining()&lt;/tt&gt;, then no</span></span><br><span class="line"><span class="comment"> * bytes are transferred and a &#123;<span class="doctag">@link</span> BufferOverflowException&#125; is</span></span><br><span class="line"><span class="comment"> * thrown.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Otherwise, this method copies &lt;tt&gt;length&lt;/tt&gt; bytes from the</span></span><br><span class="line"><span class="comment"> * given array into this buffer, starting at the given offset in the array</span></span><br><span class="line"><span class="comment"> * and at the current position of this buffer.  The position of this buffer</span></span><br><span class="line"><span class="comment"> * is then incremented by &lt;tt&gt;length&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; In other words, an invocation of this method of the form</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;dst.put(src,&amp;nbsp;off,&amp;nbsp;len)&lt;/tt&gt; has exactly the same effect as</span></span><br><span class="line"><span class="comment"> * the loop</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     for (int i = off; i &lt; off + len; i++)</span></span><br><span class="line"><span class="comment"> *         dst.put(a[i]);</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * except that it first checks that there is sufficient space in this</span></span><br><span class="line"><span class="comment"> * buffer and it is potentially much more efficient.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  src</span></span><br><span class="line"><span class="comment"> *         The array from which bytes are to be read</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  offset</span></span><br><span class="line"><span class="comment"> *         The offset within the array of the first byte to be read;</span></span><br><span class="line"><span class="comment"> *         must be non-negative and no larger than &lt;tt&gt;array.length&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  length</span></span><br><span class="line"><span class="comment"> *         The number of bytes to be read from the given array;</span></span><br><span class="line"><span class="comment"> *         must be non-negative and no larger than</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;array.length - offset&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  BufferOverflowException</span></span><br><span class="line"><span class="comment"> *          If there is insufficient space in this buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> *          If the preconditions on the &lt;tt&gt;offset&lt;/tt&gt; and &lt;tt&gt;length&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *          parameters do not hold</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ReadOnlyBufferException</span></span><br><span class="line"><span class="comment"> *          If this buffer is read-only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, src.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        <span class="keyword">this</span>.put(src[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>剩余集中put就不再做展示，整体思路和上面两个put类似。</p><h2 id="二、创建缓冲区"><a href="#二、创建缓冲区" class="headerlink" title="二、创建缓冲区"></a>二、创建缓冲区</h2><h3 id="1-相关API"><a href="#1-相关API" class="headerlink" title="1. 相关API"></a>1. 相关API</h3><p>类似于<code>get()</code>和<code>put()</code>函数，因为Buffer是实现类返回和写入类型不同，所以在Buffer类上没有这两个接口。<br>同样Buffer类上也没有创建缓冲区的方法<code>allocate(int)</code>。<br>下面我们以ByteBuffer为例看一下一些创建缓冲区的关键函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// This is a partial API listing</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] <span class="title">array</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="2-使用allocate-int-创建"><a href="#2-使用allocate-int-创建" class="headerlink" title="2. 使用allocate(int)创建"></a>2. 使用allocate(int)创建</h3><p>缓冲区的创建是由分配或者包装操作来实现的。当我们要分配一个容量为100的<code>ByteBuffer</code>的时候可以执行下面这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p><p>函数源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new byte buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer's position will be zero, its limit will be its</span></span><br><span class="line"><span class="comment"> * capacity, its mark will be undefined, and each of its elements will be</span></span><br><span class="line"><span class="comment"> * initialized to zero.  It will have a &#123;<span class="doctag">@link</span> #array backing array&#125;,</span></span><br><span class="line"><span class="comment"> * and its &#123;<span class="doctag">@link</span> #arrayOffset array offset&#125; will be zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  capacity</span></span><br><span class="line"><span class="comment"> *         The new buffer's capacity, in bytes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          If the &lt;tt&gt;capacity&lt;/tt&gt; is a negative integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到他实际创建的是一个以堆为存储方式的<code>ByteBuffer</code>。也就是<code>HeapByteBuffer</code>。<br>通过阅读<code>HeapByteBuffer</code>的构造方法可以发现实际就是创建了一个大小为容量的byte数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HeapByteBuffer(<span class="keyword">int</span> cap, <span class="keyword">int</span> lim) &#123;            <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, lim, cap, <span class="keyword">new</span> <span class="keyword">byte</span>[cap], <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    hb = new byte[cap];</span></span><br><span class="line"><span class="comment">    offset = 0;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-使用warp-创建"><a href="#3-使用warp-创建" class="headerlink" title="3. 使用warp()创建"></a>3. 使用warp()创建</h3><p>当我们自己创建了一个数组作为缓冲区的备份存储器，就可以使用<code>warp()</code>函数进行创建<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> [] myArray = <span class="keyword">new</span> <span class="keyword">byte</span> [<span class="number">100</span>];</span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap(myArray);</span><br></pre></td></tr></table></figure></p><p>源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wraps a byte array into a buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer will be backed by the given byte array;</span></span><br><span class="line"><span class="comment"> * that is, modifications to the buffer will cause the array to be modified</span></span><br><span class="line"><span class="comment"> * and vice versa.  The new buffer's capacity will be</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;array.length&lt;/tt&gt;, its position will be &lt;tt&gt;offset&lt;/tt&gt;, its limit</span></span><br><span class="line"><span class="comment"> * will be &lt;tt&gt;offset + length&lt;/tt&gt;, and its mark will be undefined.  Its</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #array backing array&#125; will be the given array, and</span></span><br><span class="line"><span class="comment"> * its &#123;<span class="doctag">@link</span> #arrayOffset array offset&#125; will be zero.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array</span></span><br><span class="line"><span class="comment"> *         The array that will back the new buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  offset</span></span><br><span class="line"><span class="comment"> *         The offset of the subarray to be used; must be non-negative and</span></span><br><span class="line"><span class="comment"> *         no larger than &lt;tt&gt;array.length&lt;/tt&gt;.  The new buffer's position</span></span><br><span class="line"><span class="comment"> *         will be set to this value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  length</span></span><br><span class="line"><span class="comment"> *         The length of the subarray to be used;</span></span><br><span class="line"><span class="comment"> *         must be non-negative and no larger than</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;array.length - offset&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         The new buffer's limit will be set to &lt;tt&gt;offset + length&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> *          If the preconditions on the &lt;tt&gt;offset&lt;/tt&gt; and &lt;tt&gt;length&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *          parameters do not hold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们看看<code>HeapByteBuffer</code>如何创建，源码如下。<br>通过阅读源码可以知道实际上<code>warp()</code>函数并不是将offset开始的长度为length的数据创建。而是将整个数组的数据都写入缓冲区的备份存储器，并且这个缓冲区的位置为offset，上界为offset + length，容量为数组大小，标记未初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HeapByteBuffer(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123; <span class="comment">// package-private</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以看到mark标记位为-1</span></span><br><span class="line"><span class="comment">     * 位置为offset</span></span><br><span class="line"><span class="comment">     * 上界为offset+length</span></span><br><span class="line"><span class="comment">     * 容量为数组的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, off, off + len, buf.length, buf, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    hb = buf;</span></span><br><span class="line"><span class="comment">    offset = 0;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 他的父类构造器如下</span></span><br><span class="line">ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,   <span class="comment">// package-private</span></span><br><span class="line">                 <span class="keyword">byte</span>[] hb, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">    <span class="keyword">this</span>.hb = hb;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>通过 allocate()或者 wrap()函数创建的缓冲区通常都是间接的，直接缓冲区我们会在后续进行讨论。</p></blockquote><h3 id="4-array-或者arrayOffset-，hasArray-介绍"><a href="#4-array-或者arrayOffset-，hasArray-介绍" class="headerlink" title="4. array()或者arrayOffset()，hasArray()介绍"></a>4. array()或者arrayOffset()，hasArray()介绍</h3><ul><li>使用<code>hasArray()</code>函数来判断缓冲区是够有一个可以存取的备份数组，</li><li>使用<code>array()</code>函数来获取对应的字节数组，</li><li>使用<code>arrayOffset()</code>获取缓冲区第一个元素在这个缓冲区的的偏移量(从数组头 0 开始计算)，如果您使用了带有三个参数的版本的<code>wrap()</code>函数来创建一个缓冲区，则<code>arrayOffset()</code>会一直返回 0，然而，如果 您切分了（可以使用<code>slice()</code>函数）由一个数组提供存储的缓冲区，得到的缓冲区可能会有一个非0的数组偏移量。这个数组偏移量和缓冲区容量值会告诉您数组中哪些元素是被缓冲区使用的。。</li></ul><blockquote><p>在调用<code>array()</code>或者<code>arrayOffset()</code>前应该使用<code>hasArray()</code>来判断数组是否存在，否则会抛出异常<br>下面是三个函数的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tells whether or not this buffer is backed by an accessible byte</span></span><br><span class="line"><span class="comment"> * array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If this method returns &lt;tt&gt;true&lt;/tt&gt; then the &#123;<span class="doctag">@link</span> #array() array&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> #arrayOffset() arrayOffset&#125; methods may safely be invoked.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &lt;tt&gt;true&lt;/tt&gt; if, and only if, this buffer</span></span><br><span class="line"><span class="comment"> *          is backed by an array and is not read-only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (hb != <span class="keyword">null</span>) &amp;&amp; !isReadOnly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the byte array that backs this</span></span><br><span class="line"><span class="comment"> * buffer&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Modifications to this buffer's content will cause the returned</span></span><br><span class="line"><span class="comment"> * array's content to be modified, and vice versa.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #hasArray hasArray&#125; method before invoking this</span></span><br><span class="line"><span class="comment"> * method in order to ensure that this buffer has an accessible backing</span></span><br><span class="line"><span class="comment"> * array.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The array that backs this buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ReadOnlyBufferException</span></span><br><span class="line"><span class="comment"> *          If this buffer is backed by an array but is read-only</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  UnsupportedOperationException</span></span><br><span class="line"><span class="comment"> *          If this buffer is not backed by an accessible array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] array() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> hb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the offset within this buffer's backing array of the first</span></span><br><span class="line"><span class="comment"> * element of the buffer&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If this buffer is backed by an array then buffer position &lt;i&gt;p&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * corresponds to array index &lt;i&gt;p&lt;/i&gt;&amp;nbsp;+&amp;nbsp;&lt;tt&gt;arrayOffset()&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #hasArray hasArray&#125; method before invoking this</span></span><br><span class="line"><span class="comment"> * method in order to ensure that this buffer has an accessible backing</span></span><br><span class="line"><span class="comment"> * array.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The offset within this buffer's array</span></span><br><span class="line"><span class="comment"> *          of the first element of the buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ReadOnlyBufferException</span></span><br><span class="line"><span class="comment"> *          If this buffer is backed by an array but is read-only</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  UnsupportedOperationException</span></span><br><span class="line"><span class="comment"> *          If this buffer is not backed by an accessible array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="三、复制缓冲区"><a href="#三、复制缓冲区" class="headerlink" title="三、复制缓冲区"></a>三、复制缓冲区</h2><p>首先我们先介绍一个概念</p><blockquote><p>我们可以创建描述从外部存储到数组中的数据元素的缓冲区对象。但是缓冲区不限于管理数组中的外部数据。它们也能管理其他缓冲区中的外部数据。当一个管理其他缓冲器所包含的数据元素的缓冲器被创建时，这个缓冲器被称为<code>视图缓冲器</code>。</p></blockquote><h3 id="1-相关API-1"><a href="#1-相关API-1" class="headerlink" title="1. 相关API"></a>1. 相关API</h3><p>复制缓冲区就是从当前缓冲区对象中复制出来一个新的缓冲区对象，我们以<code>ByteBuffer</code>为例，相关的api如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// This is a partial API listing</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">slice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-使用duplicate-复制"><a href="#2-使用duplicate-复制" class="headerlink" title="2. 使用duplicate()复制"></a>2. 使用duplicate()复制</h3><p>首先介绍<code>duplicate()</code>函数，他是创建一个共享当前缓冲区内容的新缓冲区，两个缓冲区共享数据元素，一个缓冲区数据的改变也会影响另一个缓冲区中的数据。但是每个缓冲区拥有各自的位置，上界，标记属性。如果原始的缓冲区为只读或者直接缓冲区，新的缓冲区也将继承这些属性（直接缓冲区的内容会在后续进行介绍）。<br>函数源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new byte buffer that shares this buffer's content.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The content of the new buffer will be that of this buffer.  Changes</span></span><br><span class="line"><span class="comment"> * to this buffer's content will be visible in the new buffer, and vice</span></span><br><span class="line"><span class="comment"> * versa; the two buffers' position, limit, and mark values will be</span></span><br><span class="line"><span class="comment"> * independent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer's capacity, limit, position, and mark values will be</span></span><br><span class="line"><span class="comment"> * identical to those of this buffer.  The new buffer will be direct if,</span></span><br><span class="line"><span class="comment"> * and only if, this buffer is direct, and it will be read-only if, and</span></span><br><span class="line"><span class="comment"> * only if, this buffer is read-only.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法的实现以HeapByteBuffer为例实现如下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb,</span><br><span class="line">                            <span class="keyword">this</span>.markValue(),</span><br><span class="line">                            <span class="keyword">this</span>.position(),</span><br><span class="line">                            <span class="keyword">this</span>.limit(),</span><br><span class="line">                            <span class="keyword">this</span>.capacity(),</span><br><span class="line">                            offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-使用asReadOnlyBuffer-复制"><a href="#3-使用asReadOnlyBuffer-复制" class="headerlink" title="3. 使用asReadOnlyBuffer()复制"></a>3. 使用asReadOnlyBuffer()复制</h3><p>我们还可以使用<code>asReadOnlyBuffer()</code>函数来生成一个只读的缓冲区视图。与<code>duplicate()</code>相比，这种方式创建的新缓冲区不允许使用<code>put()</code>，并且其<code>isReadOnly()</code>函数将会返回true。对这一只读缓冲区的<code>put()</code>函数的调用尝试会导致抛出<code>ReadOnlyBufferException</code>异常。<br>函数源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, read-only byte buffer that shares this buffer's</span></span><br><span class="line"><span class="comment"> * content.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The content of the new buffer will be that of this buffer.  Changes</span></span><br><span class="line"><span class="comment"> * to this buffer's content will be visible in the new buffer; the new</span></span><br><span class="line"><span class="comment"> * buffer itself, however, will be read-only and will not allow the shared</span></span><br><span class="line"><span class="comment"> * content to be modified.  The two buffers' position, limit, and mark</span></span><br><span class="line"><span class="comment"> * values will be independent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer's capacity, limit, position, and mark values will be</span></span><br><span class="line"><span class="comment"> * identical to those of this buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If this buffer is itself read-only then this method behaves in</span></span><br><span class="line"><span class="comment"> * exactly the same way as the &#123;<span class="doctag">@link</span> #duplicate duplicate&#125; method.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new, read-only byte buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法的实现以HeapByteBuffer为例实现如下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处创建的是一个只读ByteBuffer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBufferR(hb,</span><br><span class="line">                             <span class="keyword">this</span>.markValue(),</span><br><span class="line">                             <span class="keyword">this</span>.position(),</span><br><span class="line">                             <span class="keyword">this</span>.limit(),</span><br><span class="line">                             <span class="keyword">this</span>.capacity(),</span><br><span class="line">                             offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们来尝试复制一个缓冲区<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">buffer.position(<span class="number">3</span>).limit(<span class="number">6</span>).mark().position(<span class="number">5</span>);</span><br><span class="line">ByteBuffer dupeBuffer = buffer.duplicate();</span><br><span class="line">buffer.clear();</span><br></pre></td></tr></table></figure></p><p>执行完后两个缓冲区数据如下图<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/BE251E19-10DB-4FC9-9532-ED0D564C6796_4_5005_c.jpeg" alt="img"></p><h3 id="4-使用slice-切片复制"><a href="#4-使用slice-切片复制" class="headerlink" title="4. 使用slice()切片复制"></a>4. 使用slice()切片复制</h3><p>分割缓冲区与复制相似，但是<code>slice()</code>创建了一个从原始缓冲区的当前位置开始的信缓冲区，并且新缓冲区的容量是原始缓冲区的剩余数量也就是(<code>limit-position</code>)。这个新缓冲区与原始缓冲区共享一段数据元素子序列。分割出来的缓冲区也会继承只读和直接属性。<br>源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new byte buffer whose content is a shared subsequence of</span></span><br><span class="line"><span class="comment"> * this buffer's content.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The content of the new buffer will start at this buffer's current</span></span><br><span class="line"><span class="comment"> * position.  Changes to this buffer's content will be visible in the new</span></span><br><span class="line"><span class="comment"> * buffer, and vice versa; the two buffers' position, limit, and mark</span></span><br><span class="line"><span class="comment"> * values will be independent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer's position will be zero, its capacity and its limit</span></span><br><span class="line"><span class="comment"> * will be the number of bytes remaining in this buffer, and its mark</span></span><br><span class="line"><span class="comment"> * will be undefined.  The new buffer will be direct if, and only if, this</span></span><br><span class="line"><span class="comment"> * buffer is direct, and it will be read-only if, and only if, this buffer</span></span><br><span class="line"><span class="comment"> * is read-only.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">slice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法的实现以HeapByteBuffer为例实现如下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="keyword">this</span>.position();</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="keyword">this</span>.limit();</span><br><span class="line">    <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 这里我们可以看到slice创建的ByteBuffer与之前带有三个参数的版本的wrap()函数来创建一个缓冲区不同</span></span><br><span class="line">    <span class="comment">// 这里新缓冲区的offset不是0而是原始缓冲区的pos + offset</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb,</span><br><span class="line">                            -<span class="number">1</span>,</span><br><span class="line">                            <span class="number">0</span>,</span><br><span class="line">                            rem,</span><br><span class="line">                            rem,</span><br><span class="line">                            pos + offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们尝试分割一个缓冲区<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">buffer.position(<span class="number">3</span>).limit(<span class="number">5</span>);</span><br><span class="line">ByteBuffer sliceBuffer = buffer.slice();</span><br></pre></td></tr></table></figure></p><p>创建的缓冲区如下<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/E9421FD9-DA4B-4E4E-83E1-DABC5017BB6C_4_5005_c.jpeg" alt="img"></p><p>要创建一个映射到位置12-20(9个元素)的 buffer对象，应使用下面的代码实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] myBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">ByteBuffer cb = ByteBuffer.wrap(myBuffer);</span><br><span class="line">cb.position(<span class="number">12</span>).limit(<span class="number">21</span>);</span><br><span class="line">ByteBuffer sliced = cb.slice();</span><br></pre></td></tr></table></figure></p><h2 id="四、字节缓冲区"><a href="#四、字节缓冲区" class="headerlink" title="四、字节缓冲区"></a>四、字节缓冲区</h2><p>所有的基本数据类型都有相应的缓冲区类(布尔型除外)，但字节缓冲区有自己的独特之处。字节是操作系统及其 I/O 设备使用的基本数据类型。当在 JVM 和操作系统间传递数据时，将其他的数据类型拆分成构成它们的字节是十分必要的。如我们在后面的章节中将要看到的那样，系统层次的 I/O 面向字节的性质可以在整个缓冲区的设计以及它们互相配合的服务中感受到。</p><h3 id="1-ByteBuffer类完整API"><a href="#1-ByteBuffer类完整API" class="headerlink" title="1. ByteBuffer类完整API"></a>1. ByteBuffer类完整API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.nio;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">slice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] <span class="title">array</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(ByteBuffer src)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> ByteOrder <span class="title">order</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">order</span><span class="params">(ByteOrder bo)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> CharBuffer <span class="title">asCharBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ShortBuffer <span class="title">asShortBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IntBuffer <span class="title">asIntBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> LongBuffer <span class="title">asLongBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FloatBuffer <span class="title">asFloatBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DoubleBuffer <span class="title">asDoubleBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putChar</span><span class="params">(<span class="keyword">char</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putChar</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putShort</span><span class="params">(<span class="keyword">short</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putShort</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">short</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putInt</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putLong</span><span class="params">(<span class="keyword">long</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putLong</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">long</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putFloat</span><span class="params">(<span class="keyword">float</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putFloat</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">float</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putDouble</span><span class="params">(<span class="keyword">double</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putDouble</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">double</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">compact</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object ob)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object ob)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-字节顺序"><a href="#2-字节顺序" class="headerlink" title="2. 字节顺序"></a>2. 字节顺序</h3><p>此章忽略</p><h3 id="3-直接缓冲区"><a href="#3-直接缓冲区" class="headerlink" title="3. 直接缓冲区"></a>3. 直接缓冲区</h3><p><strong>推荐观看这个up的视频，讲的非常好</strong> <a href="https://www.bilibili.com/video/BV1ar4y1J7mC?p=11" target="_blank" rel="noopener"><strong>视频链接</strong></a></p><p>首先简单概括一下什么是直接缓冲区</p><blockquote><p>在我们之前使用的缓冲区都是堆内的缓冲区，而直接缓冲区则是可以从堆外申请内存来进行数据的保存，采用操作系统本地的I/O会比堆缓冲区更快一些。</p></blockquote><p>下面我们摘抄一下JAVA NIO一书中的介绍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">操作系统的在内存区域中进行 I/O 操作。这些内存区域，就操作系统方面而言，是相连的字节序列。于是，毫无疑问，只有字节缓冲区有资格参与I/O 操作。也请回想一下操作系统会直接存取进程——在本例中是 JVM 进程的内存空间，以传输数据。这也意味着 I/O 操作的目标内存区域必须是连续的字节序列。在 JVM 中，字节数组可能不会在内存中连续存储，或者无用存储单元收集可能随时对其进行移动。在 Java 中，数组是对象，而数据存储在对象中的方式在不同的 JVM 实现中都各有不同。</span><br><span class="line">出于这一原因，引入了直接缓冲区的概念。直接缓冲区被用于与通道和固有 I/O 例程交互。它们通过使用固有代码来告知操作系统直接释放或填充内存区域，对用于通道直接或原始存取的内存区域中的字节元素的存储尽了最大的努力。</span><br><span class="line"></span><br><span class="line">直接字节缓冲区通常是 I/O 操作最好的选择。在设计方面，它们支持 JVM 可用的最高效 I/O 机制。非直接字节缓冲区可以被传递给通道，但是这样可能导致性能损耗。通常非直接缓冲不可能成为一个本地 I/O 操作的目标。如果您向一个通道中传递一个非直接 ByteBuffer 对象用于写入，通道可能会在每次调用中隐含地进行下面的操作:</span><br><span class="line">1.创建一个临时的直接 ByteBuffer 对象。</span><br><span class="line">2.将非直接缓冲区的内容复制到临时缓冲中。</span><br><span class="line">3.使用临时缓冲区执行低层次 I/O 操作。</span><br><span class="line">4.临时缓冲区对象离开作用域，并最终成为被回收的无用数据。</span><br><span class="line"></span><br><span class="line">这可能导致缓冲区在每个 I/O 上复制并产生大量对象，而这种事都是我们极力避免的。不过，依靠工具，事情可以不这么糟糕。运行时间可能会缓存并重新使用直接缓冲区或者执行其他一些聪明的技巧来提高吞吐量。如果您仅仅为一次使用而创建了一个缓冲区，区别并不是很明显。另一方面，如果您将在一段高性能脚本中重复使用缓冲区，分配直接缓冲区并重新使用它们会使您游刃有余。</span><br><span class="line">直接缓冲区时 I/O 的最佳选择，但可能比创建非直接缓冲区要花费更高的成本。直接缓冲区使用的内存是通过调用本地操作系统方面的代码分配的，绕过了标准 JVM 堆栈。建立和销毁直接缓冲区会明显比具有堆栈的缓冲区更加优秀，这取决于主操作系统以及 JVM 实现。直接缓冲区的内存区域不受无用存储单元收集支配，因为它们位于标准 JVM 堆栈之外。</span><br><span class="line"></span><br><span class="line">使用直接缓冲区或非直接缓冲区的性能权衡会因JVM，操作系统，以及代码设计而产生巨大差异。通过分配堆栈外的内存，您可以使您的应用程序依赖于JVM未涉及的其它力量。当加入其他的移动部分时，确定您正在达到想要的效果。我以一条旧的软件行业格言建议您:先使其工作，再加快其运行。不要一开始就过多担心优化问题;首先要注重正确性。JVM实现可能会执行缓冲区缓存或其他的优化，这会在不需要您参与许多不必要工作的情况下为您提供所需的性能。</span><br></pre></td></tr></table></figure></p><h4 id="3-1-创建直接缓冲区"><a href="#3-1-创建直接缓冲区" class="headerlink" title="3.1 创建直接缓冲区"></a>3.1 创建直接缓冲区</h4><p>下面我们从ByteBuffer的allocateDirect()函数中探寻一下他是如何创建一个直接缓冲区<br>下面是函数源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new direct byte buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer's position will be zero, its limit will be its</span></span><br><span class="line"><span class="comment"> * capacity, its mark will be undefined, and each of its elements will be</span></span><br><span class="line"><span class="comment"> * initialized to zero.  Whether or not it has a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #hasArray backing array&#125; is unspecified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  capacity</span></span><br><span class="line"><span class="comment"> *         The new buffer's capacity, in bytes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          If the &lt;tt&gt;capacity&lt;/tt&gt; is a negative integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到到我们创建一个直接缓冲区时，他会去new一个DirectByteBuffer对象<br>下面是DirectByteBuffer类的构造方法，从下面我们可以看到直接缓冲区是使用java的unsafe类直接申请内存。<br>那申请的内存在清除后什么时候被回收，我们可以深入阅读Cleaner类。在里面我们可以看到他其实是一个虚引用的类，当他没有被强引用的情况下就会被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    <span class="comment">// 基础的定义上界，位置，容量，标记位等信息</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="comment">// 是否直接内存分页对齐，操作系统相关信息</span></span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="comment">// 页大小</span></span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="comment">// 计算需要申请的内存大小</span></span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 判断内存是否足够</span></span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试申请内存</span></span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        <span class="comment">// 如果出现OOM将一开始的保留内存进行释放</span></span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将申请的内存中的数据进行置0</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算申请的内存空间的地址并赋值给address</span></span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个cleaner对象</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    <span class="comment">// 这个参数的含义我们会在后面的直接缓冲区的复制那部分降到</span></span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们看看cleaner中的实际如何进行内存的释放<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deallocator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Deallocator</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> size, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (address != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果地址为0，表示已经被释放过了</span></span><br><span class="line">        <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Paranoia</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将内存进行释放</span></span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">        <span class="comment">// 将地址置0</span></span><br><span class="line">        address = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 取消保留内存</span></span><br><span class="line">        Bits.unreserveMemory(size, capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-2-直接缓冲区如何get"><a href="#3-2-直接缓冲区如何get" class="headerlink" title="3.2 直接缓冲区如何get()"></a>3.2 直接缓冲区如何get()</h4><p>下面是方法源码，从源码中我们可以看到在获取数据的时候，会通过，计算地址所在的位置来获取对应的数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((unsafe.getByte(ix(nextGetIndex()))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> address + ((<span class="keyword">long</span>)i &lt;&lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks the current position against the limit, throwing a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * BufferUnderflowException&#125; if it is not smaller than the limit, and then</span></span><br><span class="line"><span class="comment"> * increments the position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The current position value, before it is incremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">int</span> p = position;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    position = p + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>get(int)函数再次就不再进行介绍，自行阅读源码</p></blockquote><h4 id="3-3-直接缓冲区如何put"><a href="#3-3-直接缓冲区如何put" class="headerlink" title="3.3 直接缓冲区如何put()"></a>3.3 直接缓冲区如何put()</h4><p>下面是方法源码，从源码中我们可以看到与get逻辑类似，获取到下一步要put数据的地址，然后将数据写入内存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    unsafe.putByte(ix(nextPutIndex()), ((x)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> address + ((<span class="keyword">long</span>)i &lt;&lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks the current position against the limit, throwing a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * BufferOverflowException&#125; if it is not smaller than the limit, and then</span></span><br><span class="line"><span class="comment"> * increments the position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The current position value, before it is incremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">int</span> p = position;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    position = p + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>put(int)函数再次就不再进行介绍，自行阅读源码</p></blockquote><h4 id="3-4-复制直接缓冲区"><a href="#3-4-复制直接缓冲区" class="headerlink" title="3.4 复制直接缓冲区"></a>3.4 复制直接缓冲区</h4><p>下面我们看看直接缓冲区如何进行复制<br>我们从复制的源码入手<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(<span class="keyword">this</span>,</span><br><span class="line">                              <span class="keyword">this</span>.markValue(),</span><br><span class="line">                              <span class="keyword">this</span>.position(),</span><br><span class="line">                              <span class="keyword">this</span>.limit(),</span><br><span class="line">                              <span class="keyword">this</span>.capacity(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DirectByteBuffer(DirectBuffer db,         <span class="comment">// package-private</span></span><br><span class="line">               <span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,</span><br><span class="line">               <span class="keyword">int</span> off) &#123;</span><br><span class="line">    <span class="comment">// 基础的定义上界，位置，容量，标记位等信息</span></span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">    <span class="comment">// 将被复制对象的内存地址赋值给复制的缓冲区对象</span></span><br><span class="line">    address = db.address() + off;</span><br><span class="line">    <span class="comment">// 这里的cleaner不需要赋值，因为他本身不需要去考虑内存的释放，实际的释放是由被复制的对象进行</span></span><br><span class="line">    cleaner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从这里我们就知道att的作用了，因为我们所谓的复制是和被复制的缓冲区对象使用同一片内存，</span></span><br><span class="line">    <span class="comment">// 假设被复制的缓冲区对象没有被任何对象强引用，这个时候就可能会被JVM的GC删除，所以我们让att强引用了被复制的缓冲区对象，这样哪怕被复制的缓冲区对象被原来强引用的对象断除引用也不会导致这块内存被垃圾回收</span></span><br><span class="line">    att = db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>slice()函数再次就不再进行介绍，自行阅读源码</p></blockquote><h3 id="4-视图缓冲区"><a href="#4-视图缓冲区" class="headerlink" title="4. 视图缓冲区"></a>4. 视图缓冲区</h3><p>我们之前已经见过了一些的简单例子，在例子中一个缓冲区被复制和切分。ByteBuffer 类允许创建视图来将 byte 型缓冲区字节数据映射为其它的原始数据类型。例如，asLongBuffer()函数 创建一个将八个字节型数据当成一个 long 型数据来存取的视图缓冲区。<br>下面列出的每一个工厂方法都在原有的 ByteBuffer 对象上创建一个视图缓冲区。调用其中的任何一个方法都会创建对应的缓冲区类型，这个缓冲区是基础缓冲区的一个切分，由基 础缓冲区的位置和上界决定。新的缓冲区的容量是字节缓冲区中存在的元素数量除以视图类型中组成一个数据类型的字节数。在切分中任一个超过上界的元素对于这个视图 缓冲区都是不可见的。视图缓冲区的第一个元素从创建它的 ByteBuffer 对象的位置开始 (positon()函数的返回值)。具有能被自然数整除的数据元素个数的视图缓冲区是一种较好的实现。</p><h4 id="4-1-视图缓冲区相关API"><a href="#4-1-视图缓冲区相关API" class="headerlink" title="4.1 视图缓冲区相关API"></a>4.1 视图缓冲区相关API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">// This is a partial API listing</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> CharBuffer <span class="title">asCharBuffer</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ShortBuffer <span class="title">asShortBuffer</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IntBuffer <span class="title">asIntBuffer</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> LongBuffer <span class="title">asLongBuffer</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FloatBuffer <span class="title">asFloatBuffer</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DoubleBuffer <span class="title">asDoubleBuffer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-ByteBuffer-gt-CharBuffer"><a href="#4-2-ByteBuffer-gt-CharBuffer" class="headerlink" title="4.2 ByteBuffer -&gt; CharBuffer"></a>4.2 ByteBuffer -&gt; CharBuffer</h4><p>下面我们就医ByteBuffer -&gt; CharBuffer为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">7</span>).order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">CharBuffer charBuffer = byteBuffer.asCharBuffer();</span><br></pre></td></tr></table></figure></p><p>下面是复制的charBuffer的视图<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/370474B0-530E-48AF-B7D3-3AB0235AB516_4_5005_c.jpeg" alt="img"></p><p>下面我们尝试代码运行一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferCharView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">7</span>).order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">        CharBuffer charBuffer = byteBuffer.asCharBuffer();</span><br><span class="line">        <span class="comment">// Load the ByteBuffer with some bytes</span></span><br><span class="line">        byteBuffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        byteBuffer.put(<span class="number">1</span>, (<span class="keyword">byte</span>) <span class="string">'H'</span>);</span><br><span class="line">        byteBuffer.put(<span class="number">2</span>, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        byteBuffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>) <span class="string">'i'</span>);</span><br><span class="line">        byteBuffer.put(<span class="number">4</span>, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        byteBuffer.put(<span class="number">5</span>, (<span class="keyword">byte</span>) <span class="string">'!'</span>);</span><br><span class="line">        byteBuffer.put(<span class="number">6</span>, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        println(byteBuffer);</span><br><span class="line">        println(charBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print info about a buffer</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"pos="</span> + buffer.position() + <span class="string">", limit="</span> + buffer.limit() + <span class="string">", capacity="</span> + buffer.capacity() </span><br><span class="line">                + <span class="string">": '"</span> + buffer.toString() + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos=<span class="number">0</span>, limit=<span class="number">7</span>, capacity=<span class="number">7</span>: <span class="string">'java.nio.HeapByteBuffer[pos=0 lim=7 cap=7]'</span></span><br><span class="line">pos=<span class="number">0</span>, limit=<span class="number">3</span>, capacity=<span class="number">3</span>: <span class="string">'Hi!'</span></span><br></pre></td></tr></table></figure></p><h3 id="5-数据元素视图"><a href="#5-数据元素视图" class="headerlink" title="5. 数据元素视图"></a>5. 数据元素视图</h3><p>ByteBuffer 类提供了一个不太重要的机制来以多字节数据类型的形式存取 byte 数据组。ByteBuffer类为每一种原始数据类型提供了存取的和转化的方法:</p><h4 id="5-1-数据元素视图相关API"><a href="#5-1-数据元素视图相关API" class="headerlink" title="5.1 数据元素视图相关API"></a>5.1 数据元素视图相关API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">public</span> <span class="title">abstract</span> <span class="title">char</span> <span class="title">getChar</span>( )</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">getChar</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">getShort</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getInt</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLong</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">getFloat</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getDouble</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putChar</span> <span class="params">(<span class="keyword">char</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putChar</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putShort</span> <span class="params">(<span class="keyword">short</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putShort</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">short</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putInt</span> <span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putInt</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putLong</span> <span class="params">(<span class="keyword">long</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putLong</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">long</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putFloat</span> <span class="params">(<span class="keyword">float</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putFloat</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">float</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putDouble</span> <span class="params">(<span class="keyword">double</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putDouble</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">double</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-从ByteBuffer中获取int或者long类型元素"><a href="#5-2-从ByteBuffer中获取int或者long类型元素" class="headerlink" title="5.2 从ByteBuffer中获取int或者long类型元素"></a>5.2 从ByteBuffer中获取int或者long类型元素</h4><p>假设一个叫 buffer 的 ByteBuffer 对象处于下图的状态。<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/BD8A5C19-D9A9-4440-B63B-861E9C01091E_4_5005_c.jpeg" alt="img"></p><p>这段代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = buffer.getInt( );</span><br></pre></td></tr></table></figure></p><p>由于int为4个字节，会返回一个由缓冲区中位置 1-4 的 byte 数据值组成的 int 型变量的值。实际的返回值取决于缓冲区的当前的比特排序(byte-order)设置。<br>更具体的写法是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = buffer.order (ByteOrder.BIG_ENDIAN).getInt( );</span><br></pre></td></tr></table></figure></p><p>这将会返回值 0x3BC5315E，同时:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = buffer.order (ByteOrder.LITTLE_ENDIAN).getInt( );</span><br></pre></td></tr></table></figure></p><p>返回值 0x5E31C53B。</p><p>如果您试图获取的原始类型需要比缓冲区中存在的字节数更多的字节，会抛出 BufferUnderflowException。如我们执行下面这行代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个 long 型变量是 8 个字节的，但是缓冲区中只有 5 个字节，所以会抛出 BufferUnderflowException</span></span><br><span class="line"><span class="keyword">long</span> value = buffer.getLong( );</span><br></pre></td></tr></table></figure></p><h3 id="6-内存映射缓冲区"><a href="#6-内存映射缓冲区" class="headerlink" title="6. 内存映射缓冲区"></a>6. 内存映射缓冲区</h3><p>映射缓冲区是带有存储在文件，通过内存映射来存取数据元素的字节缓冲区。映射缓冲区通常是直接存取内存的，只能通过 FileChannel 类创建。映射缓冲区的用法和直接缓冲区类似，但是 MappedByteBuffer 对象可以处理独立于文件存取形式的的许多特定字符。出于这个原因，我们会在讲内存映射文件的时候讲到这部分内容。</p>]]></content>
    
    <summary type="html">
    
      本文是对Java NIO一书中缓冲区这一章节的总结，并将相关源码进行了注释和解读。
    
    </summary>
    
      <category term="Java" scheme="http://suiwo.xyz/categories/Java/"/>
    
    
      <category term="Java" scheme="http://suiwo.xyz/tags/Java/"/>
    
      <category term="NIO" scheme="http://suiwo.xyz/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Flink常见知识点</title>
    <link href="http://suiwo.xyz/2022/08/26/Flink%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://suiwo.xyz/2022/08/26/Flink常见知识点/</id>
    <published>2022-08-26T07:11:57.000Z</published>
    <updated>2023-01-07T15:50:28.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-讲一下flink的运行架构"><a href="#1-讲一下flink的运行架构" class="headerlink" title="1.讲一下flink的运行架构"></a>1.讲一下flink的运行架构</h3><p>当flink集群启动后，首先会启动一个JobManager和一个或者多个TaskManager。有Client提交任务给JobManager，JobManager在调度任务到各个TaskManager去执行，然后 TaskManager 将心跳和统计信息汇报给 JobManager。TaskManager 之间以流的形式进行数据的传输。上述三者均为独立的 JVM 进程。</p><ul><li>Client 为提交 Job 的客户端，可以是运行在任何机器上（与 JobManager 环境连通即可）。提交 Job 后，Client 可以结束进程（Streaming的任务），也可以不结束并等待结果返回。</li><li>JobManager 主要负责调度 Job 并协调 Task 做 checkpoint，职责上很像 Storm 的 Nimbus。从 Client 处接收到 Job 和 JAR 包等资源后，会生成优化后的执行计划，并以 Task 的单元调度到各个 TaskManager 去执行。</li><li>TaskManager 在启动的时候就设置好了槽位数（Slot），每个 slot 能启动一个 Task，Task 为线程。从 JobManager 处接收需要部署的 Task，部署启动后，与自己的上游建立 Netty 连接，接收数据并处理。</li></ul><h3 id="2-讲一下flink的作业执行流程"><a href="#2-讲一下flink的作业执行流程" class="headerlink" title="2.讲一下flink的作业执行流程"></a>2.讲一下flink的作业执行流程</h3><ul><li><p>以yarn模式Per-job方式为例概述作业提交执行流程<br>当执行executor() 之后,会首先在本地client 中将代码转化为可以提交的 JobGraph如果提交为Per-Job模式,则首先需要启动AM, client会首先向资源系统申请资源, 在yarn下即为申请container开启AM, 如果是Session模式的话则不需要这个步骤</p></li><li><p>Yarn分配资源, 开启AM</p></li><li>Client将Job提交给Dispatcher</li><li>Dispatcher 会开启一个新的 JobManager线程</li><li>JM 向Flink 自己的 Resourcemanager申请slot资源来执行任务</li><li>RM 向 Yarn申请资源来启动 TaskManger (Session模式跳过此步)</li><li>Yarn 分配 Container 来启动 taskManger (Session模式跳过此步)</li><li>Flink 的 RM 向 TM 申请 slot资源来启动 task</li><li>TM 将待分配的 slot 提供给 JM</li><li>JM 提交 task, TM 会启动新的线程来执行任务,开始启动后就可以通过 shuffle模块进行 task之间的数据交换</li></ul>]]></content>
    
    <summary type="html">
    
      本文将对Flink中常遇到的知识点和面试题进行总结。
    
    </summary>
    
      <category term="Flink" scheme="http://suiwo.xyz/categories/Flink/"/>
    
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Flink" scheme="http://suiwo.xyz/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Kafka常见知识点</title>
    <link href="http://suiwo.xyz/2022/08/26/Kafka%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://suiwo.xyz/2022/08/26/Kafka常见知识点/</id>
    <published>2022-08-26T06:33:55.000Z</published>
    <updated>2023-01-07T15:50:41.286Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-讲一下kafka"><a href="#1-讲一下kafka" class="headerlink" title="1. 讲一下kafka"></a>1. 讲一下kafka</h3><p>Producer: 消息生产者</p><ul><li><p>Producer可以发送消息到Topic</p><ul><li>Topic的消息存放在不同的Partition中，不同Partition存放在不同的Broker中</li><li>Producer值需要指定Topic的名字、要连接到的Broker，这样Kafka就可以自动吧消息数据路由到指定的Broker（不一定是指定连接的Broker）</li></ul></li><li><p>Producer发送消息后，可以选择是否要确认消息写入成功（ACK， Acknowledgment）</p><ul><li>ACK = 0: Producer不会等待ACK（消息可能丢失）</li><li>ACK = 1: Producer会等待Leader Partition的ACK（Follower Partition消息可能丢失）</li><li>ACK = all: Producer会等待Leader Partition和Follower Partition的ACK（消息不会丢失）</li></ul></li><li><p>消息key: Producer可以给消息加上key，带相同key的消息会被分发到同一个Partition，这样就可以保证带相同key的消息的消费是有序的</p></li><li><p>Broker: 每个Broker里包含了不同Topic的不同Partition，Partition中包含了有序的消息</p><ul><li>一个Kafka集群由多个Broker（server）组成</li><li>每个Broker都有ID标识</li><li>每个Broker里保存一定数量的Partition</li><li>客户端只要连接上任意一个Broker，就可以连接上整个Kafka集群</li><li>大多数Kafka集群刚开始的时候建议使用至少3个Broker，集群大了可以有上百个Broker。</li></ul></li></ul><p>Consumer：消息消费者</p><ul><li><p>Consumer可以从Topic读取消息进行消费</p><ul><li>Topic的消息存放在不同Partition中，不同Partition存放在不同Broker中</li><li>Consumer只需要指定Topic的名字、要连接到的Broker，这样Kafka就可以自动地把Consumer路由到合适的Broker拉取消息进行消费（不一定是指定连接的Broker）</li><li>每一个Partition中的消息都会被有序消费</li></ul></li><li><p>Consumer Group</p><ul><li>Consumer Group由多个Consumer组成</li><li>Consumer Group里的每个Consumer都会从不同的Partition中读取消息</li><li>如果Consumer的数量大于Partition的数量，那么多出来的Consumer就会空闲下来（浪费资源）</li></ul></li><li><p>Consumer offset</p><ul><li>Kafka会为Consumer Group要消费的每个Partion保存一个offset，这个offset标记了该Consumer Group最后消费消息的位置</li><li>这个offset保存在Kafka里一个名为“__consumer_offsets”的Topic中；当Consumer从Kafka拉取消息消费时，同时也要对这个offset提交修改更新操作。这样若一个Consumer消费消息时挂了，其他Consumer可以通过这个offset值重新找到上一个消息再进行处理</li></ul></li></ul><h3 id="2-kafka实现高吞吐的原理"><a href="#2-kafka实现高吞吐的原理" class="headerlink" title="2.kafka实现高吞吐的原理"></a>2.kafka实现高吞吐的原理</h3><ul><li>读写文件依赖OS文件系统的页缓存，而不是在JVM内部缓存数据，利用OS来缓存，内存利用率高</li><li>sendfile技术（零拷贝），避免了传统网络IO四步流程</li><li>支持End-to-End的压缩</li><li>顺序IO以及常量时间get、put消息</li><li>Partition 可以很好的横向扩展和提供高并发处理</li></ul>]]></content>
    
    <summary type="html">
    
      本文将对Kafka中常遇到的知识点和面试题进行总结。
    
    </summary>
    
      <category term="Kafka" scheme="http://suiwo.xyz/categories/Kafka/"/>
    
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Kafka" scheme="http://suiwo.xyz/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop常见知识点</title>
    <link href="http://suiwo.xyz/2022/08/24/Hadoop%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://suiwo.xyz/2022/08/24/Hadoop常见知识点/</id>
    <published>2022-08-24T03:07:24.000Z</published>
    <updated>2023-01-07T16:01:59.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-HDFS架构"><a href="#1-HDFS架构" class="headerlink" title="1. HDFS架构"></a>1. HDFS架构</h3><p><img src="/images/Hadoop常见知识点/4093A846-0B4E-4EF1-8DF2-5F175350D92D_4_5005_c.jpeg" alt="4093A846-0B4E-4EF1-8DF2-5F175350D92D_4_5005_c.jpeg"></p><ol><li>Active NameNode和 Standby NameNode：两台NameNode形成互备，处于Active状态的为主NameNode，另一台处于StandBy状态，为备用NameNode，主要主NameNode对外提供读写服务。</li><li>ZKFailoverController（主备切换控制器，FC）：ZKFailoverController 作为独立的进程运行，对 NameNode 的主备切换进行总体控制。ZKFailoverController 能及时检测到 NameNode 的健康状况，在主 NameNode 故障时借助 Zookeeper 实现自动的主备选举和切换（当然 NameNode 目前也支持不依赖于 Zookeeper 的手动主备切换）；</li><li>Zookeeper 集群：为主备切换控制器提供主备选举支持；</li><li>共享存储系统：共享存储系统是实现 NameNode 的高可用最为关键的部分，共享存储系统保存了 NameNode 在运行过程中所产生的 HDFS 的元数据。主 NameNode 和备 NameNode 通过共享存储系统实现元数据同步。在进行主备切换的时候，新的主 NameNode 在确认元数据完全同步之后才能继续对外提供服务。</li><li>DataNode 节点：因为主 NameNode 和备 NameNode 需要共享 HDFS 的数据块和 DataNode 之间的映射关系，为了使故障切换能够快速进行，DataNode 会同时向主 NameNode 和备 NameNode 上报数据块的位置信息。</li></ol><p>FailoverController<br>FC 最初的目的是为了实现 SNN 和 ANN 之间故障自动切换，FC 是独立与 NN 之外的故障切换控制器，ZKFC 作为 NameNode 机器上一个独立的进程启动 ，它启动的时候会创建 HealthMonitor 和 ActiveStandbyElector 这两个主要的内部组件，其中：</p><ol><li>HealthMonitor：主要负责检测 NameNode 的健康状态，如果检测到 NameNode 的状态发生变化，会回调 ZKFailoverController 的相应方法进行自动的主备选举；</li><li>ActiveStandbyElector：主要负责完成自动的主备选举，内部封装了 Zookeeper 的处理逻辑，一旦 Zookeeper 主备选举完成，会回调 ZKFailoverController 的相应方法来进行 NameNode 的主备状态切换。</li></ol><h4 id="自动触发主备选举"><a href="#自动触发主备选举" class="headerlink" title="自动触发主备选举"></a>自动触发主备选举</h4><ol><li><p>NameNode 在选举成功后，会在 zk 上创建了一个 /hadoop-ha/${dfs.nameservices}/ActiveStandbyElectorLock 节点，而没有选举成功的备 NameNode 会监控这个节点，通过 Watcher 来监听这个节点的状态变化事件，ZKFC 的 ActiveStandbyElector 主要关注这个节点的 NodeDeleted 事件（这部分实现跟 Kafka 中 Controller 的选举一样）。</p></li><li><p>如果 Active NameNode 对应的 HealthMonitor 检测到 NameNode 的状态异常时， ZKFailoverController 会主动删除当前在 Zookeeper 上建立的临时节点 /hadoop-ha/${dfs.nameservices}/ActiveStandbyElectorLock，这样处于 Standby 状态的 NameNode 的 ActiveStandbyElector 注册的监听器就会收到这个节点的 NodeDeleted 事件。收到这个事件之后，会马上再次进入到创建 /hadoop-ha/${dfs.nameservices}/ActiveStandbyElectorLock 节点的流程，如果创建成功，这个本来处于 Standby 状态的 NameNode 就选举为主 NameNode 并随后开始切换为 Active 状态。</p></li><li><p>当然，如果是 Active 状态的 NameNode 所在的机器整个宕掉的话，那么根据 Zookeeper 的临时节点特性，/hadoop-ha/${dfs.nameservices}/ActiveStandbyElectorLock 节点会自动被删除，从而也会自动进行一次主备切换。</p></li></ol><h4 id="HDFS-脑裂问题"><a href="#HDFS-脑裂问题" class="headerlink" title="HDFS 脑裂问题"></a>HDFS 脑裂问题</h4><p>在实际中，NameNode 可能会出现这种情况，NameNode 在垃圾回收（GC）时，可能会在长时间内整个系统无响应，因此，也就无法向 zk 写入心跳信息，这样的话可能会导致临时节点掉线，备 NameNode 会切换到 Active 状态，这种情况，可能会导致整个集群会有同时有两个 NameNode，这就是脑裂问题。</p><p>脑裂问题的解决方案是隔离（Fencing），主要是在以下三处采用隔离措施：</p><ul><li>第三方共享存储：任一时刻，只有一个 NN 可以写入；</li><li>DataNode：需要保证只有一个 NN 发出与管理数据副本有关的删除命令；</li><li>Client：需要保证同一时刻只有一个 NN 能够对 Client 的请求发出正确的响应。</li></ul><p>关于这个问题目前解决方案的实现如下：</p><ol><li>ActiveStandbyElector 为了实现 fencing，会在成功创建 Zookeeper 节点 hadoop-ha/${dfs.nameservices}/ActiveStandbyElectorLock 从而成为 Active NameNode 之后，创建另外一个路径为 /hadoop-ha/${dfs.nameservices}/ActiveBreadCrumb 的持久节点，这个节点里面保存了这个 Active NameNode 的地址信息</li><li>Active NameNode 的 ActiveStandbyElector 在正常的状态下关闭 Zookeeper Session 的时候，会一起删除这个持久节点；</li><li><p>但如果 ActiveStandbyElector 在异常的状态下 Zookeeper Session 关闭 (比如前述的 Zookeeper 假死)，那么由于 /hadoop-ha/${dfs.nameservices}/ActiveBreadCrumb 是持久节点，会一直保留下来，后面当另一个 NameNode 选主成功之后，会注意到上一个 Active NameNode 遗留下来的这个节点，从而会回调 ZKFailoverController 的方法对旧的 Active NameNode 进行 fencing。<br>在进行 fencing 的时候，会执行以下的操作：</p><ol><li>首先尝试调用这个旧 Active NameNode 的 HAServiceProtocol RPC 接口的 transitionToStandby 方法，看能不能把它转换为 Standby 状态；</li><li>如果 transitionToStandby 方法调用失败，那么就执行 Hadoop 配置文件之中预定义的隔离措施。</li></ol></li></ol><blockquote><p>Hadoop 目前主要提供两种隔离措施，通常会选择第一种：</p><ul><li>sshfence：通过 SSH 登录到目标机器上，执行命令 fuser 将对应的进程杀死；</li><li>shellfence：执行一个用户自定义的 shell 脚本来将对应的进程隔离。<br>只有在成功地执行完成 fencing 之后，选主成功的 ActiveStandbyElector 才会回调 ZKFailoverController 的 becomeActive 方法将对应的 NameNode 转换为 Active 状态，开始对外提供服务。</li></ul></blockquote><h4 id="HDFS-2-0-Federation-实现"><a href="#HDFS-2-0-Federation-实现" class="headerlink" title="HDFS 2.0 Federation 实现"></a>HDFS 2.0 Federation 实现</h4><p>在 1.0 中，HDFS 的架构设计有以下缺点：</p><ol><li>namespace 扩展性差：在单一的 NN 情况下，因为所有 namespace 数据都需要加载到内存，所以物理机内存的大小限制了整个 HDFS 能够容纳文件的最大个数（namespace 指的是 HDFS 中树形目录和文件结构以及文件对应的 block 信息）；</li><li>性能可扩展性差：由于所有请求都需要经过 NN，单一 NN 导致所有请求都由一台机器进行处理，很容易达到单台机器的吞吐；</li><li>隔离性差：多租户的情况下，单一 NN 的架构无法在租户间进行隔离，会造成不可避免的相互影响。</li></ol><h5 id="Federation-架构"><a href="#Federation-架构" class="headerlink" title="Federation 架构"></a>Federation 架构</h5><p>Federation 的架构设计如下图所示（图片来自 HDFS Federation）：<br><img src="/images/Hadoop常见知识点/8786F522-742E-4650-913D-392BDAB938DA_4_5005_c.jpeg" alt="8786F522-742E-4650-913D-392BDAB938DA_4_5005_c.jpeg"></p><h6 id="Federation-的核心设计思想"><a href="#Federation-的核心设计思想" class="headerlink" title="Federation 的核心设计思想"></a>Federation 的核心设计思想</h6><p>Federation 的核心思想是将一个大的 namespace 划分多个子 namespace，并且每个 namespace 分别由单独的 NameNode 负责，这些 NameNode 之间互相独立，不会影响，不需要做任何协调工作（其实跟拆集群有一些相似），集群的所有 DataNode 会被多个 NameNode 共享。<br>其中，每个子 namespace 和 DataNode 之间会由数据块管理层作为中介建立映射关系，数据块管理层由若干数据块池（Pool）构成，每个数据块只会唯一属于某个固定的数据块池，而一个子 namespace 可以对应多个数据块池。每个 DataNode 需要向集群中所有的 NameNode 注册，且周期性地向所有 NameNode 发送心跳和块报告，并执行来自所有 NameNode 的命令。<br>一个 block pool 由属于同一个 namespace 的数据块组成，每个 DataNode 可能会存储集群中所有 block pool 的数据块；<br>每个 block pool 内部自治，也就是说各自管理各自的 block，不会与其他 block pool 交流，如果一个 NameNode 挂掉了，不会影响其他 NameNode;<br>某个 NameNode 上的 namespace 和它对应的 block pool 一起被称为 namespace volume，它是管理的基本单位。当一个 NameNode/namespace 被删除后，其所有 DataNode 上对应的 block pool 也会被删除，当集群升级时，每个 namespace volume 可以作为一个基本单元进行升级。</p><h3 id="2-Yarn架构"><a href="#2-Yarn架构" class="headerlink" title="2. Yarn架构"></a>2. Yarn架构</h3><p>待完成</p><h3 id="3-MapReduce过程"><a href="#3-MapReduce过程" class="headerlink" title="3. MapReduce过程"></a>3. MapReduce过程</h3><h3 id="4-Yarn-调度MapReduce"><a href="#4-Yarn-调度MapReduce" class="headerlink" title="4. Yarn 调度MapReduce"></a>4. Yarn 调度MapReduce</h3><h3 id="5-HDFS写流程"><a href="#5-HDFS写流程" class="headerlink" title="5. HDFS写流程"></a>5. HDFS写流程</h3><ol><li>Client调用DistributedFileSystem对象的create方法，创建一个文件输出流（FSDataOutputStream）对象。</li><li>通过DistributedFileSystem对象与集群的NameNode进行一次RPC远程调用，在HDFS的Namespace中创建一个文件条目（Entry），此时该条目没有任何block，NameNode会返回该数据每个块需要拷贝的DataNode地址信息。</li><li>通过FSDataOutputStream对象，开始向DataNode写入数据，数据首先被写入FSDataOutputStream对象内部的数据队列中，数据队列由DataStreamer使用，它通过选择合适的DataNode列表来存储副本，从而要求NameNode分配新的block；</li><li>DataStreamer将数据包以流式传输的方式传输到分配的第一个DataNode中，该数据流将数据包存储到第一个 DataNode 中并将其转发到第二个 DataNode 中，接着第二个 DataNode 节点会将数据包转发到第三个 DataNode 节点；</li><li>DataNode 确认数据传输完成，最后由第一个 DataNode 通知 client 数据写入成功；</li><li>完成向文件写入数据，Client 在文件输出流（FSDataOutputStream）对象上调用 close 方法，完成文件写入；</li><li>调用 DistributedFileSystem 对象的 complete 方法，通知 NameNode 文件写入成功，NameNode 会将相关结果记录到 editlog 中。</li></ol><h3 id="6-HDFS读流程"><a href="#6-HDFS读流程" class="headerlink" title="6. HDFS读流程"></a>6. HDFS读流程</h3><ol><li>Client 通过 DistributedFileSystem 对象与集群的 NameNode 进行一次 RPC 远程调用，获取文件 block 位置信息；</li><li>NameNode 返回存储的每个块的 DataNode 列表；</li><li>Client 将连接到列表中最近的 DataNode；</li><li>Client 开始从 DataNode 并行读取数据；</li><li>一旦 Client 获得了所有必须的 block，它就会将这些 block 组合起来形成一个文件。</li></ol><h3 id="7-hdfs创建一个文件的流程"><a href="#7-hdfs创建一个文件的流程" class="headerlink" title="7. hdfs创建一个文件的流程"></a>7. hdfs创建一个文件的流程</h3><ol><li>客户端通过ClientProtocol协议向RpcServer发起创建文件的RPC请求。</li><li>FSNamesystem封装了各种HDFS操作的实现细节，RpcServer调用FSNamesystem中的相关方法以创建目录。</li><li>进一步的，FSDirectory封装了各种目录树操作的实现细节，FSNamesystem调用FSDirectory中的相关方法在目录树中创建目标文件，并通过日志系统备份文件系统的修改。</li><li>最后，RpcServer将RPC响应返回给客户端。</li></ol><h3 id="8-hadoop1-x-和hadoop-2-x-的区别"><a href="#8-hadoop1-x-和hadoop-2-x-的区别" class="headerlink" title="8. hadoop1.x 和hadoop 2.x 的区别"></a>8. hadoop1.x 和hadoop 2.x 的区别</h3><ol><li><p>资源调度方式的改变<br>在1.x, 使用Jobtracker负责任务调度和资源管理,单点负担过重,在2.x中,新增了yarn作为集群的调度工具.在yarn中,使用ResourceManager进行 资源管理, 单独开启一个Container作为ApplicationMaster来进行任务管理.</p></li><li><p>HA模式<br>在1.x中没有HA模式,集群中只有一个NameNode,而在2.x中可以启用HA模式,存在一个Active NameNode 和Standby NameNode.</p></li><li><p>HDFS Federation<br>Hadoop 2.0中对HDFS进行了改进，使NameNode可以横向扩展成多个，每个NameNode分管一部分目录，进而产生了HDFS Federation，该机制的引入不仅增强了HDFS的扩展性，也使HDFS具备了隔离性</p></li></ol><h3 id="9-hadoop-HA介绍"><a href="#9-hadoop-HA介绍" class="headerlink" title="9. hadoop HA介绍"></a>9. hadoop HA介绍</h3><ol><li>Active NameNode 和 Standby NameNode：两台 NameNode 形成互备，一台处于 Active 状态，为主 NameNode，另外一台处于 Standby 状态，为备 NameNode，只有主 NameNode 才能对外提供读写服务；</li><li>ZKFailoverController（主备切换控制器，FC）：ZKFailoverController 作为独立的进程运行，对 NameNode 的主备切换进行总体控制。ZKFailoverController 能及时检测到 NameNode 的健康状况，在主 NameNode 故障时借助 Zookeeper 实现自动的主备选举和切换（当然 NameNode 目前也支持不依赖于 Zookeeper 的手动主备切换）；</li><li>Zookeeper 集群：为主备切换控制器提供主备选举支持；<br>共享存储系统：共享存储系统是实现 NameNode 的高可用最为关键的部分，共享存储系统保存了 NameNode 在运行过程中所产生的 HDFS 的元数据。主 NameNode 和备 NameNode 通过共享存储系统实现元数据同步。在进行主备切换的时候，新的主 NameNode 在确认元数据完全同步之后才能继续对外提供服务。</li><li>DataNode 节点：因为主 NameNode 和备 NameNode 需要共享 HDFS 的数据块和 DataNode 之间的映射关系，为了使故障切换能够快速进行，DataNode 会同时向主 NameNode 和备 NameNode 上报数据块的位置信息。</li></ol><h3 id="10-小文件过多会有什么危害-如何避免"><a href="#10-小文件过多会有什么危害-如何避免" class="headerlink" title="10. 小文件过多会有什么危害,如何避免?"></a>10. 小文件过多会有什么危害,如何避免?</h3><p>Hadoop上大量HDFS元数据信息存储在NameNode内存中,因此过多的小文件必定会压垮NameNode的内存.</p><p>每个元数据对象约占150byte，所以如果有1千万个小文件，每个文件占用一个block，则NameNode大约需要2G空间。如果存储1亿个文件，则NameNode需要20G空间.</p><p>显而易见的解决这个问题的方法就是合并小文件,可以选择在客户端上传时执行一定的策略先合并,或者是使用Hadoop的CombineFileInputFormat&lt;K,V&gt;实现小文件的合并</p><h3 id="11-启动hadoop集群会分别启动哪些进程-各自的作用"><a href="#11-启动hadoop集群会分别启动哪些进程-各自的作用" class="headerlink" title="11. 启动hadoop集群会分别启动哪些进程,各自的作用"></a>11. 启动hadoop集群会分别启动哪些进程,各自的作用</h3><ul><li><p>NameNode：<br>维护文件系统树及整棵树内所有的文件和目录。这些信息永久保存在本地磁盘的两个文件中：命名空间镜像文件、编辑日志文件<br>记录每个文件中各个块所在的数据节点信息，这些信息在内存中保存，每次启动系统时重建这些信息<br>负责响应客户端的 数据块位置请求 。也就是客户端想存数据，应该往哪些节点的哪些块存；客户端想取数据，应该到哪些节点取<br>接受记录在数据存取过程中，datanode节点报告过来的故障、损坏信息</p></li><li><p>SecondaryNameNode(非HA模式)：<br>实现namenode容错的一种机制。定期合并编辑日志与命名空间镜像，当namenode挂掉时，可通过一定步骤进行上顶。(注意 并不是NameNode的备用节点)</p></li><li><p>DataNode：<br>根据需要存取并检索数据块<br>定期向namenode发送其存储的数据块列表</p></li><li><p>ResourceManager：<br>负责Job的调度,将一个任务与一个NodeManager相匹配。也就是将一个MapReduce之类的任务分配给一个从节点的NodeManager来执行。</p></li><li><p>NodeManager：<br>运行ResourceManager分配的任务，同时将任务进度向application master报告</p></li><li><p>JournalNode(HA下启用):<br>高可用情况下存放namenode的editlog文件</p></li></ul>]]></content>
    
    <summary type="html">
    
      本文将对Hadoop中常遇到的知识点和面试题进行总结。
    
    </summary>
    
      <category term="Hadoop" scheme="http://suiwo.xyz/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="http://suiwo.xyz/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="HDFS" scheme="http://suiwo.xyz/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>Spark常见知识点</title>
    <link href="http://suiwo.xyz/2022/08/18/Spark%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://suiwo.xyz/2022/08/18/Spark常见知识点/</id>
    <published>2022-08-18T10:29:20.000Z</published>
    <updated>2023-01-07T15:51:51.019Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/will-che/BigData-Interview" target="_blank" rel="noopener">大数据面试题【github】</a></p><h3 id="1-spark运行架构"><a href="#1-spark运行架构" class="headerlink" title="1. spark运行架构"></a>1. spark运行架构</h3><p><img src="/images/spark常见知识点/B88CDF76-5160-49FE-AB4C-7EA898015A4B_4_5005_c.jpeg" alt="B88CDF76-5160-49FE-AB4C-7EA898015A4B_4_5005_c.jpeg"></p><ol><li>当<code>Spark应用</code>提交时，根据提交的参数在<code>Driver</code>中创建进程，初始化<code>SparkContext对象</code>。并找到<code>Cluster Manager（Master）进程</code>，对Spark应用进行注册。</li><li>当<code>Master</code>收到Spark应用注册申请，会发送请求给<code>Worker</code>，进行资源的调度和分配。</li><li>Worker收到Master请求后，会为Spark应用启动<code>Executor进程</code>。具体数量由参数决定。Executor启动后，会向Driver反注册，这样Driver就可以知道哪些Executor在运行。</li><li>Driver会根据我们对RDD定义的操作，提交一堆的<code>Task</code>去Executor上执行，<code>Task</code>里面执行的就是具体的<code>map、flatMap</code>这些操作。</li></ol><h3 id="2-一个spark程序的执行流程"><a href="#2-一个spark程序的执行流程" class="headerlink" title="2.一个spark程序的执行流程"></a>2.一个spark程序的执行流程</h3><p><a href="https://zhuanlan.zhihu.com/p/35713084" target="_blank" rel="noopener">参考文章</a><br><img src="/images/spark常见知识点/A5561B89-2C96-4E5F-8833-9558D80B12D0.jpeg" alt="A5561B89-2C96-4E5F-8833-9558D80B12D0.jpeg"></p><ul><li><p>A: 每当Driver进程被启动之后，都会做哪些事情来初始化操作呢？首先它将发送请求到Master上，进行Spark应用程序的注册，也就是我们要让Master知道，现在有一个新的Spark应用程序要运行了。</p></li><li><p>B: 那Master在接收到Spark应用程序的注册申请之后，会发送给Worker，让其进行资源的调度和分配。这也说明资源分配是由executor来分配管理。</p></li><li><p>C: Worter接收Master的请求之后，会为Spark应用启动Executor，来给分配资源。</p></li><li><p>D: Executor启动分配资源好后，就会向Driver进行反注册，这也Driver就会知道哪些Executor是为他进行服务的了。</p></li><li><p>E: 当Driver得到注册了Executor之后，就可以开启正式执行我们的spark应用程序了。首先第一步，就是创建初始RDD，读取数据源，再执行之后的一系列算子。HDFS文件内容被读取到多个worker节点上，形成内存中的分布式数据集，也就是初始RDD 。</p></li><li><p>F: 这时候，Driver就会根据Job任务中的算子形成对应的task，最后提交给Executor，来分配task进行计算的线程。</p></li><li><p>G: 这时的task就会去调用对应自己任务的数据(也就是第一步初始化RDD的partition)来计算，并且task会对调用过来的RDD的partition数据执行指定的算子操作，形成新的RDD的partition，这时一个大的循环就结束了。</p></li></ul><h3 id="3-spark的shuffle介绍"><a href="#3-spark的shuffle介绍" class="headerlink" title="3. spark的shuffle介绍"></a>3. spark的shuffle介绍</h3><p>待整理</p><h3 id="4-Spark的-partitioner-都有哪些"><a href="#4-Spark的-partitioner-都有哪些" class="headerlink" title="4. Spark的 partitioner 都有哪些?"></a>4. Spark的 partitioner 都有哪些?</h3><p><code>Partitioner</code>主要由两个实现类：<code>HashPartitioner</code>和<code>RangePartitioner</code>。<code>HashPartitioner</code>主要用于<code>tansformation算子</code>的默认实现。<code>RangePartitoner</code>主要用于<code>sortBy</code>和<code>sortByKey</code>。</p><ul><li><p>HashPartitoner: numPartitions方法返回传入的分区数，getPartition方法使用key的hashCode值对分区数取模得到PartitionId，写入到对应的bucket中。</p></li><li><p>RangePartioner: 相比于HashPartitoner，RangePartioner能保证每个分区中的数据量的均匀</p></li></ul><h3 id="5-coalesce和repartition区别"><a href="#5-coalesce和repartition区别" class="headerlink" title="5. coalesce和repartition区别"></a>5. coalesce和repartition区别</h3><ul><li>coalesce用已有的partition去尽量减少数据shuffle。</li><li>repartition创建新的partition并且使用 full shuffle。repartition使得每个partition的数据大小都粗略地相等。</li><li>coalesce会使得每个partition不同数量的数据分布（有些时候各个partition会有不同的size）<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repartition</span></span>(numPartitions: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>] = withScope &#123;</span><br><span class="line">  coalesce(numPartitions, shuffle = <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-coalesce如果不进行shuffle为什么会导致数据倾斜"><a href="#6-coalesce如果不进行shuffle为什么会导致数据倾斜" class="headerlink" title="6. coalesce如果不进行shuffle为什么会导致数据倾斜"></a>6. coalesce如果不进行shuffle为什么会导致数据倾斜</h3><ol><li>进行分区缩小时，如果原分区为3个分区中的数据分别为[1,2],[3,4],[5,6]，此时缩小为2若不shuffle，便可能是[1,2],[3,4,5,6]或[1,2,3,4],[5,6]</li><li>进行分区缩小时，如果原分区为2个分区中的数据分别为[1,2],[3,4]，此时扩大为3若不shuffle，便是[1,2],[3,4],[]</li></ol><h3 id="7-Spark有哪几种join"><a href="#7-Spark有哪几种join" class="headerlink" title="7. Spark有哪几种join"></a>7. Spark有哪几种join</h3><p>spark中和join相关的算子有这几个：<code>join</code>, <code>fullOuterJoin</code>, <code>leftOuterJoin</code>, <code>rightOuterJoin</code></p><ul><li><p><code>join</code>: join函数会输出两个RDD中key相同的所有项，并将它们的value联结起来，它联结的key要求在两个表中都存在，类似于SQL中的INNER JOIN。但它不满足交换律，a.join(b)与b.join(a)的结果不完全相同，值插入的顺序与调用关系有关。</p></li><li><p><code>leftOuterJoin</code>: leftOuterJoin会保留对象的所有key，而用None填充在参数RDD other中缺失的值，因此调用顺序会使结果完全不同。如下面展示的结果，</p></li><li><p><code>rightOuterJoin</code>: rightOuterJoin与leftOuterJoin基本一致，区别在于它的结果保留的是参数other这个RDD中所有的key。</p></li><li><p><code>fullOuterJoin</code>: fullOuterJoin会保留两个RDD中所有的key，因此所有的值列都有可能出现缺失的情况，所有的值列都会转为Some对象。</p></li></ul><h3 id="8-RDD有哪些特点"><a href="#8-RDD有哪些特点" class="headerlink" title="8. RDD有哪些特点"></a>8. RDD有哪些特点</h3><ol><li><code>a list of partition</code>: RDD是一个有多个partition（某个节点里的某一片连续的数据）组成的list，将数据加载为RDD是，一般会遵循数据的本地性（一般一个hdfs里的block会记载成一个partition）。</li><li><code>a function for computing each split</code>: RDD的每个partition上面都会有function，也就是函数应用，其作用是实现RDD之间的partition的转换。</li><li><code>A list of dependencies on other RDDs</code>: RDD会记录他的依赖，为了容错（重算，cache，checkpoint），也就是说在内存中的RDD操作是出错或丢失会进行重算。</li><li><code>Optionally, a partitioner for key-value RDDs</code>: 可选项，如果RDD里面存的数据时key-value形式，则可以传递一个自定义的partitioner进行重分区，例如这里自定义的partitioner是基于key进行分区，那则会将不容的RDD里面相同的key的数据放到同一个partition里面。</li><li><code>Optionally, a list of prefered locations to compute each split on</code>: 根据数据的位置进行最优位置的计算。</li></ol><h3 id="9-讲一下宽依赖以及窄依赖"><a href="#9-讲一下宽依赖以及窄依赖" class="headerlink" title="9. 讲一下宽依赖以及窄依赖"></a>9. 讲一下宽依赖以及窄依赖</h3><p><a href="https://www.jianshu.com/p/736a4e628f0f" target="_blank" rel="noopener">spark宽依赖和窄依赖</a><br>宽依赖和窄依赖的区别就是RDD之间是否存在shuffle操作。<br>如果父RDD分区对应1个子RDD的分区就是窄依赖，否则就是宽依赖。</p><h4 id="1-窄依赖"><a href="#1-窄依赖" class="headerlink" title="1.窄依赖"></a>1.窄依赖</h4><p>窄依赖指父RDD的每一个分区最多被一个子RDD的分区所用，即一个父RDD对应一个子RDD或者多个父RDD对应一个子RDD。</p><ul><li>map, filter, union 属于窄依赖</li><li>co-partioned join 属于窄依赖<blockquote><p>join分为宽依赖和窄依赖，如果RDD有相同的partitioner，那么将不会引起shuffle，因此我们可以对RDD进行Hash分区。分别对A和B用同一个函数进行Partition，比如按照首字母进行Partition，那么A和B都可以分成26个Partition，并且A1只需要和B1进行join，A1不需要和B剩下的25个Partition进行join，这样就大大的减少了join次数，最好的办法是对表进行分区，每次只取两个对应分区的数据进行join操作。</p></blockquote></li></ul><h4 id="2-宽依赖"><a href="#2-宽依赖" class="headerlink" title="2.宽依赖"></a>2.宽依赖</h4><p>宽依赖指子RDD的每个分区都依赖于父RDD的多个分区</p><ul><li>group by和join 都属于宽依赖</li><li>DAGScheduler从当前算子往前推，遇到宽依赖就生成一个stage。</li></ul><h4 id="3-为什么spark将依赖分位窄依赖和宽依赖"><a href="#3-为什么spark将依赖分位窄依赖和宽依赖" class="headerlink" title="3.为什么spark将依赖分位窄依赖和宽依赖"></a>3.为什么spark将依赖分位窄依赖和宽依赖</h4><ul><li><p>窄依赖<br>可以支持在一个集群的Executor上，以pipeline管道形式顺序执行多条命令。同时也由于分区内的计算收敛，不需要依赖所有分区的数据，可以并行的在不同的节点计算。所以他的失败恢复也更简单。只需要重新计算丢失的parent partition即可。</p></li><li><p>宽依赖<br>宽依赖需要所有父分区都是可用的，必须等RDD的parent partition数据全部ready之后才能进行计算。从数据恢复的角度，shuffle dependency牵扯到RDD各级的多个parent partition。对于宽依赖，重算的父RDD分区对应多个子RDD分区，这样实际上父RDD 中只有一部分的数据是被用于恢复这个丢失的子RDD分区的，另一部分对应子RDD的其它未丢失分区，这就造成了多余的计算；更一般的，宽依赖中子RDD分区通常来自多个父RDD分区，极端情况下，所有的父RDD分区都要进行重新计算。</p></li></ul><h3 id="10-Spark中的算子有哪些"><a href="#10-Spark中的算子有哪些" class="headerlink" title="10. Spark中的算子有哪些"></a>10. Spark中的算子有哪些</h3><p>Spark分位两大类算子：<br>Transformation 变换/转换算子：这种变换并不触发提交作业，完成作业中间过程处理。Transformation操作是延迟计算的，也就是说从一个RDD转换成另一个RDD的转换操作不是马上执行，需要等到有Action操作的时候才会真正触发计算。</p><p>Action行动算子：这类算子会触发SparkContext提交Job作业。</p><ol><li><p>Value数据类型的Transformation算子</p><ol><li><p>一对一<br>map算子<br>flatMap算子<br>mapPartitions算子<br>glom算子</p></li><li><p>多对一<br>union算子<br>cartesian算子（笛卡尔）</p></li><li><p>多对多<br>groupBy算子</p></li><li><p>输出为输入子集<br>filter算子<br>distinct算子<br>subtract算子（差集）<br>sample算子（抽样调查）<br>takeSample算子</p></li><li><p>Cache型<br>cache算子<br>persist算子</p></li></ol></li><li><p>Key-Value数据类型的Transformation算子</p><ol><li><p>一对一<br>mapValues算子 [对于(K,V)形式的类型只对V进行操作]</p></li><li><p>对单个RDD或两个RDD聚集<br>combineByKey算子<br>reduceByKey算子<br>partitionBy算子<br>Cogroup算子</p></li><li><p>连接<br>join算子<br>leftOutJoin 和 rightOutJoin算子</p></li></ol></li></ol><ol start="3"><li><p>Action算子</p><ol><li><p>无输出<br>foreach算子</p></li><li><p>HDFS算子<br>saveAsTextFile算子<br>saveAsObjectFile算子</p></li><li><p>Scala集合和数据类型<br>collect算子<br>collectAsMap算子<br>reduceByKeyLocally算子<br>lookup算子<br>count算子<br>top算子<br>reduce算子<br>fold算子<br>aggregate算子<br>countByValue<br>countByKey</p></li></ol></li></ol><h3 id="11-RDD的缓存级别"><a href="#11-RDD的缓存级别" class="headerlink" title="11. RDD的缓存级别"></a>11. RDD的缓存级别</h3><ol><li>NONE：什么类型都不是</li><li>DISK_ONLY：磁盘</li><li>DISK_ONLY_2：磁盘；双副本</li><li>MEMORY_ONLY：内存；反序列化；把RDD作为反序列化的方式存储，假如RDD的内容存不下，剩余的分区在以后需要时会重新计算，不会刷到磁盘上</li><li>MEMORY_ONLY_2：内存；反序列化；双副本。</li><li>MEMORY_ONLY_SER：内存；序列化；这种序列化方式，每一个partition以字节数据存储，好处是能带来更好的空间存储，但CPU耗费高</li><li>MEMORY_ONLY_SER_2：内存；序列化；双副本</li><li>MEMORY_AND_DISK：内存 + 磁盘；反序列化；双副本；RDD以反序列化的方式存内存，假如RDD的内容存不下，剩余的会存到磁盘</li><li>MEMORY_AND_DISK_2：内存 + 磁盘；反序列化；双副本</li><li>MEMORY_AND_DISK_SER：内存 + 磁盘；序列化</li><li>MEMORY_AND_DISK_SER_2：内存 + 磁盘；序列化；双副本</li></ol><h3 id="12-RDD懒加载是什么意思"><a href="#12-RDD懒加载是什么意思" class="headerlink" title="12. RDD懒加载是什么意思"></a>12. RDD懒加载是什么意思</h3><p>Transformation 操作是延迟计算的，也就是说从一个RDD转换生成另一个RDD的转换操作不是马上执行，需要等到有Acion操作的时候才会真正触发运算,这也就是懒加载。</p><h3 id="13-讲一下spark的几种部署方式"><a href="#13-讲一下spark的几种部署方式" class="headerlink" title="13. 讲一下spark的几种部署方式"></a>13. 讲一下spark的几种部署方式</h3><p>目前,除了local模式为本地调试模式以为, Spark支持三种分布式部署方式，分别是standalone、spark on mesos和 spark on YARN。</p><ol><li><p>Standalone模式<br>即独立模式，自带完整的服务，可单独部署到一个集群中，无需依赖任何其他资源管理系统。从一定程度上说，该模式是其他两种的基础。目前Spark在standalone模式下是没有任何单点故障问题的，这是借助zookeeper实现的，思想类似于Hbase master单点故障解决方案。</p></li><li><p>Spark On YARN模式<br>spark on yarn 的支持两种模式：<br>yarn-cluster：适用于生产环境；<br>yarn-client：适用于交互、调试，希望立即看到app的输出<br>yarn-cluster和yarn-client的区别在于yarn appMaster，每个yarn app实例有一个appMaster进程，是为app启动的第一个container；负责从ResourceManager请求资源，获取到资源后，告诉NodeManager为其启动container。yarn-cluster和yarn-client模式内部实现还是有很大的区别。如果你需要用于生产环境，那么请选择yarn-cluster；而如果你仅仅是Debug程序，可以选择yarn-client。</p></li><li><p>Spark On Mesos模式<br>略</p></li></ol><h3 id="14-Spark-on-yarn模式下的cluster模式和client模式有什么区别"><a href="#14-Spark-on-yarn模式下的cluster模式和client模式有什么区别" class="headerlink" title="14. Spark on yarn模式下的cluster模式和client模式有什么区别"></a>14. Spark on yarn模式下的cluster模式和client模式有什么区别</h3><ol><li>yarn-cluster适用于生产环境。而yarn-client适用于交互和调试，也就是希望快速地看到application的输出。</li><li>yarn-cluster 和 yarn-client 模式的区别其实就是 Application Master 进程的区别，yarn-cluster 模式下，driver 运行在 AM(Application Master)中，它负责向 YARN 申请资源，并监督作业的运行状况。当用户提交了作业之后，就可以关掉 Client，作业会继续在 YARN 上运行。然而 yarn-cluster 模式不适合运行交互类型的作业。而 yarn-client 模式下，Application Master 仅仅向 YARN 请求 executor，Client 会和请求的container 通信来调度他们工作，也就是说 Client 不能离开。</li></ol><h3 id="15-spark运行原理，从提交一个jar到最后返回结果"><a href="#15-spark运行原理，从提交一个jar到最后返回结果" class="headerlink" title="15. spark运行原理，从提交一个jar到最后返回结果"></a>15. spark运行原理，从提交一个jar到最后返回结果</h3><ol><li>spark-submit提交代码，执行new SparkContext(), 在SparkContext里构造DAGScheduler和TaskScheduler。</li><li>TaskScheduler会通过后台的一个进程，连接master，向master注册Application。</li><li>Master接收到Application请求后，会使用相应的资源调用算法。在Worker上为这个Application启动多个Executor。</li><li>Executor启动后，会自己反向注册到TaskScheduler中。所有Executor都注册到Driver上之后，SparkContext结束初始化，接下来往下执行我们自己的代码。</li><li>每执行到一个 Action，就会创建一个 Job。Job 会提交给 DAGScheduler。</li><li>DAGScheduler 会将 Job划分为多个 stage，然后每个 stage 创建一个 TaskSet。</li><li>TaskScheduler 会把每一个 TaskSet 里的 Task，提交到 Executor 上执行。</li><li>Executor 上有线程池，每接收到一个 Task，就用 TaskRunner 封装，然后从线程池里取出一个线程执行这个 task。(TaskRunner 将我们编写的代码，拷贝，反序列化，执行 Task，每个 Task 执行 RDD 里的一个 partition)</li></ol><h3 id="16-Spark的stage是如何划分的"><a href="#16-Spark的stage是如何划分的" class="headerlink" title="16. Spark的stage是如何划分的"></a>16. Spark的stage是如何划分的</h3><p>stage的划分依据就是看是否产生了shuffle（即宽依赖），遇到一个shuffle操作就划分为前后两个stage。</p><h3 id="17-Spark2-0为什么放弃了akka而用netty"><a href="#17-Spark2-0为什么放弃了akka而用netty" class="headerlink" title="17. Spark2.0为什么放弃了akka而用netty"></a>17. Spark2.0为什么放弃了akka而用netty</h3><ol><li>很多Spark用户也使用Akka，但是由于Akka不同版本之间无法互相通信，这就要求用户必须使用跟Spark完全一样的Akka版本，导致用户无法升级Akka。</li><li>Spark的Akka配置是针对Spark自身来调优的，可能跟用户自己代码中的Akka配置冲突。</li><li>Spark用的Akka特性很少，这部分特性很容易自己实现。同时，这部分代码量相比Akka来说少很多，debug比较容易。如果遇到什么bug，也可以自己马上fix，不需要等Akka上游发布新版本。而且，Spark升级Akka本身又因为第一点会强制要求用户升级他们使用的Akka，对于某些用户来说是不现实的。</li></ol><h3 id="18-Spark的各种HA，master-worker-executor的ha"><a href="#18-Spark的各种HA，master-worker-executor的ha" class="headerlink" title="18. Spark的各种HA，master/worker/executor的ha"></a>18. Spark的各种HA，master/worker/executor的ha</h3><ul><li><p>Master异常<br>spark可以在集群运行时启动一个或多个standby Master,当 Master 出现异常时,会根据规则启动某个standby master接管,在standlone模式下有如下几种配置</p><ul><li><p>ZOOKEEPER<br>集群数据持久化到zk中,当master出现异常时,zk通过选举机制选出新的master,新的master接管是需要从zk获取持久化信息</p></li><li><p>FILESYSTEM<br>集群元数据信息持久化到本地文件系统, 当master出现异常时,只需要在该机器上重新启动master,启动后新的master获取持久化信息并根据这些信息恢复集群状态</p></li><li><p>CUSTOM<br>自定义恢复方式,对 standloneRecoveryModeFactory 抽象类 进行实现并把该类配置到系统中,当master出现异常时,会根据用户自定义行为恢复集群</p></li><li><p>None<br>不持久化集群的元数据, 当 master出现异常时, 新启动的Master 不进行恢复集群状态,而是直接接管集群</p></li></ul></li><li><p>Worker异常<br>Worker以定时发送心跳给Master，让Master知道Worker的实时状态，当Worker出现超时，Master 调用 timeOutDeadWorker 方法进行处理,在处理时根据 Worker 运行的是 Executor 和 Driver 分别进行处理。<br>如果是Executor, Master先把该 Worker 上运行的Executor 发送信息ExecutorUpdate给对应的Driver,告知Executor已经丢失,同时把这些Executor从其应用程序列表删除, 另外, 相关Executor的异常也需要处理<br>如果是Driver, 则判断是否设置重新启动,如果需要,则调用Master.shedule方法进行调度,分配合适节点重启Driver, 如果不需要重启, 则删除该应用程序</p></li><li><p>Executor异常<br>Executor发生异常时由ExecutorRunner捕获该异常并发送ExecutorStateChanged信息给Worker<br>Worker接收到消息时, 在Worker的 handleExecutorStateChanged 方法中, 根据Executor状态进行信息更新,同时把Executor状态发送给Master<br>Master在接受Executor状态变化消息之后,如果发现其是异常退出,会尝试可用的Worker节点去启动Executor</p></li></ul><h3 id="19-spark的内存管理机制-spark-1-6前后分析对比-spark2-0-做出来哪些优化"><a href="#19-spark的内存管理机制-spark-1-6前后分析对比-spark2-0-做出来哪些优化" class="headerlink" title="19. spark的内存管理机制,spark 1.6前后分析对比, spark2.0 做出来哪些优化"></a>19. spark的内存管理机制,spark 1.6前后分析对比, spark2.0 做出来哪些优化</h3><h3 id="20-讲一下spark中的广播变量"><a href="#20-讲一下spark中的广播变量" class="headerlink" title="20. 讲一下spark中的广播变量"></a>20. 讲一下spark中的广播变量</h3><p>broadcast 就是将数据从一个节点发送到其他各个节点上去。这样的场景很多，比如 driver 上有一张表，其他节点上运行的 task 需要 lookup 这张表，那么 driver 可以先把这张表 copy 到这些节点，这样 task 就可以在本地查表了。</p><ul><li><p>为什么broadcast是只读变量<br>这就涉及到一致性的问题，如果变量可以被更新，name一旦变量被某个节点更新，其他的节点要不要一块更新？如果多个节点同事更新，更新顺序是什么？怎么做同步？为了避免维护数据一致性问题，Spark 目前只支持 broadcast 只读变量。</p></li><li><p>为什么broadcast到节点而不是到每个task<br>因为每个task是一个线程，而且同在一个进程运行tasks都属于同一个application。因此每个节点（executor）上放一份就可以被所有task共享。</p></li><li><p>怎么实现broadcast<br>Driver先建一个本地文件夹用于存放需要broadcast的data，并启动一个可以访问该文件的HttpServer。当调用val bdata = sc.broadcast(data)时就把data写入文件夹，同时写入driver自己的blockManger中（StorageLevel 为内存＋磁盘）。如果func用到了 bdata，那么driver submitTask() 的时候会将bdata一同func进行序列化得到 serialized task，<strong>注意序列化的时候不会序列化bdata中包含的data。</strong>上一章讲到 serialized task从driverActor传递到executor时使用Akka的传消息机制，消息不能太大，而实际的data可能很大，所以这时候还不能broadcast data。</p><blockquote><p>driver 为什么会同时将 data 放到磁盘和 blockManager 里面？放到磁盘是为了让 》HttpServer 访问到，放到 blockManager 是为了让 driver program 自身使用 bdata 时方便（其实我觉得不放到 blockManger 里面也行）。<br><strong>那么什么时候传送真正的 data？</strong>在 executor 反序列化 task 的时候，会同时反序列化 task 中的 bdata 对象，这时候会调用 bdata 的 readObject() 方法。该方法先去本地 blockManager 那里询问 bdata 的 data 在不在 blockManager 里面，如果不在就使用下面的两种 fetch 方式之一去将 data fetch 过来。得到 data 后，将其存放到 blockManager 里面，这样后面运行的 task 如果需要 bdata 就不需要再去 fetch data 了。如果在，就直接拿来用了。</p></blockquote></li></ul><p>下面探讨 broadcast data 时候的两种实现方式：</p><ul><li>HttpBroadcast<br>无</li><li>TorrentBroadcast<br>无</li></ul><h3 id="21-什么是数据倾斜，怎样去处理数据倾斜"><a href="#21-什么是数据倾斜，怎样去处理数据倾斜" class="headerlink" title="21. 什么是数据倾斜，怎样去处理数据倾斜"></a>21. 什么是数据倾斜，怎样去处理数据倾斜</h3><p><a href="https://juejin.cn/post/6844903837505945608#heading-9" target="_blank" rel="noopener">参考文章：Spark学习——数据倾斜</a><br><a href="https://blog.csdn.net/qq_35394891/article/details/82260907" target="_blank" rel="noopener">[spark 面试]数据倾斜</a><br>数据倾斜是一种很常见的问题，比方WordCount中某个Key对应的数据量非常大，就会产生数据倾斜，导致两个后果：</p><ul><li>OOM（单或少数的节点）</li><li>拖慢整个Job执行时间（其他已经完成的节点都在等未完成的节点）</li></ul><p>数据倾斜主要分为两类：聚合倾斜和join倾斜</p><ul><li><p>聚合倾斜</p><ul><li>双重聚合（局部聚合+全局聚合）<ul><li>场景：对RDD进行reduceByKey等聚合类shuffle算子，SparkSQL的groupBy做分组聚合这两种情况。</li><li>思路：首先通过map给每个key打上n以内的随机数的前缀并进行局部聚合，即(hello, 1) (hello, 1) (hello, 1) (hello, 1)变为(1_hello, 1) (1_hello, 1) (2_hello, 1)，并进行reduceByKey的局部聚合，然后再次map将key的前缀随机数去掉再次进行全局聚合。</li><li>原理: 对原本相同的key进行随机数附加，变成不同key，让原本一个task处理的数据分摊到多个task做局部聚合，规避单task数据过量。之后再去随机前缀进行全局聚合；</li><li>优点：效果非常好（对聚合类Shuffle操作的倾斜问题）；</li><li>缺点：范围窄（仅适用于聚合类的Shuffle操作，join类的Shuffle还需其它方案）</li></ul></li></ul></li><li><p>join倾斜</p><ul><li><p>将reduce join转化为map join</p><ul><li>场景: 对RDD或Spark SQL使用join类操作或语句，且join操作的RDD或表比较小（百兆或1,2G）； </li><li>思路: 使用broadcast和map类算子实现join的功能替代原本的join，彻底规避shuffle。对较小RDD直接collect到内存，并创建broadcast变量；并对另外一个RDD执行map类算子，在该算子的函数中，从broadcast变量（collect出的较小RDD）与当前RDD中的每条数据依次比对key，相同的key执行你需要方式的join；</li><li>原理: 若RDD较小，可采用广播小的RDD，并对大的RDD进行map，来实现与join同样的效果。简而言之，用broadcast-map代替join，规避join带来的shuffle（无Shuffle无倾斜）； </li><li>优点：效果很好（对join操作导致的倾斜），根治；</li><li>缺点：适用场景小（大表+小表），广播（driver和executor节点都会驻留小表数据）小表也耗内存</li></ul></li><li><p>采样倾斜key并分拆join操作</p><ul><li>场景：两个较大的（无法采用方案五）RDD/Hive表进行join时，且一个RDD/Hive表中少数key数据量过大，另一个RDD/Hive表的key分布较均匀（RDD中两者之一有一个更倾斜）； </li><li>思路:<ul><li>对更倾斜rdd1进行采样（RDD.sample）并统计出数据量最大的几个key；</li><li>对这几个倾斜的key从原本rdd1中拆出形成一个单独的rdd1_1，并打上0~n的随机数前缀，被拆分的原rdd1的另一部分（不包含倾斜key）又形成一个新rdd1_2；</li><li>对rdd2过滤出rdd1倾斜的key，得到rdd2_1，并将其中每条数据扩n倍，对每条数据按顺序附加0~n的前缀，被拆分出key的rdd2也独立形成另一个rdd2_2； 【个人认为，这里扩了n倍，最后union完还需要将每个倾斜key对应的value减去(n-1)】</li><li>将加了随机前缀的rdd1_1和rdd2_1进行join（此时原本倾斜的key被打散n份并被分散到更多的task中进行join）； 【个人认为，这里应该做两次join，两次join中间有一个map去前缀】</li><li>另外两个普通的RDD（rdd1_2、rdd2_2）照常join；</li><li>最后将两次join的结果用union结合得到最终的join结果。 原理：对join导致的倾斜是因为某几个key，可将原本RDD中的倾斜key拆分出原RDD得到新RDD，并以加随机前缀的方式打散n份做join，将倾斜key对应的大量数据分摊到更多task上来规避倾斜；</li></ul></li><li>优点: 前提是join导致的倾斜（某几个key倾斜），避免占用过多内存（只需对少数倾斜key扩容n倍）； </li><li>缺点: 对过多倾斜key不适用。</li></ul></li><li><p>用随机前缀和扩容RDD进行join</p><ul><li>场景：RDD中有大量key导致倾斜； </li><li>思路：与方案六类似<ul><li>查看RDD/Hive表中数据分布并找到造成倾斜的RDD/表；</li><li>对倾斜RDD中的每条数据打上n以内的随机数前缀；</li><li>对另外一个正常RDD的每条数据扩容n倍，扩容出的每条数据依次打上0到n的前缀；</li><li>对处理后的两个RDD进行join。</li></ul></li><li>原理: 与方案六只有唯一不同在于这里对不倾斜RDD中所有数据进行扩大n倍，而不是找出倾斜key进行扩容； </li><li>优点: 对join类的数据倾斜都可处理，效果非常显著； </li><li>缺点: 缓解，扩容需要大内存</li></ul></li></ul></li></ul><h3 id="22-分析一下一段spark代码中哪些部分在Driver端执行-哪些部分在Worker端执行"><a href="#22-分析一下一段spark代码中哪些部分在Driver端执行-哪些部分在Worker端执行" class="headerlink" title="22. 分析一下一段spark代码中哪些部分在Driver端执行,哪些部分在Worker端执行"></a>22. 分析一下一段spark代码中哪些部分在Driver端执行,哪些部分在Worker端执行</h3><p>Driver Program是用户编写的提交给Spark集群执行的application，它包含两部分</p><ul><li>作为驱动： Driver与Master、Worker协作完成application进程的启动、DAG划分、计算任务封装、计算任务分发到各个计算节点(Worker)、计算资源的分配等。</li><li>计算逻辑本身，当计算任务在Worker执行时，执行计算逻辑完成application的计算任务</li></ul><p>一般来说transformation算子均是在worker上执行的,其他类型的代码在driver端执行</p>]]></content>
    
    <summary type="html">
    
      本文将对Spark中常遇到的知识点和面试题进行总结。
    
    </summary>
    
      <category term="Spark" scheme="http://suiwo.xyz/categories/Spark/"/>
    
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="http://suiwo.xyz/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Netty核心模块组件梳理</title>
    <link href="http://suiwo.xyz/2022/01/21/Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6%E6%A2%B3%E7%90%86/"/>
    <id>http://suiwo.xyz/2022/01/21/Netty核心模块组件梳理/</id>
    <published>2022-01-21T11:16:47.000Z</published>
    <updated>2023-01-07T16:04:28.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Bootstarp、ServerBootstrap"><a href="#一、Bootstarp、ServerBootstrap" class="headerlink" title="一、Bootstarp、ServerBootstrap"></a>一、Bootstarp、ServerBootstrap</h3><p>Bootstrap意思是引导，一个Netty应用通常的Bootstrap开始，主要用于配置整个Netty程序。Netty中Bootstrap类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类。</p><h4 id="1-1-方法汇总"><a href="#1-1-方法汇总" class="headerlink" title="1.1 方法汇总"></a>1.1 方法汇总</h4><table><thead><tr><th>方法名</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</td><td>本方法用于服务端引导</td><td>parent指bossGroup，childGroup指workerGroup</td></tr><tr><td>group(EventLoopGroup group)</td><td>本方法用于客户端引导</td><td></td></tr><tr><td>channel(Class&lt;? extends C&gt; channelClass)</td><td>配置通道实现类</td><td></td></tr><tr><td>option(ChannelOption<t> option, T value)</t></td><td>用来给ServerChannel添加配置</td><td></td></tr><tr><td>childOption(ChannelOption<t> childOption, T value)</t></td><td>用来给接收到的通道添加配置</td><td></td></tr><tr><td>childHandler(ChannelHandler childHandler</td><td>该方法用来设置业务处理类(自定义的</td></tr></tbody></table><p>handler) |  |<br>| bind(int inetPort) | 该方法用于服务器端，用来设置占用的端口号 |  |<br>| connect(String inetHost, int inetPort) | 该方法用于客户端，用来连接服务器端 |  |</p><h3 id="二、Future-ChannelFuture"><a href="#二、Future-ChannelFuture" class="headerlink" title="二、Future, ChannelFuture"></a>二、Future, ChannelFuture</h3><p>Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p><h4 id="1-2-常见的方法"><a href="#1-2-常见的方法" class="headerlink" title="1.2 常见的方法"></a>1.2 常见的方法</h4><p>Channel channel()，返回当前正在进行 IO 操作的通道<br>ChannelFuture sync()，等待异步操作执行完毕</p><h3 id="三、Channel"><a href="#三、Channel" class="headerlink" title="三、Channel"></a>三、Channel</h3><p>1) Netty 网络通信的组件，能够用于执行网络 I/O 操作。<br>2) 通过Channel可获得当前网络连接的通道的状态<br>3) 通过Channel可获得网络连接的配置参数(例如接收缓冲区大小)<br>4) Channel 提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返 回，并且不保证在调用结束时所请求的 I/O 操作已完成<br>5) 调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取 消时回调通知调用方<br>6) 支持关联 I/O 操作与对应的处理程序<br>7) 不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，常用的 Channel 类型:<br>NioSocketChannel，异步的客户端 TCP Socket 连接。<br>NioServerSocketChannel，异步的服务器端 TCP Socket 连接。<br>NioDatagramChannel，异步的 UDP 连接。<br>NioSctpChannel，异步的客户端 Sctp 连接。<br>NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</p><h3 id="四、Selector"><a href="#四、Selector" class="headerlink" title="四、Selector"></a>四、Selector</h3><p>1) Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。<br>2) 当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件(例如可读，可写，网络连接完成等)，这样程序就可以很简单地使用一个<br>线程高效地管理多个 Channel</p><h3 id="五、ChannelHandler"><a href="#五、ChannelHandler" class="headerlink" title="五、ChannelHandler"></a>五、ChannelHandler</h3><p>1) ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链) 中的下一个处理程序。<br>2) ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类<br>3) ChannelHandler 及其实现类一览图(后)</p><p>ChannelInboundHandler用于处理入站I/O事件。<br>ChannelOutboundHandler用于处理出站I/O操作。<br>适配器<br>ChannelInboundHandlerAdapter用于处理入站I/O事件。<br>ChannelOutboundHandlerAdapter用于处理出站I/O操作。<br>ChannelDuplexHandler用于处理入站和出站事件。</p>]]></content>
    
    <summary type="html">
    
      本文对Netty的核心模块组件进行总结
    
    </summary>
    
      <category term="Netty" scheme="http://suiwo.xyz/categories/Netty/"/>
    
    
      <category term="Java" scheme="http://suiwo.xyz/tags/Java/"/>
    
      <category term="NIO" scheme="http://suiwo.xyz/tags/NIO/"/>
    
      <category term="Netty" scheme="http://suiwo.xyz/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Java-NIO知识点简单梳理</title>
    <link href="http://suiwo.xyz/2022/01/21/Java-NIO%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%A2%B3%E7%90%86/"/>
    <id>http://suiwo.xyz/2022/01/21/Java-NIO知识点简单梳理/</id>
    <published>2022-01-21T08:05:47.000Z</published>
    <updated>2023-01-07T16:38:10.573Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Buffer梳理"><a href="#一、Buffer梳理" class="headerlink" title="一、Buffer梳理"></a>一、Buffer梳理</h3><h4 id="1-1-字段解释"><a href="#1-1-字段解释" class="headerlink" title="1.1 字段解释"></a>1.1 字段解释</h4><p>表中几个字段的数学关系是：0 &lt;= <code>mark</code> &lt;= <code>positon</code> &lt;= <code>limit</code> &lt;= <code>capacity</code></p><table><thead><tr><th>字段名</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><code>capacity</code></td><td>buffer容量</td><td>比如在<code>ByteBuffer.allocate(1024)</code>表示将容量设置为1024</td></tr><tr><td><code>position</code></td><td>当前指针偏移量</td><td>比如在新创建的byteBuffer中<code>put()</code>一个byte，此时<code>position</code>由0变为1</td></tr><tr><td><code>limit</code></td><td>限制指针的大小</td><td>比如<code>ByteBuffer.allocate(1024)</code>此时<code>limit</code>为1024，所以<code>position</code>最大为1024。</td></tr><tr><td><code>mark</code></td><td>临时标记，默认是未定义的</td><td>假设<code>IntBuffer.allocate(1024)</code>，现在<code>position</code>位置为10，现在只想发送512到1024之间的缓冲数据，此时我们可以<code>buffer.mark(buffer.position())</code>既将position记入mark位置，然后<code>buffer.postion(512)</code>，此时发送的数据就是512到1024之间的数据。发送完成后，调用<code>buffer.reset()</code>将mark临时标记赋值给<code>position</code>使得<code>position=mark</code>。注意如果未设定<code>mark</code>，而调用了<code>buffer.reset()</code>方法则会抛出<code>InvalidMarkException</code></td></tr></tbody></table><h4 id="1-2-方法汇总"><a href="#1-2-方法汇总" class="headerlink" title="1.2 方法汇总"></a>1.2 方法汇总</h4><table><thead><tr><th>方法</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td><code>capacity()</code></td><td>获取容量大小</td><td></td></tr><tr><td><code>position()</code></td><td>获取当前值的偏移量</td><td></td></tr><tr><td><code>position(int newPosition)</code></td><td>设置偏移量指针未知</td><td><code>newPosition</code>需要小于<code>capacity</code></td></tr><tr><td><code>limit()</code></td><td>获取当前<code>limit</code>大小</td><td></td></tr><tr><td><code>limit(int newLimit)</code></td><td>设置当前<code>limit</code>大小</td><td><code>limit</code>应该小于等于<code>capacity</code>并大于0</td></tr><tr><td><code>mark()</code></td><td>记录当前的偏移量位置</td><td>即 <code>mark=position</code></td></tr><tr><td><code>reset()</code></td><td>重置为先前偏移量的位置</td><td>本方法一般要和<code>mark()</code>方法配合使用，当没有初始化<code>mark()</code>值会抛出<code>InvalidMarkException</code>异常</td></tr><tr><td><code>clear()</code></td><td>清除缓冲区</td><td>将<code>position=0,limit=capacity,mark=-1</code></td></tr><tr><td><code>flip()</code></td><td>读写翻转</td><td>将<code>limit=position,position=0,mark=-1</code>。需要注意假设一个<code>position=1,capacity=1024</code>的读状态的buffer翻转此时limit=1而不是1024</td></tr><tr><td><code>rewind()</code></td><td>回退缓冲区</td><td>他只是将<code>position=0</code>和<code>mark=-1</code></td></tr><tr><td><code>remaining()</code></td><td>返回当前位置和limit之前的元素数</td><td></td></tr><tr><td><code>hasRemaining()</code></td><td>判断当前位置和limit之前是否还存在元素</td></tr></tbody></table><h3 id="二、Channel梳理"><a href="#二、Channel梳理" class="headerlink" title="二、Channel梳理"></a>二、Channel梳理</h3><h4 id="1-1-基本介绍"><a href="#1-1-基本介绍" class="headerlink" title="1.1 基本介绍"></a>1.1 基本介绍</h4><p>channel可以同时进行读写而流只能读或者写<br>channel可以从buffer中读数据，也可以向buffer中写数据<br>常用的 <code>Channel</code> 类有：<code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code></p><h3 id="三、Selector梳理"><a href="#三、Selector梳理" class="headerlink" title="三、Selector梳理"></a>三、Selector梳理</h3><h4 id="3-1-基本介绍"><a href="#3-1-基本介绍" class="headerlink" title="3.1 基本介绍"></a>3.1 基本介绍</h4><ol><li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到Selector(选择器)</li><li>Selector 能够检测多个注册的通道上是否有事件发生(注意:多个Channel以事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</li><li>只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程4) 避免了多线程之间的上下文切换导致的开销</li></ol><h4 id="3-2-方法汇总"><a href="#3-2-方法汇总" class="headerlink" title="3.2 方法汇总"></a>3.2 方法汇总</h4><table><thead><tr><th>方法名</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>open()</td><td>创建一个selector</td><td></td></tr><tr><td>isOpen()</td><td>判断当前selector是否开启</td><td></td></tr><tr><td>keys()</td><td>返回当前selector注册的所有channel的selectionKey</td><td></td></tr><tr><td>selectedKeys()</td><td>返回当前selector中等待io操作的channel的selectionKey</td><td></td></tr><tr><td>selectNow()</td><td>通过非阻塞的方式获取当前等待io的channel的键数量</td><td></td></tr><tr><td>select()</td><td>通过阻塞的方式获取当前等待io的channel的键数量</td><td></td></tr><tr><td>select(long timeout)</td><td>同上，只不过多了一个等待超时时间</td><td></td></tr><tr><td>wakeup()</td><td>唤醒阻塞的select()</td><td>调用wakeup()没有select操作，下次调用select相关操作立即返回，不执行poll()，包括selectNow()。多次调用与一次效果一样</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      本文对NIO中的重点名词，常见概念，以及核心函数进行简单梳理
    
    </summary>
    
      <category term="Java" scheme="http://suiwo.xyz/categories/Java/"/>
    
    
      <category term="Java" scheme="http://suiwo.xyz/tags/Java/"/>
    
      <category term="NIO" scheme="http://suiwo.xyz/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Spring核心容器简介-BeanFactory，ApplicationContext</title>
    <link href="http://suiwo.xyz/2021/08/17/Spring%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B-BeanFactory%EF%BC%8CApplicationContext/"/>
    <id>http://suiwo.xyz/2021/08/17/Spring核心容器简介-BeanFactory，ApplicationContext/</id>
    <published>2021-08-17T02:13:57.000Z</published>
    <updated>2023-01-07T15:13:54.201Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Spring中容器的实现类并不是唯一的，Spring框架中提供了多个容器的实现。主要分为两套体系：一套是早期的BeanFactory体系，还有一个就是ApplicationContext，也被成为服务上下文，它继承了BeanFactory，除了BeanFactory的功能外还提供了事务，AOP，国际化的消息源以及应用程序事务处理等企业级服务。</p></blockquote><h2 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1.BeanFactory"></a>1.BeanFactory</h2><p>首先我们来看一下BeanFacotry源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要是用于FactoryBean的转义进行定义，因为当使用FactoryBean创建Bean时，使用名字进行检索获取的是FactoryBean所创建的Bean对象</span></span><br><span class="line"><span class="comment"> * 而需要使用转义来获取FactoryBean本身。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据bean的名称获取容器中的实例，这个bean可以是单例bean也可以是原型bean。</span></span><br><span class="line"><span class="comment">     * 当无法获取指定名称的bean将会抛出NoSuchBeanDefinitionException异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据bean的名称和bean的类型来获取容器中的bean实例，这个bean可以是单例bean也可以是原型bean。</span></span><br><span class="line"><span class="comment">     * 当获取的bean不是所需类型，则抛出BeanNotOfRequiredTypeException异常。可以简单理解成增加了安全验证机制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据名称来获取bean，第二个参数args可以用来给bean进行赋值。复制的方式有两种，构造方法和工厂方法。</span></span><br><span class="line"><span class="comment"> * 但是通过这种方式获取的bean必须为原型bean而不是单例bean。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据bean类型来获取容器中的bean，当bean不唯一是抛出NoUniqueBeanDefinitionException异常。</span></span><br><span class="line"><span class="comment">     * 当没有获得对应bean时抛出NoSuchBeanDefinitionException异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法与getBean(String name, Class&lt;T&gt; requiredType)方法类似</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定bean的提供者，可以简单理解为，假设一个bean是通过FactoryBean生成，此处将返回创建该bean的FactoryBean。</span></span><br><span class="line"><span class="comment">     * 调用这个方法返回的是一个对象的实例。此接口通常用于封装一个泛型工厂，在每次调用的时候返回一些目标对象新的实例。</span></span><br><span class="line"><span class="comment">     * ObjectFactory和FactoryBean是类似的，只不过FactoryBean通常被定义为BeanFactory中的服务提供者（SPI）实例，</span></span><br><span class="line"><span class="comment">     * 而ObjectFactory通常是以API的形式提供给其他的bean。简单的来说，ObjectFactory一般是提供给开发者使用的，</span></span><br><span class="line"><span class="comment">     * FactoryBean一般是提供给BeanFactory使用的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断当前容器是否存在某种名称的bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断bean是否为单例bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断bean是否为原型bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据bean名称，判断是否有指定类型匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取bean的类型，对于FactoryBean，返回Factory.getObjectType()返回的类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回给定bean的别名（如果有的话），在getBean调用中，所有这些别名都指向同一个bean。</span></span><br><span class="line"><span class="comment">     * 如果给定的名称是别名，则返回相应的原始bean名称和其他别名。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] getAliases(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2、ApplicationContext"><a href="#2、ApplicationContext" class="headerlink" title="2、ApplicationContext"></a>2、ApplicationContext</h2><p>ApplicationContext为BeanFactory的子类，它不仅包含BeanFactory的所有功能，还对其进行了扩展。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class"><span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前应用程序上下文的唯一ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前应用程序上下文所属应用程序的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getApplicationName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前应用程序上下文的具象化类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getDisplayName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前应用上下文第一次加载时的时间戳</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getStartupDate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取父级应用程序上下文，如果没有则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ApplicationContext <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过getAutowireCapableBeanFactory这个方法将 AutowireCapableBeanFactory这个接口暴露给外部使用，</span></span><br><span class="line"><span class="comment"> * AutowireCapableBeanFactory这个接口一般在applicationContext的内部是较少使用的，</span></span><br><span class="line"><span class="comment"> * 它的功能主要是为了装配applicationContext管理之外的Bean。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ApplicationContext本身实现的方法较少，也比较简单，但是他通过继承六个接口来实现了Bean相关的方法等常用功能。<br>ApplicationContext有多种实现类，其中最重要的两类是ConfigurableApplicationContext和WebApplicationContext。</p><h3 id="2-1、ConfigurableApplicationContext"><a href="#2-1、ConfigurableApplicationContext" class="headerlink" title="2.1、ConfigurableApplicationContext"></a>2.1、ConfigurableApplicationContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span>, <span class="title">Lifecycle</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下面这些字符会被认为是用于分割上下文配置路径的分隔符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String CONFIG_LOCATION_DELIMITERS = <span class="string">",; \t\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在BeanFactory中ConversionService对应的bean名称。如果没有实现该类的实例，则使用默认的转换规则。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String CONVERSION_SERVICE_BEAN_NAME = <span class="string">"conversionService"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LoadTimeWaver类所对应的Bean在容器中的名字。如果提供了该实例，上下文会使用临时的 ClassLoader。</span></span><br><span class="line"><span class="comment"> * 这样，LoadTimeWaver就可以使用bean确切的类型了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String LOAD_TIME_WEAVER_BEAN_NAME = <span class="string">"loadTimeWeaver"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Environment在容器中的Bean名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String ENVIRONMENT_BEAN_NAME = <span class="string">"environment"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * System系统变量在容器中对应的Bean名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SYSTEM_PROPERTIES_BEAN_NAME = <span class="string">"systemProperties"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * System环境变量在容器中对应的Bean名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SYSTEM_ENVIRONMENT_BEAN_NAME = <span class="string">"systemEnvironment"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给当前应用上下文设置唯一ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为当前容器设置父容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(@Nullable ApplicationContext parent)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置当前容器的环境变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(ConfigurableEnvironment environment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以ConfigurableEnvironment的形式返回当前容器的环境变量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">ConfigurableEnvironment <span class="title">getEnvironment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为当前容器新增一个BeanFactoryPostProcessor。增加的BeanFactoryPostProcessor将在容器进行refresh操作后使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBeanFactoryPostProcessor</span><span class="params">(BeanFactoryPostProcessor postProcessor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为当前容器新增一个ApplicationListener，增加的Listener将用于发布上下文时间。如初始化刷新容器，关闭容器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为当前容器新增一个ProtocolResolver，ProtocolResolver主要用于自定义协议的解析。</span></span><br><span class="line"><span class="comment"> * 比如spring就有一个 “classpath:”开头的特定协议（但是spring并不是自定义ProtocolResolver 实现来完成这个功能的）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addProtocolResolver</span><span class="params">(ProtocolResolver resolver)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载或者刷新配置，可能是xml文件或者是properties文件，或者是连接数据源。</span></span><br><span class="line"><span class="comment"> * 由于这是一个初始化方法，当前方法执行失败时，则已经创建的Bean也会销毁。</span></span><br><span class="line"><span class="comment"> * 所以调用此方法时，要么所有的Bean都实例化成功，要么一个Bean都没有实例化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向JVM注册一个关闭当前应用上下文的回调函数。当前方法可以多次调用，但是一个应用上下文只会有一个回调函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭当前应用程序上下文，释放所占用对的资源和锁，并且销毁所有已经创建的单例Bean</span></span><br><span class="line"><span class="comment"> * 该close()方法不会调用父类的close方法。父级应用上下文有自己的生命周期。</span></span><br><span class="line"><span class="comment"> * 这个方法可以被多次调用而没有副作用：对已经关闭的上下文的后续close调用将被忽略。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断当前应用上下文是否处于启动状态，即是否至少执行一次refresh()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前应用上下文的BeanFactory容器。不要使用当前方法对BeanFactory生成的Bean进行后置处理，因为此时Bean已经初始化完成。</span></span><br><span class="line"><span class="comment"> * 应该是用BeanFactoryPostProcessor来在Bean声称之前对其进行处理。在获取容器是应该保证容器是在启动状态，即在refresh()和close()之间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、WebApplicationContext"><a href="#2-2、WebApplicationContext" class="headerlink" title="2.2、WebApplicationContext"></a>2.2、WebApplicationContext</h3><p>WebApplicationCOntext是专门为Web应用所准备的，其允许从相对于Web根目录的路径中加载配置文件完成初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整个Web应用上下文是作为属性放置在ServletContext中的，该常量就是应用上下文在ServletContext属性列表中的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + <span class="string">".ROOT"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request作用域，只要发出一个请求就会创建一个request，它的作用域：尽在当前请求中有效。</span></span><br><span class="line"><span class="comment"> * 用处：常用于服务器间同一请求不同页面之间的参数传递，常应用于表单的控件值传递。</span></span><br><span class="line"><span class="comment"> * 方法：request.setAttribute(); request.getAttribute(); request.removeAttribute(); request.getParameter().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_REQUEST = <span class="string">"request"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器会为每个会话创建一个session对象，所以session中的数据可供当前会话中所有servlet共享。</span></span><br><span class="line"><span class="comment"> * 会话：用户打开浏览器会话开始，直到关闭浏览器会话才会结束。一次会话期间只会创建一个session对象。</span></span><br><span class="line"><span class="comment"> * 用处：常用于web开发中的登陆验证界面（当用户登录成功后浏览器分配其一个session键值对）。</span></span><br><span class="line"><span class="comment"> * 方法：session.setAttribute(); session.getAttribute(); session.removeAttribute();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_SESSION = <span class="string">"session"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作用范围：所有的用户都可以取得此信息，此信息在整个服务器上被保留。Application属性范围值，只要设置一次，则所有的网页窗口都可以取得数据。</span></span><br><span class="line"><span class="comment"> * ServletContext在服务器启动时创建，在服务器关闭时销毁，一个JavaWeb应用只创建一个ServletContext对象，</span></span><br><span class="line"><span class="comment"> * 所有的客户端在访问服务器时都共享同一个ServletContext对象;ServletContext对象一般用于在多个客户端间共享数据时使用;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SCOPE_APPLICATION = <span class="string">"application"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在工厂中的bean名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String SERVLET_CONTEXT_BEAN_NAME = <span class="string">"servletContext"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServletContext 初始化参数名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String CONTEXT_PARAMETERS_BEAN_NAME = <span class="string">"contextParameters"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在工厂中 ServletContext 属性值环境bean的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String CONTEXT_ATTRIBUTES_BEAN_NAME = <span class="string">"contextAttributes"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来获取 ServletContext 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3、ApplicationContext和BeanFactory对比"><a href="#3、ApplicationContext和BeanFactory对比" class="headerlink" title="3、ApplicationContext和BeanFactory对比"></a>3、ApplicationContext和BeanFactory对比</h3><p>1.ApplicationContext包含BeanFactory的所有特性，所以一般情况下我们都选择使用ApplicationContext，但是在一些限制情况下，如对于内存消耗要求比较严格的时候使用轻量的BeanFactory是更合理的选择。<br>2.在BeanFactory采用延迟加载的形式来注入Bean。只有使用到某个Bean是，才会对Bean进行加载实例化。而ApplicationContext则相反，它在容器启动时，一次性创建了所有Bean。这样我们就能在容器启动时发现Spring存在的配置错误。<br>3.BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><table><thead><tr><th>功能/特点</th><th>BeanFactory</th><th>ApplicationContext</th></tr></thead><tbody><tr><td>Bean加载方式</td><td>延迟加载</td><td>容器启动时加载所有Bean</td></tr><tr><td>Bean 实例化/装配</td><td>有</td><td>有</td></tr><tr><td>BeanPostProcessor 自动注册</td><td>没有</td><td>有</td></tr><tr><td>BeanFactoryPostProcessor 自动注册</td><td>没有</td><td>有</td></tr><tr><td>MessageSource 便捷访问（针对i18n）</td><td>没有</td><td>有</td></tr><tr><td>ApplicationEvent 发布</td><td>没有</td><td>有</td></tr></tbody></table><h2 id="3、ApplicationContext准备启动"><a href="#3、ApplicationContext准备启动" class="headerlink" title="3、ApplicationContext准备启动"></a>3、ApplicationContext准备启动</h2><p> ps:ContextLoaderListener简介<a href="https://www.cnblogs.com/xunyi/p/10363290.html" target="_blank" rel="noopener">https://www.cnblogs.com/xunyi/p/10363290.html</a></p><p> 在容器启动时会调用ContextLoaderListener中的contextInitialized()方法<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化根web应用程序上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类ContextLoader的方法进行web容器初始化</span></span><br><span class="line">initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭根web应用程序上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">closeWebApplicationContext(event.getServletContext());</span><br><span class="line">ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们查看父类的initWebApplicationListener<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 将上下文存储在本地实例变量中，以确保在ServletContext关闭时可用。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过 createWebApplicationContext 方法创建应用上下文</span></span><br><span class="line"><span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line"><span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 在该方法中调用上下文的 refresh 方法，refresh 就是启动上下文的入口</span></span><br><span class="line">configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac, ServletContext sc)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">wac.refresh();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用SpringBoot启动ApplicationContext时<br>首先我们可以看SpringBoot的启动类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>点击进入SpringApplication的run方法我们可以得知<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 创建一个应用上下文            </span></span><br><span class="line">context = createApplicationContext();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 进入refreshContext方法可以发现实际是调用refresh启动上下文方法</span></span><br><span class="line">refreshContext(context);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过对ContextLoaderListener和SpringApplication两个类的分析我们可以发现，实际最终他们都调用了refresh()方法，所以我们接下来对refresh()进行分析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 预刷新，做一些准备工作。记录了启动时间戳，标记为活动，非关闭状态，并处理配置文件中的占位符</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置文件，创建BeanFactory，对Bean进行包装成BeanDefinition</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对BeanFactory进行增强处理，比如添加BeanPostProcessor，手动注册部分bean等。</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 钩子方法，BeanFactory创建后，对BeanFactory的自定义操作。</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重点：调用了postProcessBeanDefinitionRegistry(registry);</span></span><br><span class="line">            <span class="comment">// springboot中很多激活自动配置的注解都是通过这里导入的。</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重点：从beanFactory中获取所有的BeanPostProcessor，优先进行getBean操作，实例化</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 国际化支持</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化ApplicationEventMulticaster。 如果上下文中未定义，则使用SimpleApplicationEventMulticaster。</span></span><br><span class="line">            <span class="comment">// 这里是监听器的支持，监听器时间多播。</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 钩子方法，springBoot中的嵌入式tomcat就是通过此方法实现的</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听器注册</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重点方法：完成容器中bean的实例化，及代理的生成等操作。</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 完成此上下文的刷新，调用LifecycleProcessor的onRefresh（）方法并发布</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                        <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结： 容器是Spring中最为重要的概念之一，也是Spring大厦的基石。通过总结我们可以发现，Spring Bean的自动注入大大简化了操作，下一步我们将分析，Spring是如何通过Xml文件或者注解的方式将我们需要的Bean放入容器中的。</p>]]></content>
    
    <summary type="html">
    
      容器是Spring的最核心之一，本文将对BeanFactory，ApplicationContext这两个类入手对容器有个基本认识。
    
    </summary>
    
      <category term="Spring" scheme="http://suiwo.xyz/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://suiwo.xyz/tags/Spring/"/>
    
      <category term="BeanFactory" scheme="http://suiwo.xyz/tags/BeanFactory/"/>
    
      <category term="ApplicationContext" scheme="http://suiwo.xyz/tags/ApplicationContext/"/>
    
  </entry>
  
  <entry>
    <title>Hive之行列互转</title>
    <link href="http://suiwo.xyz/2020/12/07/Hive%E4%B9%8B%E8%A1%8C%E5%88%97%E4%BA%92%E8%BD%AC/"/>
    <id>http://suiwo.xyz/2020/12/07/Hive之行列互转/</id>
    <published>2020-12-07T10:35:44.000Z</published>
    <updated>2023-01-07T16:02:50.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、行转列"><a href="#一、行转列" class="headerlink" title="一、行转列"></a>一、行转列</h3><h4 id="1-1-函数说明"><a href="#1-1-函数说明" class="headerlink" title="1.1 函数说明"></a>1.1 函数说明</h4><p><code>CONCAT(string A/col, string B/col...)</code></p><ul><li>返回输入字符串连接后的结果，支持任意个输入字符串</li></ul><p><code>CONCAT_WS(separator, str1, str2,...)</code></p><ul><li>他是一个特殊形式的CONCAT()，第一个参数是剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是NULL返回值也是NULL。这个函数会跳过分隔符参数后的任何NULL和空字符串。分隔符将被加到被连接的字符串之间;</li></ul><p><code>COLLECT_SET(col)</code></p><ul><li>函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生array类型字段。</li></ul><h4 id="1-2-准备数据"><a href="#1-2-准备数据" class="headerlink" title="1.2 准备数据"></a>1.2 准备数据</h4><table><thead><tr><th>name</th><th>constellation</th><th>blood_type</th></tr></thead><tbody><tr><td>孙悟空</td><td>白羊座</td><td>A</td></tr><tr><td>大海</td><td>射手座</td><td>A</td></tr><tr><td>宋宋</td><td>白羊座</td><td>B</td></tr><tr><td>猪八戒</td><td>白羊座</td><td>A</td></tr><tr><td>凤姐</td><td>射手座</td><td>A</td></tr></tbody></table><h4 id="1-3-需求描述"><a href="#1-3-需求描述" class="headerlink" title="1.3 需求描述"></a>1.3 需求描述</h4><p>将星座和血型一样的人归类到一起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">射手座,A 大海|凤姐</span><br><span class="line">白羊座,A 孙悟空|猪八戒</span><br><span class="line">白羊座,B 宋宋</span><br></pre></td></tr></table></figure></p><h4 id="1-4-实现SQL"><a href="#1-4-实现SQL" class="headerlink" title="1.4 实现SQL"></a>1.4 实现SQL</h4><p>sql<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.base, <span class="keyword">CONCAT_WS</span>(<span class="string">"|"</span>, CONCAT_SET(t1.name)) <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">name</span>, <span class="keyword">CONCAT</span>(constellation, <span class="string">","</span>, blood_type) base <span class="keyword">FROM</span> person_info) t1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.base;</span><br></pre></td></tr></table></figure></p><h3 id="二、列转行"><a href="#二、列转行" class="headerlink" title="二、列转行"></a>二、列转行</h3><h4 id="2-1-函数说明"><a href="#2-1-函数说明" class="headerlink" title="2.1 函数说明"></a>2.1 函数说明</h4><p><code>EXPLODE(col)</code></p><ul><li>将hive一列中复杂的array或者map结构拆分成多行。</li></ul><p><code>LATERAL VIEW</code></p><ul><li>用法:LATERAL VIEW udtf(expression) tableAlias AS columnAlias</li><li>解释:用于和split,explode等UDTF一起使用，它能够将一列数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。</li></ul><h4 id="2-2-数据准备"><a href="#2-2-数据准备" class="headerlink" title="2.2 数据准备"></a>2.2 数据准备</h4><table><thead><tr><th>movie</th><th>category</th></tr></thead><tbody><tr><td>《疑犯追踪》</td><td>悬疑,动作,科幻,剧情</td></tr><tr><td>《Lie to me》</td><td>悬疑,警匪,动作,心理,剧情</td></tr><tr><td>《战狼 2》</td><td>战争,动作,灾难</td></tr></tbody></table><h4 id="2-3-需求描述"><a href="#2-3-需求描述" class="headerlink" title="2.3 需求描述"></a>2.3 需求描述</h4><p>将电影分类中的数组数据展开。结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">《疑犯追踪》 悬疑</span><br><span class="line">《疑犯追踪》 动作</span><br><span class="line">《疑犯追踪》 科幻</span><br><span class="line">《疑犯追踪》 剧情</span><br><span class="line">《Lie to me》 悬疑</span><br><span class="line">《Lie to me》 警匪</span><br><span class="line">《Lie to me》 动作</span><br><span class="line">《Lie to me》 心理</span><br><span class="line">《Lie to me》 剧情</span><br><span class="line">《战狼 2》 战争</span><br><span class="line">《战狼 2》 动作</span><br><span class="line">《战狼 2》 灾难</span><br></pre></td></tr></table></figure></p><h4 id="2-4-实现SQL"><a href="#2-4-实现SQL" class="headerlink" title="2.4 实现SQL"></a>2.4 实现SQL</h4><p>sql<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">movie,</span><br><span class="line">category_name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">movie_info lateral <span class="keyword">view</span> explode(<span class="keyword">category</span>) table_tmp <span class="keyword">as</span> category_name;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      本文章从实际案例介绍常见的行转列方法
    
    </summary>
    
      <category term="Hive" scheme="http://suiwo.xyz/categories/Hive/"/>
    
    
      <category term="Hadoop" scheme="http://suiwo.xyz/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hive" scheme="http://suiwo.xyz/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>Hive之窗口函数</title>
    <link href="http://suiwo.xyz/2020/11/30/Hive%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    <id>http://suiwo.xyz/2020/11/30/Hive之窗口函数/</id>
    <published>2020-11-30T03:31:46.000Z</published>
    <updated>2023-01-07T16:02:43.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、常见窗口函数函数"><a href="#一、常见窗口函数函数" class="headerlink" title="一、常见窗口函数函数"></a>一、常见窗口函数函数</h3><ol><li><code>OVER()</code> </li></ol><ul><li>指定分析函数工作的数据窗口大小，这个数据窗口的大小可能会随着行的变化而变化。</li></ul><ol start="2"><li><code>CURRENT ROW</code></li></ol><ul><li>当前行</li></ul><ol start="3"><li><code>n PRECEDING</code></li></ol><ul><li>往前n行数据</li></ul><ol start="4"><li><code>n FOLLOWING</code></li></ol><ul><li>往后n行数据</li></ul><ol start="5"><li><code>UNBOUNDED</code></li></ol><ul><li>起点，UNBOUNDED PRECEDING表示从前面的起点，UNBOUNDED FOLLOWING表示到后面的终点</li></ul><ol start="6"><li><code>LAG(col, n)</code></li></ol><ul><li>往前第n行数据</li></ul><ol start="7"><li><code>LEAD(col, n)</code></li></ol><ul><li>往后第n行数据</li></ul><ol start="8"><li><code>NTILE(n)</code></li></ol><ul><li>把有序分区中的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号。注意：n必须为int类型。</li></ul><h3 id="二、案例实操"><a href="#二、案例实操" class="headerlink" title="二、案例实操"></a>二、案例实操</h3><h4 id="2-1-数据准备-business表"><a href="#2-1-数据准备-business表" class="headerlink" title="2.1 数据准备 business表"></a>2.1 数据准备 business表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">name，orderdate，cost</span><br><span class="line">jack,2017-01-01,10</span><br><span class="line">tony,2017-01-02,15</span><br><span class="line">jack,2017-02-03,23</span><br><span class="line">tony,2017-01-04,29</span><br><span class="line">jack,2017-01-05,46</span><br><span class="line">jack,2017-04-06,42</span><br><span class="line">tony,2017-01-07,50</span><br><span class="line">jack,2017-01-08,55</span><br><span class="line">mart,2017-04-08,62</span><br><span class="line">mart,2017-04-09,68</span><br><span class="line">neil,2017-05-10,12</span><br><span class="line">mart,2017-04-11,75</span><br><span class="line">neil,2017-06-12,80</span><br><span class="line">mart,2017-04-13,94</span><br></pre></td></tr></table></figure><h4 id="2-2-查询在2017年4月份购买过的顾客及总人数"><a href="#2-2-查询在2017年4月份购买过的顾客及总人数" class="headerlink" title="2.2 查询在2017年4月份购买过的顾客及总人数"></a>2.2 查询在2017年4月份购买过的顾客及总人数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">count</span>(*) <span class="keyword">over</span>()</span><br><span class="line"><span class="keyword">from</span> business</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">substring</span>(ordergate, <span class="number">1</span>, <span class="number">7</span>) = <span class="string">'2017-04'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><h4 id="2-3-查询顾客的购买明细及月购买总额"><a href="#2-3-查询顾客的购买明细及月购买总额" class="headerlink" title="2.3 查询顾客的购买明细及月购买总额"></a>2.3 查询顾客的购买明细及月购买总额</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, orderdate, <span class="keyword">cost</span>, <span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">substring</span>(ordergate, <span class="number">1</span>, <span class="number">7</span>))</span><br><span class="line"><span class="keyword">from</span> business</span><br></pre></td></tr></table></figure><h4 id="2-4-上述的场景-要将cost按照日期进行累加"><a href="#2-4-上述的场景-要将cost按照日期进行累加" class="headerlink" title="2.4 上述的场景,要将cost按照日期进行累加"></a>2.4 上述的场景,要将cost按照日期进行累加</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>() <span class="keyword">as</span> sample1,<span class="comment">--所有行相加</span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span>) <span class="keyword">as</span> sample2,<span class="comment">--按name分组，组内 数据相加</span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) <span class="keyword">as</span> sample3,<span class="comment">--按name分组，组内数据累加</span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">PRECEDING</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span> ) <span class="keyword">as</span> sample4 ,<span class="comment">--和sample3一样,由起点到当前行的聚合</span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">PRECEDING</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span>) <span class="keyword">as</span> sample5, <span class="comment">--当前行和前面一行做聚合</span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="number">1</span> <span class="keyword">FOLLOWING</span> ) <span class="keyword">as</span> sample6,<span class="comment">--当前行和前边一行及后面一行</span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="keyword">row</span> <span class="keyword">and</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">FOLLOWING</span> ) <span class="keyword">as</span> sample7 <span class="comment">--当前行及后面所有行</span></span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure><h4 id="2-5-查询顾客上次的购买时间"><a href="#2-5-查询顾客上次的购买时间" class="headerlink" title="2.5 查询顾客上次的购买时间"></a>2.5 查询顾客上次的购买时间</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, orderdate, <span class="keyword">cost</span>, lag(orderdate, <span class="number">1</span>, <span class="string">'1900-01-01'</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span>, <span class="keyword">order</span> <span class="keyword">by</span> orderdate) <span class="keyword">as</span> time1</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure><h4 id="2-6-查询前20-时间的订单信息"><a href="#2-6-查询前20-时间的订单信息" class="headerlink" title="2.6 查询前20%时间的订单信息"></a>2.6 查询前20%时间的订单信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>, ntile(<span class="number">5</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) sorted <span class="keyword">from</span> business)t</span><br><span class="line"><span class="keyword">where</span> sorted = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      窗口函数又名开窗函数，属于分析函数的一种，用于解决复杂报表统计需求的功能强大的函数。
    
    </summary>
    
      <category term="Hive" scheme="http://suiwo.xyz/categories/Hive/"/>
    
    
      <category term="Hadoop" scheme="http://suiwo.xyz/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hive" scheme="http://suiwo.xyz/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>Hive之分桶</title>
    <link href="http://suiwo.xyz/2020/11/27/Hive%E4%B9%8B%E5%88%86%E6%A1%B6/"/>
    <id>http://suiwo.xyz/2020/11/27/Hive之分桶/</id>
    <published>2020-11-27T06:43:35.000Z</published>
    <updated>2023-01-07T16:02:46.214Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、分桶及抽样数据存储"><a href="#一、分桶及抽样数据存储" class="headerlink" title="一、分桶及抽样数据存储"></a>一、分桶及抽样数据存储</h3><p>分区针对的是数据的存储路径；分桶针对的是数据文件。</p><p>分区提供一个隔离数据和优化查询到的便利方式。不过并非所有的数据集都可形成合理的分区，特别是之前所提到的要确定合适的划分大小这个疑虑。<br>分桶试讲数据及分解成更容易管理的若干部分的另一个技术。</p><h3 id="二、创建分桶表"><a href="#二、创建分桶表" class="headerlink" title="二、创建分桶表"></a>二、创建分桶表</h3><h4 id="2-1-首先设置相关属性"><a href="#2-1-首先设置相关属性" class="headerlink" title="2.1 首先设置相关属性"></a>2.1 首先设置相关属性</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.ecforce.bucketing=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces=<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h4 id="2-2-创建一个分桶表"><a href="#2-2-创建一个分桶表" class="headerlink" title="2.2 创建一个分桶表"></a>2.2 创建一个分桶表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu_bucket(<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">name</span> <span class="keyword">string</span>)</span><br><span class="line">clustered <span class="keyword">by</span> (<span class="keyword">id</span>) <span class="keyword">into</span> <span class="number">4</span> buckets</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">field</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><h4 id="2-3-将stu表的数据导入分桶表中"><a href="#2-3-将stu表的数据导入分桶表中" class="headerlink" title="2.3 将stu表的数据导入分桶表中"></a>2.3 将stu表的数据导入分桶表中</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> stu_buck</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure><h3 id="三、分桶抽样调查"><a href="#三、分桶抽样调查" class="headerlink" title="三、分桶抽样调查"></a>三、分桶抽样调查</h3><p>对于非常大的数据集，又是用户需要使用过的是一个具有代表性的查询结果而不是全部结果。Hive可以通过对表的抽样来满足这个需求<br>查询表stu_buck中的数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> stu_buck tablesample(bucket <span class="number">1</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="number">4</span> <span class="keyword">on</span> <span class="keyword">id</span>);</span><br></pre></td></tr></table></figure></p><p>tablesample是抽样语句，语法：<code>TABLESAMPLE(BUCKET x OUT OF y)</code><br>y必须是table总bucket数的倍数或者因子。Hive根据y的大小，决定取样的比例。例如table总共有4份，如果y=2是，则抽取2个bucket数据， 如果y=8，则抽取1/2个bucket的数据。<br>x表示从哪个bucket开始抽取，如果需要取多个分区，以后的分区号为当前分区号加上y。例如<code>tablesample(bucket 1 out of 2)</code>，表示总共抽取(4/2=)2个bucket的数据，抽取第1(x)个和第3(x+y)个bucket的数据。</p>]]></content>
    
    <summary type="html">
    
      对于每一个Hive表（包括分区表），Hive可以进一步对数据进行分桶，桶是更细粒度的数据范围划分。
    
    </summary>
    
      <category term="Hive" scheme="http://suiwo.xyz/categories/Hive/"/>
    
    
      <category term="Hadoop" scheme="http://suiwo.xyz/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hive" scheme="http://suiwo.xyz/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>HiveDML数据操作之查询</title>
    <link href="http://suiwo.xyz/2020/11/25/HiveDML%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E4%B9%8B%E6%9F%A5%E8%AF%A2/"/>
    <id>http://suiwo.xyz/2020/11/25/HiveDML数据操作之查询/</id>
    <published>2020-11-25T12:46:19.000Z</published>
    <updated>2023-01-07T16:03:00.439Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、常用函数"><a href="#一、常用函数" class="headerlink" title="一、常用函数"></a>一、常用函数</h3><p>总行数<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></p><p>最大值<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">id</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></p><p>最小值<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">min</span>(<span class="keyword">id</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></p><p>总和<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(<span class="keyword">id</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></p><p>平均值<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(<span class="keyword">id</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></p><h3 id="二、案例实操"><a href="#二、案例实操" class="headerlink" title="二、案例实操"></a>二、案例实操</h3><h3 id="2-1-比较运算符"><a href="#2-1-比较运算符" class="headerlink" title="2.1 比较运算符"></a>2.1 比较运算符</h3><p>查出薪水大于1000的虽有员工emp<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; <span class="number">1000</span>;</span><br></pre></td></tr></table></figure></p><p>查出薪水等于1000的员工<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure></p><p>查询工资在1000到5000的员工<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">between</span> <span class="number">1000</span> <span class="keyword">and</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure></p><p>查询comm为空的所有员工<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> comm <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p><p>查询工资是1000或者5000的员工<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">in</span> (<span class="number">1000</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="2-2-Like-RLike"><a href="#2-2-Like-RLike" class="headerlink" title="2.2 Like RLike"></a>2.2 Like RLike</h3><p>查询薪资是以2开头的员工<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">like</span> <span class="string">'2%'</span>;</span><br></pre></td></tr></table></figure></p><p>查询薪水中第二个数值为2的员工信息<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">like</span> <span class="string">'_2%'</span>;</span><br></pre></td></tr></table></figure></p><p>查询薪水中含有2的员工信息 (rlike是Hive的一个扩展功能，可以通过正则表达式来指定匹配条件)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">rlike</span> <span class="string">'[2]'</span>;</span><br></pre></td></tr></table></figure></p><h3 id="2-3-Group-By"><a href="#2-3-Group-By" class="headerlink" title="2.3 Group By"></a>2.3 Group By</h3><p>计算各个部门的平均工资<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno, <span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure></p><p>计算各部门中各个岗位的最高薪水<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno, job, <span class="keyword">max</span>(<span class="keyword">sql</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno, job;</span><br></pre></td></tr></table></figure></p><h3 id="2-4-Having"><a href="#2-4-Having" class="headerlink" title="2.4 Having"></a>2.4 Having</h3><p>1.having 与 where 不同点<br>(1)where 针对表中的列发挥作用，查询数据;having 针对查询结果中的列发挥作用， 筛选数据。<br>(2)where 后面不能写聚合函数，而 having 后面可以使用聚合函数。 (3)having 只用于 group by 分组统计语句。<br>计算平均薪资大于2000的部门<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno, <span class="keyword">avg</span>(sal) <span class="keyword">as</span> avg_sal <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">having</span> avg_sal &gt; <span class="number">2000</span>;</span><br></pre></td></tr></table></figure></p><h3 id="2-5-JOIN"><a href="#2-5-JOIN" class="headerlink" title="2.5 JOIN"></a>2.5 JOIN</h3><p>Join 连接谓词中不支持 or<br>左连接<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.empno, e.ename, d.deptno <span class="keyword">from</span> emp e <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno;</span><br></pre></td></tr></table></figure></p><p>右连接<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.empno, e.ename, d.deptno <span class="keyword">from</span> emp e <span class="keyword">right</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno;</span><br></pre></td></tr></table></figure></p><p>内连接<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.empno, e.ename, d.deptno <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno;</span><br></pre></td></tr></table></figure></p><p>满外连接（将会返回所有表中符合 WHERE 语句条件的所有记录。如果任一表的指定字段没有符合条件的值的话，那么就使用 NULL 值替代。）<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.empno, e.ename, d.deptno <span class="keyword">from</span> emp e <span class="keyword">full</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno;</span><br></pre></td></tr></table></figure></p><p>笛卡尔积<br>1.笛卡尔集会在下面条件下产生<br>(1)省略连接条件 (2)连接条件无效 (3)所有表中的所有行互相连接<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empno, dname <span class="keyword">from</span> emp, dept;</span><br></pre></td></tr></table></figure></p><h3 id="2-6-排序"><a href="#2-6-排序" class="headerlink" title="2.6 排序"></a>2.6 排序</h3><ul><li>Order By: 全局排序，一个Reducer</li><li>Sort By: 每个Reducer内部进行排序，对全局结果集来说不是排序。</li><li>Distribute By: 类似MR中partition，进行分区，结合sort by使用。</li><li>Cluster By: 当distribute by和sorts by字段相同时，可以使用cluster by方式。cluster by除了具有distribute by的功能外还兼具sort by的功能。但是排序只能是升序排序，不能指定排序规则为ASC或者DESC。</li></ul><h3 id="2-7-分桶表"><a href="#2-7-分桶表" class="headerlink" title="2.7 分桶表"></a>2.7 分桶表</h3><p>略</p><h3 id="2-8-CASE-WHEN"><a href="#2-8-CASE-WHEN" class="headerlink" title="2.8 CASE WHEN"></a>2.8 CASE WHEN</h3><ol><li>数据准备</li></ol><table><thead><tr><th>name</th><th>dept_id</th><th>sex</th></tr></thead><tbody><tr><td>悟空</td><td>A</td><td>男</td></tr><tr><td>大海</td><td>A</td><td>男</td></tr><tr><td>宋宋</td><td>B</td><td>男</td></tr><tr><td>凤姐</td><td>A</td><td>女</td></tr><tr><td>婷姐</td><td>B</td><td>女</td></tr><tr><td>婷婷</td><td>B</td><td>女</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">dept_id,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> sex <span class="keyword">when</span> <span class="string">'男'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) male_count, <span class="keyword">sum</span>(<span class="keyword">case</span> sex <span class="keyword">when</span> <span class="string">'女'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) female_count</span><br><span class="line"><span class="keyword">from</span> emp_sex</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">  dept_id;</span><br></pre></td></tr></table></figure><h3 id="2-9-其他常用的查询函数"><a href="#2-9-其他常用的查询函数" class="headerlink" title="2.9 其他常用的查询函数"></a>2.9 其他常用的查询函数</h3><p>空字段赋值<br>NVL赋值，它的格式是NVL(string1, replace_with)。它的功能是如果string1是NULL，则NVL函数返回replace_with的值，否则返回string1的值，如果两个参数都是NULL，则返回NULL。</p><p>1)date_format:格式化时间<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive(default)&gt; select date_format('2019-06-29','yyyy-MM-dd');</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">2019-06-29</span><br></pre></td></tr></table></figure></p><p>2)date_add:时间跟天数相加<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select date_add('2019-06-29',5);</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">2019-07-04</span><br><span class="line">hive (default)&gt; select date_add('2019-06-29',-5);</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">2019-06-24</span><br></pre></td></tr></table></figure></p><p>3)date_sub:时间跟天数相减<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select date_sub('2019-06-29',5);</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">2019-06-24</span><br><span class="line">hive (default)&gt; select date_sub('2019-06-29 12:12:12',5);</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">2019-06-24</span><br><span class="line">hive (default)&gt; select date_sub('2019-06-29',-5);</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">2019-07-04</span><br></pre></td></tr></table></figure></p><p>4)datediff:两个时间相减<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select datediff('2019-06-29','2019-06-24');</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">5</span><br><span class="line">hive (default)&gt; select datediff('2019-06-24','2019-06-29');</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">-5</span><br><span class="line">hive (default)&gt; select datediff('2019-06-24 12:12:12','2019-06-29');</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">-5</span><br><span class="line">hive (default)&gt; select datediff('2019-06-24 12:12:12','2019-06-29 13:13:13');</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">-5</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      HiveDML是Hive中对表中数据的查询、插入、删除和修改的语言。
    
    </summary>
    
      <category term="Hive" scheme="http://suiwo.xyz/categories/Hive/"/>
    
    
      <category term="Hadoop" scheme="http://suiwo.xyz/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hive" scheme="http://suiwo.xyz/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>HiveDML数据操作之导入导出</title>
    <link href="http://suiwo.xyz/2020/11/24/HiveDML%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <id>http://suiwo.xyz/2020/11/24/HiveDML数据操作之导入导出/</id>
    <published>2020-11-24T06:54:50.000Z</published>
    <updated>2023-01-07T16:03:04.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、数据导入"><a href="#一、数据导入" class="headerlink" title="一、数据导入"></a>一、数据导入</h3><p>向表中加载数据Load<br>语法<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> [<span class="keyword">local</span>] inpath <span class="string">'/opt/module/datas/student.txt'</span> [overwrite] | <span class="keyword">into</span> <span class="keyword">table</span> student [<span class="keyword">partition</span> (partcol1=val1,...)];</span><br></pre></td></tr></table></figure></p><p>load data：表示加载数据<br>local： 表示从本地数据中加载数据到Hive表中，否则是从HDFS中加载数据到Hive表<br>inpath： 表示加载数据的路径<br>overwrite： 表示覆盖表中的已有数据，否则表示追加<br>into table： 表示加载到哪张表<br>student： 表示表名<br>partition： 表示上传到指定的分区</p><p>案例实操</p><p>创建一张表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(<span class="keyword">id</span> <span class="keyword">string</span>, <span class="keyword">name</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure></p><p>加载本地文件到hive<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/opt/module/datas/student.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> default.student;</span><br></pre></td></tr></table></figure></p><p>加载HDFS文件到Hive<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> inpath <span class="string">'/user/suiwo/hive/student.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> default.student;</span><br></pre></td></tr></table></figure></p><p>加载数据覆盖表中的已有的数据<br>上传文件到HDFS<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs -put /opt/module/datas/student.txt /user/suiwo/hive;</span><br></pre></td></tr></table></figure></p><p>加载数据覆盖表中已有的数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> inpath <span class="string">"/user/suiwo/hive/student.txt"</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> default.student;</span><br></pre></td></tr></table></figure></p><p>通过查询语句向表中插入数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> student <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">'201708'</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">month</span>=<span class="string">'201709'</span>;</span><br></pre></td></tr></table></figure></p><p>查询语句中创建表并加载数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> student3</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure></p><p>import数据到指定的Hive表中（此处导入的数据格式应该是和导出的数据格式相同）<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import table student2 partition(month='201709') from '/user/hive/warehouse/export/student';</span><br></pre></td></tr></table></figure></p><h3 id="二、数据导出"><a href="#二、数据导出" class="headerlink" title="二、数据导出"></a>二、数据导出</h3><p>将查询的结果导出到本地（将local去掉便是将数据导出到HDFS）<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> <span class="keyword">directory</span> <span class="string">'/opt/module/datas/export/student1'</span> <span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure></p><p>将查询的结果格式化导出到本地<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> <span class="keyword">directory</span> <span class="string">'/opt/module/datas/export/student1'</span> <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> dields <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure></p><p>Hadoop命令导出到本地<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs -get /user/hive/warehouse/student/month=2017/00000_0</span><br><span class="line">/opt/module/datas/export/studemt3.txt</span><br></pre></td></tr></table></figure></p><p>Hive Shell 命令导出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hive -e <span class="string">'select * from default.student;'</span> &gt; /opt/module/datas/<span class="built_in">export</span>/student3.txt;</span><br></pre></td></tr></table></figure></p><p>export 导出到HDFS上<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export table default.student to '/user/hive/warehouse/export/student'</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      使用HiveDML将数据进行导入导出。
    
    </summary>
    
      <category term="Hive" scheme="http://suiwo.xyz/categories/Hive/"/>
    
    
      <category term="Hadoop" scheme="http://suiwo.xyz/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hive" scheme="http://suiwo.xyz/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>HiveDDL数据操作</title>
    <link href="http://suiwo.xyz/2020/11/23/HiveDDL%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    <id>http://suiwo.xyz/2020/11/23/HiveDDL数据操作/</id>
    <published>2020-11-23T07:08:46.000Z</published>
    <updated>2023-01-07T16:02:54.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、-Hive集合数据类型"><a href="#一、-Hive集合数据类型" class="headerlink" title="一、 Hive集合数据类型"></a>一、 Hive集合数据类型</h3><p>除了常见的基本数据类型，Hive还支持三种复杂的数据类型ARRAY、MAP和STRUCT。ARRAY和MAP与Java中的Array和Map类似，而STRUCT与C语言中的Struct类似，它封装了一个命名字段集合，复杂数据类型允许任意层次的嵌套。</p><table><thead><tr><th>数据类型</th><th>描述</th><th>语法示例</th></tr></thead><tbody><tr><td>STRUCT</td><td>和c语言中的struct类似，都可以通过“点”符号访问元素内容。例如，如果某个列的数据类型是STRUCT{first STRING, last STRING},那么第1个元素可以通过字段.first来引用。</td><td>struct()</td></tr><tr><td>MAP</td><td>MAP是一组键-值对元组集合，使用数组表示法可以访问数据。例如，如果某个列的数据类型是MAP，其中键-&gt;值对是’first’-&gt;’John’和’last’-&gt;’Doe’，那么可以通过字段名[‘last’]获取最后一个元素</td><td>map()</td></tr><tr><td>ARRAY</td><td>数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，编号从零开始。例如，数组值为[‘John’, ‘Doe’]，那么第2个元素可以通过数组名[1]进行引用。</td><td>Array()</td></tr></tbody></table><h4 id="1-案例实操"><a href="#1-案例实操" class="headerlink" title="1. 案例实操"></a>1. 案例实操</h4><p>假设某表有如下一行，我们用JSON格式来表示其数据结构。下面这个json字符串存在列表，键值对，以及结构体<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"songsong"</span>,</span><br><span class="line">    <span class="attr">"friends"</span>:[ // Array</span><br><span class="line">        <span class="string">"bingbing"</span>,</span><br><span class="line">        <span class="string">"lili"</span></span><br><span class="line">    ],</span><br><span class="line">    "children":&#123; // Map</span><br><span class="line">        "xiao song":18,</span><br><span class="line">        "xiaoxiao song":19</span><br><span class="line">    &#125;,</span><br><span class="line">    "address":&#123; // Struct</span><br><span class="line">        "street":"huilongguan",</span><br><span class="line">        "city":"beijing"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们尝试创建对应的表，并将上述的json中包含的数据导入到这个表中。<br>首先我们创建本地的测试文件test.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">songsong,bingbing_lili,xiaosong:18_xiaoxiaosong:19,huilongguan_beijing</span><br><span class="line">yangyang,caicai_susu,xiaoyang:18_xiaoxiaoyang:19,chaoyang_beijing</span><br></pre></td></tr></table></figure></p><p>注意:MAP，STRUCT和ARRAY里的元素间关系都可以用同一个字符表示，这里用“_”。</p><p>首先我们创建一个数据表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(</span><br><span class="line"><span class="keyword">name</span> <span class="keyword">string</span>,</span><br><span class="line">friend <span class="built_in">array</span>&lt;<span class="keyword">string</span>&gt;,</span><br><span class="line">children <span class="keyword">map</span>&lt;<span class="keyword">string</span>, <span class="built_in">int</span>&gt;,</span><br><span class="line">address <span class="keyword">struct</span>&lt;street:<span class="keyword">string</span>, city:<span class="keyword">string</span>&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="comment">-- 列分隔符</span></span><br><span class="line">collection items <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'_'</span> <span class="comment">-- MAP，ARRAY，STRUCT的分隔符</span></span><br><span class="line"><span class="keyword">map</span> <span class="keyword">keys</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">':'</span> <span class="comment">-- MAP中的key与value的分隔符</span></span><br><span class="line"><span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>; <span class="comment">-- 行分隔符</span></span><br></pre></td></tr></table></figure></p><p>将文本数据导入到测试表中<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">"/filepath/test.txt"</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure></p><p>之后我们尝试访问三种集合列中的数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> friend[<span class="number">1</span>], children[<span class="string">'xiaosong'</span>], address.city <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'songsong'</span>;</span><br></pre></td></tr></table></figure></p><p>执行后可以发现返回结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OK</span><br><span class="line">_c0 _c1 city</span><br><span class="line">lili 18 beijing</span><br><span class="line">Time taken: 0.076 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure></p><h4 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2. 类型转换"></a>2. 类型转换</h4><p>使用CAST操作显示进行数据类型转换<br>例如CAST(‘1’ AS INT)将把字符串’1’转换成整数1;如果强制类型转换失败，如执行CAST(‘X’ AS INT)，表达式返回空值NULL。</p><h3 id="二、-DDL数据操作"><a href="#二、-DDL数据操作" class="headerlink" title="二、 DDL数据操作"></a>二、 DDL数据操作</h3><h4 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h4><p>为了避免已创建的数据库已存在，建议增加if not exists进行判断<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> db_hive;</span><br></pre></td></tr></table></figure></p><p>创建数据库可以指定HDFS上存放的位置<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db_hive location <span class="string">'/db_hive2.db'</span>;</span><br></pre></td></tr></table></figure></p><h4 id="3-查询数据库"><a href="#3-查询数据库" class="headerlink" title="3. 查询数据库"></a>3. 查询数据库</h4><p>显示数据库<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure></p><p>过滤显示查询的数据库<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span> <span class="keyword">like</span> <span class="string">'db_hive*'</span>;</span><br></pre></td></tr></table></figure></p><h4 id="4-查看数据库详细"><a href="#4-查看数据库详细" class="headerlink" title="4. 查看数据库详细"></a>4. 查看数据库详细</h4><p>显示数据库信息<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc database db_hive;</span><br></pre></td></tr></table></figure></p><p>查询数据库详细信息， extended<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc database extended db_hive;</span><br></pre></td></tr></table></figure></p><h4 id="5-切换当前数据库"><a href="#5-切换当前数据库" class="headerlink" title="5. 切换当前数据库"></a>5. 切换当前数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> db_hive;</span><br></pre></td></tr></table></figure><h4 id="6-修改数据库"><a href="#6-修改数据库" class="headerlink" title="6. 修改数据库"></a>6. 修改数据库</h4><p>用户可以使用ALTER DATABASE命令为某个数据库的DBPROPERTIES设置键-值对属性值，来描述这个数据库的属性信息。数据库的其他元数据信息都是不可更改的，包括数据库名和数据库所在的目录位置。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> hive <span class="keyword">set</span> dbproperties(<span class="string">'createtime'</span>=<span class="string">'20170830'</span>);</span><br></pre></td></tr></table></figure></p><h4 id="7-删除数据库"><a href="#7-删除数据库" class="headerlink" title="7. 删除数据库"></a>7. 删除数据库</h4><p>最好采用if exists判断数据库是否存在<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> db_hive2;</span><br></pre></td></tr></table></figure></p><p>对于数据库不为空的时候，可以使用cascade命令强制删除<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> db_hive <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure></p><h4 id="8-创建表"><a href="#8-创建表" class="headerlink" title="8. 创建表"></a>8. 创建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">EXTERNAL</span>] <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] table_name</span><br><span class="line">[(col_name data_type [<span class="keyword">COMMENT</span> col_comment], ...)]</span><br><span class="line">[<span class="keyword">COMMENT</span> table_comment]</span><br><span class="line">[PARTITIONED <span class="keyword">BY</span> (col_name data_type [<span class="keyword">COMMENT</span> col_comment], ...)] [CLUSTERED <span class="keyword">BY</span> (col_name, col_name, ...)</span><br><span class="line">[SORTED <span class="keyword">BY</span> (col_name [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>], ...)] <span class="keyword">INTO</span> num_buckets BUCKETS]</span><br><span class="line">[<span class="keyword">ROW</span> <span class="keyword">FORMAT</span> row_format]</span><br><span class="line">[<span class="keyword">STORED</span> <span class="keyword">AS</span> file_format]</span><br><span class="line">[LOCATION hdfs_path]</span><br></pre></td></tr></table></figure><p>字段解释说明<br>(1)CREATE TABLE创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常;用户可以用IFNOTEXISTS选项来忽略这个异常。<br>(2)EXTERNAL 关键字可以让用户创建一个外部表，在建表的同时指定一个指向实际 数据的路径(LOCATION)，Hive创建内部表时，会将数据移动到数据仓库指向的路径;若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。<br>(3)COMMENT:为表和列添加注释。<br>(4)PARTITIONED BY创建分区表<br>(5)CLUSTERED BY创建分桶表<br>(6)SORTED BY不常用<br>(7)ROW FORMAT<br>DELIMITED [FIELDS TERMINATED BY char] [COLLECTION ITEMS TERMINATED BY char] [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char] | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, …)]<br>用户在建表的时候可以自定义SerDe或者使用自带的 SerDe。如果没有指定ROW FORMAT或者ROW FORMAT DELIMITED，将会使用自带的SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的SerDe，Hive 通过SerDe确定表的具体的列的数据。SerDe是Serialize/Deserilize的简称，目的是用于序列化和反序列化。<br>(8)STORED AS指定存储文件类型,常用的存储文件类型:SEQUENCEFILE(二进制序列文件)、TEXTFILE(文本)、 RCFILE(列式存储格式文件),如果文件数据是纯文本，可以使用STORED AS TEXTFILE。如果数据需要压缩，使用STORED AS SEQUENCEFILE。<br>(9)LOCATION:指定表在HDFS上的存储位置。<br>(10)LIKE允许用户复制现有的表结构，但是不复制数据。</p><h4 id="9-内部表，外部表，分区表"><a href="#9-内部表，外部表，分区表" class="headerlink" title="9. 内部表，外部表，分区表"></a>9. 内部表，外部表，分区表</h4><p>略</p><h3 id="三-分区表常见操作"><a href="#三-分区表常见操作" class="headerlink" title="三. 分区表常见操作"></a>三. 分区表常见操作</h3><ol><li><p>创建分区表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept_partition(deptno <span class="built_in">int</span>, dname <span class="keyword">string</span>, loc <span class="keyword">string</span>)</span><br><span class="line">partitioned <span class="keyword">by</span> (<span class="keyword">month</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure></li><li><p>加载数据到分区表</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/opt/module/datas/dept.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> default.dept_partition <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">'201709'</span>);</span><br><span class="line">hive (default)&gt; load data local inpath '/opt/module/datas/dept.txt' into table default.dept_partition partition(month='201708');</span><br><span class="line">hive (default)&gt; load data local inpath '/opt/module/datas/dept.txt' into table default.dept_partition partition(month='201707’);</span><br></pre></td></tr></table></figure></li><li><p>创建单个分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dept_partition <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">'201706'</span>) ;</span><br></pre></td></tr></table></figure></li><li><p>创建多个分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dept_partition <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">'201705'</span>) <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">'201704'</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除单个分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dept_partition <span class="keyword">drop</span> <span class="keyword">partition</span> (<span class="keyword">month</span>=<span class="string">'201704'</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除多个分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dept_partition <span class="keyword">drop</span> <span class="keyword">partition</span> (<span class="keyword">month</span>=<span class="string">'201705'</span>), <span class="keyword">partition</span> (<span class="keyword">month</span>=<span class="string">'201706'</span>);</span><br></pre></td></tr></table></figure></li></ol><p><em>记得区分创建多个和删除多个的时候，分隔符一个为空格一个为逗号。</em></p><ol start="7"><li>创建二级分区<br>(1) 首先创建一个表<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept_partition2(deptno <span class="built_in">int</span>, dname <span class="keyword">string</span>, loc <span class="keyword">string</span>)</span><br><span class="line">partitioned <span class="keyword">by</span> (<span class="keyword">month</span> <span class="keyword">string</span>, <span class="keyword">day</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure></li></ol><p>(2) 正常的加载数据,加载数据到二级分区表中<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/filepath/test.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> default.dept_partition2 <span class="keyword">partition</span>(moth=<span class="string">'201709'</span>, <span class="keyword">day</span>=<span class="string">'13'</span>);</span><br></pre></td></tr></table></figure></p><p>(3) 查询分区数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dept_partition2 <span class="keyword">where</span> <span class="keyword">month</span>=<span class="string">'201709'</span> <span class="keyword">and</span> <span class="keyword">day</span>=<span class="string">'13'</span>;</span><br></pre></td></tr></table></figure></p><ol start="8"><li>当我们把数据直接上传到分区目录上的时候，我们需要让分区表和数据产生关联，一共有三种方式</li></ol><p>(1) 上传数据后修复<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=12;</span><br><span class="line">dfs -put /opt/module/datas/dept.txt /user/hive/warehouse/dept_partition2/month=201709/day=12;</span><br></pre></td></tr></table></figure></p><p>此时我们是查询不到数据的，需要执行修复指令<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msck <span class="keyword">repair</span> <span class="keyword">table</span> dept_partition2;</span><br></pre></td></tr></table></figure></p><p>这个时候便可以查询到数据了</p><p>(2) 上传数据后添加分区<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=12;</span><br><span class="line">dfs -put /opt/module/datas/dept.txt /user/hive/warehouse/dept_partition2/month=201709/day=12;</span><br></pre></td></tr></table></figure></p><p>执行添加分区<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dept_partition2 <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">'201709'</span>,<span class="keyword">day</span>=<span class="string">'11'</span>);</span><br></pre></td></tr></table></figure></p><p>(3) 创建文件夹后load数据到分区<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=12;</span><br><span class="line">dfs -put /opt/module/datas/dept.txt /user/hive/warehouse/dept_partition2/month=201709/day=12;</span><br></pre></td></tr></table></figure></p><p>上传数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/opt/module/datas/dept.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> dept_partition2 <span class="keyword">partition</span>(<span class="keyword">month</span>=<span class="string">'201709'</span>,<span class="keyword">day</span>=<span class="string">'10'</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      HiveDDL是Hive中负责数据结构定义与数据库对象定义的语言
    
    </summary>
    
      <category term="Hive" scheme="http://suiwo.xyz/categories/Hive/"/>
    
    
      <category term="Hadoop" scheme="http://suiwo.xyz/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hive" scheme="http://suiwo.xyz/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>Hive基础</title>
    <link href="http://suiwo.xyz/2020/11/23/Hive%E5%9F%BA%E7%A1%80/"/>
    <id>http://suiwo.xyz/2020/11/23/Hive基础/</id>
    <published>2020-11-23T05:46:19.000Z</published>
    <updated>2023-01-07T16:02:37.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、-Hive介绍"><a href="#一、-Hive介绍" class="headerlink" title="一、 Hive介绍"></a>一、 Hive介绍</h3><p>Hive是为了解决<code>海量结构化日志</code>的数据统计框架，他是一个基于Hadoop的<code>数据仓库工具</code>，可以将<code>结构化的数据映射为一张表</code>，并提供<code>类SQL</code>的查询功能。本质就是<code>将HQL转化成MR程序</code>。<br>简化流程可以理解成： </p><ol><li>编写SQL。</li><li>Hive匹配出相对应的MR模板并将将SQL转化成MR程序。</li><li>运行MR程序，生成相应的分析结果。</li><li>将结果写入持久化存储。</li></ol><p>Hive优点：</p><ol><li>类SQL语句，简单易上手。</li><li>自动转化成MR程序，减少开发人员学习成本。</li><li>Hive支持自定义函数，用户可以根据自己需求来实现自己的函数。</li></ol><p>Hive缺点：</p><ol><li>效率低，自动生成的MR程序通常情况下不够智能，并且调优比较困难。</li><li>HQL表达能力有限。</li><li>只适合实时性要求不高的场合。</li></ol><h3 id="二、-Hive架构"><a href="#二、-Hive架构" class="headerlink" title="二、 Hive架构"></a>二、 Hive架构</h3><p><img src="/images/Hive基础/0E472121-19CE-4CC2-A08C-9F3B4F42B545.jpeg" alt="a11d648f4c81611b4ccc929be282dba6.jpeg"></p><ol><li><p>Hive提供了三种用户接口<br>CLI(Hive shell)： CLI启动的时候，会同时启动一个Hive副本，CLI会连接到client是Hive的客户端会连接到Hive Server。在启动Client模式的时候，需要指出Hive Server所在节点，并且在该节点启动Hive Server。<br>JDBC/ODBC：使用Java访问Hive。<br>WUI：通过浏览器访问Hive。</p></li><li><p>元数据Metastore<br>Hive将元数据存储在数据库中，如mysql、derby。Hive中的元数据包括表的名字，表所属的数据库(默认是 default)，表的拥有者，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。</p></li><li><p>Hadoop<br>Hive使用HDFS进行存储，使用MR进行计算。</p></li><li><p>驱动器:Driver<br>解析器(SQL Parser):将SQL字符串转换成抽象语法树AST，这一步一般都用第三方工具库完成，比如antlr;对AST进行语法分析，比如表是否存在、字段是否存在、SQL语义是否有误。<br>编译器(Physical Plan):将AST编译生成逻辑执行计划。<br>优化器(Query Optimizer):对逻辑执行计划进行优化。<br>执行器(Execution):把逻辑执行计划转换成可以运行的物理计划。对于Hive来说，就是将其转化成MR/Spark。</p></li></ol><h3 id="三、-Hive与数据库进行比较"><a href="#三、-Hive与数据库进行比较" class="headerlink" title="三、 Hive与数据库进行比较"></a>三、 Hive与数据库进行比较</h3><p>查询语言： SQL被广泛应用在数据仓库中，因此专门针对Hive的提醒设计了类SQL的查询语句HQL。熟悉SQL的开发者可以很方便的使用Hive进行开发。<br>数据存储位： Hive是数据Hadoop生态下的一个数据仓库工具，显然，Hive中的数据是存放在HDFS中的。而数据库一般则是将数据保存在块设备或者本地文件系统中。<br>数据更新：Hive是针对数据仓库应用设计的，而数据仓库的内容一般是读多写少。因此Hive中不建议对数据进行改写。所有数据应当在加载时就确认好。而数据库中的数据通常是需要经常进行修改的，所以使用INSERT，UPDATE比较常见。<br>索引：Hive在加载数据的过程中不会对数据进行任何的处理，甚至不会对数据进行扫描，因此也没有对数据中的某些Key创建索引。Hive想要访问满足条件的特定值的时候，需要使用暴力扫描，因此访问数据的延迟比较大。也正因为延迟大，所以Hive不适合在线数据查询。因为引入了MR，Hive可以进行并行访问数据，所以即使没有索引，在遇到大数据量的访问时，Hive仍然可以体现出优势。数据库中，通常会对常用的列创建一个或者多个索引，因此可以有较高的效率以及较小的延迟。<br>执行： Hive中对的大多数查询的执行都是通过MR来实现的。而数据库通常是存在自己的执行引擎的。<br>执行延迟： Hive由于没有索引，需要扫描整个表，因此延迟较高。并且由于MR自身的延迟就较高，所以在使用MR执行Hive查询的时候，也会有较高的延迟。所以在数据量小的时候数据库的执行能力更好，但是当数据规模比较大，达到超过了数据库的数据处理能力的时候，Hive并行查询能力的优势显然能体现出来了。<br>可扩展性： 由Hive是建立在Hadoop之上的，因此Hive的可扩展性适合Hadoop的可扩展性一致的。数据库由于ACID的严格限制，扩展行非常有限。目前最先进的并行数据库Oracle在理论上的扩展能力也只有100台左右。<br>数据规模： Hive是建立在集群上的，可以利用MR进行并行计算，因此可以执行很大规模的数据。对应的数据库可以支持的数据规模较小。</p><h3 id="四、-Hive常见操作"><a href="#四、-Hive常见操作" class="headerlink" title="四、 Hive常见操作"></a>四、 Hive常见操作</h3><p>在操作Hive之前，我们需要部署好Hive，这部分可以参考<a href="https://suiwo.xyz/2020/05/24/Hive%E5%88%9D%E8%AF%86/">Hive初识</a>中的介绍。<br>并且由于Hive默认的Metastore为derby的性能限制，建议将Metastore改成MYSQL，详细更改方式同样参考<a href="https://suiwo.xyz/2020/05/24/Hive%E5%88%9D%E8%AF%86/">Hive初识</a>。<br>启动Hive  进行Hive文件夹下对的bin目录，我们可以执行<code>./hive</code>启动hive客户端</p><p>查看数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; show databases;</span><br></pre></td></tr></table></figure></p><p>打开默认数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; use default;</span><br></pre></td></tr></table></figure></p><p>显示 default 数据库中的表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; show tables;</span><br></pre></td></tr></table></figure></p><p>创建一张表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create table student(id int, name string);</span><br></pre></td></tr></table></figure></p><p>显示数据库中有几张表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; show tables;</span><br></pre></td></tr></table></figure></p><p>查看表的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; desc student;</span><br></pre></td></tr></table></figure></p><p>向表中插入数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; insert into student values(1000,&quot;ss&quot;);</span><br></pre></td></tr></table></figure></p><p>查询表中数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select * from student;</span><br></pre></td></tr></table></figure></p><p>退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive hive&gt; quit;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      Hive是为了解决海量结构化日志的数据统计框架，他是一个基于Hadoop的数据仓库工具，可以将结构化的数据映射为一张表，并提供类SQL的查询功能。本质就是将HQL转化成MR程序。
    
    </summary>
    
      <category term="Hive" scheme="http://suiwo.xyz/categories/Hive/"/>
    
    
      <category term="Hadoop" scheme="http://suiwo.xyz/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hive" scheme="http://suiwo.xyz/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>MR学习总结</title>
    <link href="http://suiwo.xyz/2020/08/07/MR%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://suiwo.xyz/2020/08/07/MR学习总结/</id>
    <published>2020-08-07T01:54:37.000Z</published>
    <updated>2023-01-07T16:04:11.997Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是在尚硅谷MapReduce课程后的课后总结</p></blockquote><h3 id="一、-MapReduce介绍"><a href="#一、-MapReduce介绍" class="headerlink" title="一、 MapReduce介绍"></a>一、 MapReduce介绍</h3><p>MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念”Map（映射）”和”Reduce（归约）”，是它们的主要思想，都是从函数式编程语言里借来的，还有从矢量编程语言里借来的特性。它极大地方便了编程人员在不会分布式并行编程的情况下，将自己的程序运行在分布式系统上。 当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p><hr><h3 id="二、-MapReduce进程"><a href="#二、-MapReduce进程" class="headerlink" title="二、 MapReduce进程"></a>二、 MapReduce进程</h3><p>一个完整的MapReduce程序在分布式运行时有三类实例进程：<br>| 进程类型 | 作用 |<br>| — | — |<br>| MrAppMaster | 负责整个程序的过程调度及状态协调 |<br>| MapTask | 负责Map阶段的整个数据处理流程 |<br>| ReduceTask | 负责Reduce阶段的整个数据处理流程 |</p><hr><h3 id="三、-常见数据序列化类型"><a href="#三、-常见数据序列化类型" class="headerlink" title="三、 常见数据序列化类型"></a>三、 常见数据序列化类型</h3><table><thead><tr><th>Java类型</th><th>Hadoop Writable类型</th></tr></thead><tbody><tr><td>boolean</td><td>BooleanWritable</td></tr><tr><td>byte</td><td>ByteWritable</td></tr><tr><td>int</td><td>IntWritable</td></tr><tr><td>float</td><td>FloatWritable</td></tr><tr><td>long</td><td>LongWritable</td></tr><tr><td>double</td><td>DoubleWritable</td></tr><tr><td>String</td><td>Text</td></tr><tr><td>map</td><td>MapWritable</td></tr><tr><td>array</td><td>ArrayWritable</td></tr></tbody></table><hr><h3 id="四、-maven包准备"><a href="#四、-maven包准备" class="headerlink" title="四、 maven包准备"></a>四、 maven包准备</h3><h4 id="1-在项目中添加以下pom配置"><a href="#1-在项目中添加以下pom配置" class="headerlink" title="1. 在项目中添加以下pom配置"></a>1. 在项目中添加以下pom配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-hdfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-mapreduce-client-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-在resource目录下添加日志相关配置文件-log4j-properties"><a href="#2-在resource目录下添加日志相关配置文件-log4j-properties" class="headerlink" title="2. 在resource目录下添加日志相关配置文件 log4j.properties"></a>2. 在resource目录下添加日志相关配置文件 log4j.properties</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=INFO, stdout</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n</span><br><span class="line">log4j.appender.logfile=org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.logfile.File=target/spring.log</span><br><span class="line">log4j.appender.logfile.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n</span><br></pre></td></tr></table></figure><hr><h3 id="五、-实现WordCount"><a href="#五、-实现WordCount" class="headerlink" title="五、 实现WordCount"></a>五、 实现WordCount</h3><h4 id="1-统计数据如下"><a href="#1-统计数据如下" class="headerlink" title="1. 统计数据如下"></a>1. 统计数据如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello hadoop</span><br><span class="line">hello hdfs</span><br><span class="line">hello scala</span><br><span class="line">mapreduce</span><br><span class="line">word count</span><br></pre></td></tr></table></figure><h4 id="2-期望输出数据："><a href="#2-期望输出数据：" class="headerlink" title="2. 期望输出数据："></a>2. 期望输出数据：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">count1</span><br><span class="line">hadoop1</span><br><span class="line">hdfs1</span><br><span class="line">hello3</span><br><span class="line">mapreduce1</span><br><span class="line">scala1</span><br><span class="line">word1</span><br></pre></td></tr></table></figure><h4 id="3-编写Mapper方法"><a href="#3-编写Mapper方法" class="headerlink" title="3. 编写Mapper方法"></a>3. 编写Mapper方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Text k = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="keyword">private</span> IntWritable v = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        String line = value.toString();</span><br><span class="line">        String[] lineArr = line.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : lineArr) &#123;</span><br><span class="line">            k.set(s);</span><br><span class="line">            context.write(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-编写Reducer方法"><a href="#4-编写Reducer方法" class="headerlink" title="4. 编写Reducer方法"></a>4. 编写Reducer方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            sum += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key, <span class="keyword">new</span> IntWritable(sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-编写Driver方法"><a href="#5-编写Driver方法" class="headerlink" title="5. 编写Driver方法"></a>5. 编写Driver方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">"/input_path"</span>, <span class="string">"/output/path"</span>&#125;;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="comment">// 获取Job对象</span></span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        <span class="comment">// 设置jar存储位置</span></span><br><span class="line">        job.setJarByClass(WordCountDriver.class);</span><br><span class="line">        <span class="comment">// 关联map和reduce</span></span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        job.setReducerClass(WordCountReducer.class);</span><br><span class="line">        <span class="comment">// 设置mapper阶段输出数据</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        <span class="comment">// 设置最终数据输出类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        <span class="comment">// 设置程序输入路径和输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        <span class="comment">// 提交job</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-执行Driver方法"><a href="#6-执行Driver方法" class="headerlink" title="6. 执行Driver方法"></a>6. 执行Driver方法</h4><p>可在输出路径下看到结果与预期一致</p><hr><h3 id="六、-自定义序列化对象"><a href="#六、-自定义序列化对象" class="headerlink" title="六、 自定义序列化对象"></a>六、 自定义序列化对象</h3><h4 id="1-什么是序列化"><a href="#1-什么是序列化" class="headerlink" title="1. 什么是序列化"></a>1. 什么是序列化</h4><p>序列化就是把内存中的对象，转换成字节序列（或其他数据传输协议）以便于存储到磁盘（持久化）和网络传输。<br>反序列化就是将收到字节序列（或其他数据传输协议）或者是磁盘的持久化数据，转换成内存中的对象。</p><h4 id="2-自定义bean对象实现序列化接口（Writable）"><a href="#2-自定义bean对象实现序列化接口（Writable）" class="headerlink" title="2. 自定义bean对象实现序列化接口（Writable）"></a>2. 自定义bean对象实现序列化接口（Writable）</h4><p>实现一个bean对象的序列化需要以下7个步骤</p><ol><li>类必须实现Writable接口</li><li><p>反序列化的时候，需要反射调用无参构造函数，所以类必须有无参构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WritableBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写序列化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写反序列化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反序列化顺序和序列化顺序必须完全一致。否则会导致反序列化失败</p></li><li>要想把结果显示在文件中，需要重写toString()，可用”\t”分开，方便后续用</li><li>如果自定义bean需要在key中传输，需要实现Comparable接口，因为MapReduce的Shuffle阶段要求key是可排序的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(WritableBean o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-案例实操"><a href="#3-案例实操" class="headerlink" title="3. 案例实操"></a>3. 案例实操</h4><h5 id="1-需求如下："><a href="#1-需求如下：" class="headerlink" title="1. 需求如下："></a>1. 需求如下：</h5><p>需要统计下列数据中每个手机号的总上行流量，总下行流量以及总流量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">113736230513192.196.100.1www.atguigu.com248124681200</span><br><span class="line">213846544121192.196.100.22640200</span><br><span class="line">3 13956435636192.196.100.31321512200</span><br><span class="line">4 13966251146192.168.100.12400404</span><br><span class="line">5 18271575951192.168.100.2www.atguigu.com15272106200</span><br><span class="line">6 84188413192.168.100.3www.atguigu.com41161432200</span><br><span class="line">7 13590439668192.168.100.41116954200</span><br><span class="line">8 15910133277192.168.100.5www.hao123.com31562936200</span><br><span class="line">9 13729199489192.168.100.62400200</span><br><span class="line">10 13630577991192.168.100.7www.shouhu.com6960690200</span><br><span class="line">11 15043685818192.168.100.8www.baidu.com36593538200</span><br><span class="line">12 15959002129192.168.100.9www.atguigu.com1938180500</span><br><span class="line">13 13560439638192.168.100.109184938200</span><br><span class="line">14 13470253144192.168.100.11180180200</span><br><span class="line">15 13682846555192.168.100.12www.qq.com19382910200</span><br><span class="line">16 13992314666192.168.100.13www.gaga.com30083720200</span><br><span class="line">17 13509468723192.168.100.14www.qinghua.com7335110349404</span><br><span class="line">18 18390173782192.168.100.15www.sogou.com95312412200</span><br><span class="line">19 13975057813192.168.100.16www.baidu.com1105848243200</span><br><span class="line">20 13768778790192.168.100.17120120200</span><br><span class="line">21 13568436656192.168.100.18www.alibaba.com248124681200</span><br><span class="line">22 13568436656192.168.100.191116954200</span><br></pre></td></tr></table></figure></p><h5 id="2-期望输出数据：-1"><a href="#2-期望输出数据：-1" class="headerlink" title="2. 期望输出数据："></a>2. 期望输出数据：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">13470253144180180360</span><br><span class="line">135094687237335110349117684</span><br><span class="line">1356043963891849385856</span><br><span class="line">1356843665635972563529232</span><br><span class="line">1359043966811169542070</span><br><span class="line">1363057799169606907650</span><br><span class="line">13682846555193829104848</span><br><span class="line">137291994892400240</span><br><span class="line">1373623051324812468127162</span><br><span class="line">13768778790120120240</span><br><span class="line">138465441212640264</span><br><span class="line">1395643563613215121644</span><br><span class="line">139662511462400240</span><br><span class="line">13975057813110584824359301</span><br><span class="line">13992314666300837206728</span><br><span class="line">15043685818365935387197</span><br><span class="line">15910133277315629366092</span><br><span class="line">1595900212919381802118</span><br><span class="line">18271575951152721063633</span><br><span class="line">183901737829531241211943</span><br><span class="line">84188413411614325548</span><br></pre></td></tr></table></figure><h5 id="3-创建流量统计Bean对象"><a href="#3-创建流量统计Bean对象" class="headerlink" title="3. 创建流量统计Bean对象"></a>3. 创建流量统计Bean对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowBean</span> <span class="keyword">implements</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上行流量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> upFlow;</span><br><span class="line">    <span class="comment">// 下行流量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> downFlow;</span><br><span class="line">    <span class="comment">// 总流量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sumFlow;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlowBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlowBean</span><span class="params">(<span class="keyword">long</span> upFlow, <span class="keyword">long</span> downFlow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.upFlow = upFlow;</span><br><span class="line">        <span class="keyword">this</span>.downFlow = downFlow;</span><br><span class="line">        <span class="keyword">this</span>.sumFlow = upFlow + downFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeLong(upFlow);</span><br><span class="line">        dataOutput.writeLong(downFlow);</span><br><span class="line">        dataOutput.writeLong(sumFlow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        upFlow = dataInput.readLong();</span><br><span class="line">        downFlow = dataInput.readLong();</span><br><span class="line">        sumFlow = dataInput.readLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getUpFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> upFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpFlow</span><span class="params">(<span class="keyword">long</span> upFlow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.upFlow = upFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDownFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> downFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDownFlow</span><span class="params">(<span class="keyword">long</span> downFlow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.downFlow = downFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSumFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sumFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSumFlow</span><span class="params">(<span class="keyword">long</span> sumFlow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sumFlow = sumFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> upFlow + <span class="string">"\t"</span> + downFlow + <span class="string">"\t"</span> + sumFlow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-编写Mapper类"><a href="#4-编写Mapper类" class="headerlink" title="4. 编写Mapper类"></a>4. 编写Mapper类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">FlowBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Text k = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="keyword">private</span> FlowBean flowBean = <span class="keyword">new</span> FlowBean();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取一行</span></span><br><span class="line">        String line = value.toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切割</span></span><br><span class="line">        String[] lineArr = line.split(<span class="string">"\t"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装对象</span></span><br><span class="line">        k.set(lineArr[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">long</span> upFLow = Long.parseLong(lineArr[lineArr.length - <span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">long</span> downFLow = Long.parseLong(lineArr[lineArr.length - <span class="number">2</span>]);</span><br><span class="line">        flowBean.setUpFlow(upFLow);</span><br><span class="line">        flowBean.setDownFlow(downFLow);</span><br><span class="line">        flowBean.setSumFlow(upFLow + downFLow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出</span></span><br><span class="line">        context.write(k, flowBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-编写Reducer类"><a href="#5-编写Reducer类" class="headerlink" title="5. 编写Reducer类"></a>5. 编写Reducer类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowCountReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">FlowBean</span>, <span class="title">Text</span>, <span class="title">FlowBean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FlowBean flowBean = <span class="keyword">new</span> FlowBean();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;FlowBean&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sumUpFlow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> sumDownFlow = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 累计求和</span></span><br><span class="line">        <span class="keyword">for</span> (FlowBean value : values) &#123;</span><br><span class="line">            sumDownFlow += value.getDownFlow();</span><br><span class="line">            sumUpFlow += value.getUpFlow();</span><br><span class="line">        &#125;</span><br><span class="line">        flowBean.setUpFlow(sumUpFlow);</span><br><span class="line">        flowBean.setDownFlow(sumDownFlow);</span><br><span class="line">        flowBean.setSumFlow(sumDownFlow + sumUpFlow);</span><br><span class="line">        <span class="comment">// 写出</span></span><br><span class="line">        context.write(key, flowBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-编写Driver类"><a href="#6-编写Driver类" class="headerlink" title="6. 编写Driver类"></a>6. 编写Driver类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowCountDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">"/input_path"</span>, <span class="string">"/output_path"</span>&#125;;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJarByClass(FlowCountDriver.class);</span><br><span class="line">        job.setMapperClass(FlowCountMapper.class);</span><br><span class="line">        job.setReducerClass(FlowCountReducer.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(FlowBean.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(FlowBean.class);</span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-执行Driver类"><a href="#7-执行Driver类" class="headerlink" title="7. 执行Driver类"></a>7. 执行Driver类</h5><p>可得统计结果与预期一致</p><hr><h3 id="七、-FileInputFormat实现类介绍"><a href="#七、-FileInputFormat实现类介绍" class="headerlink" title="七、 FileInputFormat实现类介绍"></a>七、 FileInputFormat实现类介绍</h3><p>FileInputFormat常见的接口实现类包括：TextInputFormat、KeyValueTextInputFormat、NLineInputFormat、CombineTextInputFormat和自定义InputFormat等。</p><h4 id="1-TextInputFormat"><a href="#1-TextInputFormat" class="headerlink" title="1. TextInputFormat"></a>1. TextInputFormat</h4><p>TextInputFormat是默认的FileInputFormat实现类。按行读取每条记录。键是存储该行在整个文件中的起始字节偏移量， LongWritable类型。值是这行的内容，不包括任何行终止符（换行符和回车符），Text类型。<br>以下是一个示例，比如，一个分片包含了如下4条文本记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rich learning form</span><br><span class="line">Intelligent learning engine</span><br><span class="line">Learning more convenient</span><br><span class="line">From the real demand for more close to the enterprise</span><br></pre></td></tr></table></figure></p><p>每条记录表示为以下键/值对：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(0,Rich learning form)</span><br><span class="line">(19,Intelligent learning engine)</span><br><span class="line">(47,Learning more convenient)</span><br><span class="line">(72,From the real demand for more close to the enterprise)</span><br></pre></td></tr></table></figure></p><h4 id="2-KeyValueTextInputFormat"><a href="#2-KeyValueTextInputFormat" class="headerlink" title="2. KeyValueTextInputFormat"></a>2. KeyValueTextInputFormat</h4><p>每一行均为一条记录，被分隔符分割为key，value。可以通过在驱动类中添加以下配置来设定分隔符。默认分隔符是<code>tab（\t）</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conf.set(KeyValueLineRecordReader.KEY_VALUE_SEPERATOR, <span class="string">"\t"</span>);</span><br></pre></td></tr></table></figure></p><p>以下是一个示例，输入是一个包含4条记录的分片。其中——&gt;表示一个（水平方向的）制表符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">line1 ——&gt;Rich learning form</span><br><span class="line">line2 ——&gt;Intelligent learning engine</span><br><span class="line">line3 ——&gt;Learning more convenient</span><br><span class="line">line4 ——&gt;From the real demand for more close to the enterprise</span><br></pre></td></tr></table></figure></p><p>每条记录表示为以下键/值对：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(line1,Rich learning form)</span><br><span class="line">(line2,Intelligent learning engine)</span><br><span class="line">(line3,Learning more convenient)</span><br><span class="line">(line4,From the real demand for more close to the enterprise)</span><br></pre></td></tr></table></figure></p><p>此时的键是每行排在制表符之前的Text序列。</p><h4 id="3-NLineInputFormat"><a href="#3-NLineInputFormat" class="headerlink" title="3. NLineInputFormat"></a>3. NLineInputFormat</h4><p>如果使用NlineInputFormat，代表每个map进程处理的InputSplit不再按Block块去划分，而是按NlineInputFormat指定的行数N来划分。即输入文件的总行数/N=切片数，如果不整除，切片数=商+1。<br>以下是一个示例，仍然以上面的4行输入为例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rich learning form</span><br><span class="line">Intelligent learning engine</span><br><span class="line">Learning more convenient</span><br><span class="line">From the real demand for more close to the enterprise</span><br></pre></td></tr></table></figure></p><p>例如，如果N是2，则每个输入分片包含两行。开启2个MapTask。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(0,Rich learning form)</span><br><span class="line">(19,Intelligent learning engine)</span><br></pre></td></tr></table></figure></p><p>另一个 mapper 则收到后两行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(47,Learning more convenient)</span><br><span class="line">(72,From the real demand for more close to the enterprise)</span><br></pre></td></tr></table></figure></p><p>这里的键和值与TextInputFormat生成的一样。</p><h4 id="4-CombineTextInputFormat"><a href="#4-CombineTextInputFormat" class="headerlink" title="4. CombineTextInputFormat"></a>4. CombineTextInputFormat</h4><p>框架默认的TextInputFormat切片机制是对任务按文件规划切片，不管文件多小，都会是一个单独的切片，都会交给一个MapTask，这样如果有大量小文件，就会产生大量的MapTask，处理效率极其低下。<br>设置虚拟存储切片最大值方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：虚拟存储切片最大值设置最好根据实际的小文件大小情况来设置具体的值。</span></span><br><span class="line">CombineTextInputFormat.setMaxInputSplitSize(job, <span class="number">4194304</span>);<span class="comment">// 4m</span></span><br></pre></td></tr></table></figure></p><p>（1）虚拟存储过程：<br>将输入目录下所有文件大小，依次和设置的setMaxInputSplitSize值比较，如果不大于设置的最大值，逻辑上划分一个块。如果输入文件大于设置的最大值且大于两倍，那么以最大值切割一块；当剩余数据大小超过设置的最大值且不大于最大值2倍，此时将文件均分成2个虚拟存储块（防止出现太小切片）。<br>例如setMaxInputSplitSize值为4M，输入文件大小为8.02M，则先逻辑上分成一个4M。剩余的大小为4.02M，如果按照4M逻辑划分，就会出现0.02M的小的虚拟存储文件，所以将剩余的4.02M文件切分成（2.01M和2.01M）两个文件。<br>（2）切片过程：<br>（a）判断虚拟存储的文件大小是否大于setMaxInputSplitSize值，大于等于则单独形成一个切片。<br>（b）如果不大于则跟下一个虚拟存储文件进行合并，共同形成一个切片。<br>（c）测试举例：有4个小文件大小分别为1.7M、5.1M、3.4M以及6.8M这四个小文件，则虚拟存储之后形成6个文件块，大小分别为：1.7M，（2.55M、2.55M），3.4M以及（3.4M、3.4M）<br>最终会形成3个切片，大小分别为：（1.7+2.55）M，（2.55+3.4）M，（3.4+3.4）M</p><hr><h3 id="八、-KeyValueTextInputFormat实操"><a href="#八、-KeyValueTextInputFormat实操" class="headerlink" title="八、 KeyValueTextInputFormat实操"></a>八、 KeyValueTextInputFormat实操</h3><h4 id="1-需求如下：-1"><a href="#1-需求如下：-1" class="headerlink" title="1. 需求如下："></a>1. 需求如下：</h4><p>统计输入文件中每一行的第一个单词相同的行数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">banzhang ni hao</span><br><span class="line">xihuan hadoop banzhang</span><br><span class="line">banzhang ni hao</span><br><span class="line">xihuan hadoop banzhang</span><br></pre></td></tr></table></figure></p><h4 id="2-期望输出数据：-2"><a href="#2-期望输出数据：-2" class="headerlink" title="2. 期望输出数据："></a>2. 期望输出数据：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">banzhang2</span><br><span class="line">xihuan2</span><br></pre></td></tr></table></figure><h4 id="3-编写Mapper类"><a href="#3-编写Mapper类" class="headerlink" title="3. 编写Mapper类"></a>3. 编写Mapper类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KVTextMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    IntWritable intWritable = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Text key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        context.write(key, intWritable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-编写Reducer类"><a href="#4-编写Reducer类" class="headerlink" title="4. 编写Reducer类"></a>4. 编写Reducer类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KVTextReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    IntWritable intWritable = <span class="keyword">new</span> IntWritable();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            sum += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        intWritable.set(sum);</span><br><span class="line">        context.write(key, intWritable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-编写Driver类"><a href="#5-编写Driver类" class="headerlink" title="5. 编写Driver类"></a>5. 编写Driver类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KVTextDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">"/input_path"</span>, <span class="string">"/output_path"</span>&#125;;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="comment">// 设置切割符</span></span><br><span class="line">        conf.set(KeyValueLineRecordReader.KEY_VALUE_SEPERATOR, <span class="string">" "</span>);</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJarByClass(KVTextDriver.class);</span><br><span class="line">        job.setMapperClass(KVTextMapper.class);</span><br><span class="line">        job.setReducerClass(KVTextReducer.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        job.setInputFormatClass(KeyValueTextInputFormat.class);</span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-执行Driver方法-1"><a href="#6-执行Driver方法-1" class="headerlink" title="6. 执行Driver方法"></a>6. 执行Driver方法</h4><p>发现输出结果与期望数据一致</p><hr><h3 id="九、-NLineInputFormat实操"><a href="#九、-NLineInputFormat实操" class="headerlink" title="九、 NLineInputFormat实操"></a>九、 NLineInputFormat实操</h3><h4 id="1-需求如下：-2"><a href="#1-需求如下：-2" class="headerlink" title="1. 需求如下："></a>1. 需求如下：</h4><p>对每个单词进行个数统计，要求根据每个输入文件的行数来规定输出多少个切片。此案例要求每三行放入一个切片中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">banzhang ni hao</span><br><span class="line">xihuan hadoop banzhang</span><br><span class="line">banzhang ni hao</span><br><span class="line">xihuan hadoop banzhang</span><br><span class="line">banzhang ni hao</span><br><span class="line">xihuan hadoop banzhang</span><br><span class="line">banzhang ni hao</span><br><span class="line">xihuan hadoop banzhang</span><br><span class="line">banzhang ni hao</span><br><span class="line">xihuan hadoop banzhang banzhang ni hao</span><br><span class="line">xihuan hadoop banzhang</span><br></pre></td></tr></table></figure></p><h4 id="2-期待输出数据："><a href="#2-期待输出数据：" class="headerlink" title="2. 期待输出数据："></a>2. 期待输出数据：</h4><p>在日志中打印的分区数为4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number of splits:4</span><br></pre></td></tr></table></figure></p><h4 id="3-编写Mapper类-1"><a href="#3-编写Mapper类-1" class="headerlink" title="3. 编写Mapper类"></a>3. 编写Mapper类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NLineMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    Text k = <span class="keyword">new</span> Text();</span><br><span class="line">    IntWritable v = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        String line = value.toString();</span><br><span class="line">        String[] strArr = line.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : strArr) &#123;</span><br><span class="line">            k.set(s);</span><br><span class="line">            context.write(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-编写Reducer类-1"><a href="#4-编写Reducer类-1" class="headerlink" title="4. 编写Reducer类"></a>4. 编写Reducer类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NLineReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    IntWritable v = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            sum += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        v.set(sum);</span><br><span class="line">        context.write(key, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-编写Driver类-1"><a href="#5-编写Driver类-1" class="headerlink" title="5. 编写Driver类"></a>5. 编写Driver类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NLineDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">"/input_path"</span>, <span class="string">"/output_path"</span>&#125;;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        <span class="comment">// 设置每个切片InputSplit中划分三条记录</span></span><br><span class="line">        NLineInputFormat.setNumLinesPerSplit(job, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 使用NLineInputFormat处理记录数</span></span><br><span class="line">        job.setInputFormatClass(NLineInputFormat.class);</span><br><span class="line">        job.setJarByClass(NLineDriver.class);</span><br><span class="line">        job.setMapperClass(NLineMapper.class);</span><br><span class="line">        job.setReducerClass(NLineReducer.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="自定义InputFormat"><a href="#自定义InputFormat" class="headerlink" title="自定义InputFormat"></a>自定义InputFormat</h3><p>无论HDFS还是MapReduce，在处理小文件时效率都非常低，但又难免面临处理大量小文件的场景，此时，就需要有相应解决方案。可以自定义InputFormat实现小文件的合并。</p><h4 id="1．需求"><a href="#1．需求" class="headerlink" title="1．需求"></a>1．需求</h4><p>将多个小文件合并成一个SequenceFile文件（SequenceFile文件是Hadoop用来存储二进制形式的key-value对的文件格式），SequenceFile里面存储着多个文件，存储的形式为文件路径+名称为key，文件内容为value。<br>输入数据为三个文件，所存储的数据分别如下<br>1.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yongpeng weidong weinan</span><br><span class="line">sanfeng luozong xiaoming</span><br></pre></td></tr></table></figure></p><p>2.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">longlong fanfan</span><br><span class="line">mazong kailun yuhang yixin</span><br><span class="line">longlong fanfan</span><br><span class="line">mazong kailun yuhang yixin</span><br></pre></td></tr></table></figure></p><p>3.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shuaige changmo zhenqiang </span><br><span class="line">dongli lingu xuanxuan</span><br></pre></td></tr></table></figure></p><h4 id="2-自定义InputFormat流程"><a href="#2-自定义InputFormat流程" class="headerlink" title="2. 自定义InputFormat流程"></a>2. 自定义InputFormat流程</h4><ol><li>自定义一个类继承FileInputFormat<br>（1）重写isSplitable()方法，返回false不可切割<br>（2）重写createRecordReader()，创建自定义的RecordReader对象，并初始化</li><li>改写RecordReader，实现一次读取一个完整文件封装为KV<br>（1）采用IO流一次读取一个文件输出到value中，因为设置了不可切片，最终把所有文件都封装到了value中<br>（2）获取文件路径信息+名称，并设置key</li><li>设置Driver<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）设置输入的自定义inputFormat</span></span><br><span class="line">job.setInputFormatClass(XXXFileInputformat.class);</span><br><span class="line"><span class="comment">// （2）设置输出的outputFormat</span></span><br><span class="line">job.setOutputFormatClass(SequenceFileOutputFormat.class);</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-实现WholeFileInputFormat"><a href="#3-实现WholeFileInputFormat" class="headerlink" title="3. 实现WholeFileInputFormat"></a>3. 实现WholeFileInputFormat</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WholeFileInputFormat</span> <span class="keyword">extends</span> <span class="title">FileInputFormat</span>&lt;<span class="title">Text</span>, <span class="title">BytesWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RecordReader&lt;Text, BytesWritable&gt; <span class="title">createRecordReader</span><span class="params">(InputSplit inputSplit, TaskAttemptContext taskAttemptContext)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        WholeRecordReader recordReader = <span class="keyword">new</span> WholeRecordReader();</span><br><span class="line">        recordReader.initialize(inputSplit, taskAttemptContext);</span><br><span class="line">        <span class="keyword">return</span> recordReader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-实现WholeRecordReader类"><a href="#4-实现WholeRecordReader类" class="headerlink" title="4. 实现WholeRecordReader类"></a>4. 实现WholeRecordReader类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WholeRecordReader</span> <span class="keyword">extends</span> <span class="title">RecordReader</span>&lt;<span class="title">Text</span>, <span class="title">BytesWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    FileSplit split;</span><br><span class="line">    Configuration configuration;</span><br><span class="line">    Text k = <span class="keyword">new</span> Text();</span><br><span class="line">    BytesWritable v = <span class="keyword">new</span> BytesWritable();</span><br><span class="line">    <span class="keyword">boolean</span> isProgress = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(InputSplit inputSplit, TaskAttemptContext taskAttemptContext)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">this</span>.split = (FileSplit) inputSplit;</span><br><span class="line">        <span class="keyword">this</span>.configuration = taskAttemptContext.getConfiguration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">nextKeyValue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 核心业务</span></span><br><span class="line">        <span class="keyword">if</span> (isProgress)&#123;</span><br><span class="line">            <span class="comment">// 1. 获取fileSystem对象</span></span><br><span class="line">            Path path = split.getPath();</span><br><span class="line">            FileSystem fileSystem = path.getFileSystem(configuration);</span><br><span class="line">            <span class="comment">// 2. 获取输入流</span></span><br><span class="line">            FSDataInputStream fsDataInputStream = fileSystem.open(path);</span><br><span class="line">            <span class="comment">// 3. 拷贝</span></span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) split.getLength()];</span><br><span class="line">            IOUtils.readFully(fsDataInputStream, buf, <span class="number">0</span>, buf.length);</span><br><span class="line">            <span class="comment">// 4. 封装kv</span></span><br><span class="line">            k.set(path.toString());</span><br><span class="line">            v.set(buf, <span class="number">0</span>, buf.length);</span><br><span class="line">            <span class="comment">// 5. 关闭资源</span></span><br><span class="line">            IOUtils.closeStream(fsDataInputStream);</span><br><span class="line">            isProgress = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Text <span class="title">getCurrentKey</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BytesWritable <span class="title">getCurrentValue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getProgress</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-编写Mapper方法"><a href="#5-编写Mapper方法" class="headerlink" title="5. 编写Mapper方法"></a>5. 编写Mapper方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceFileMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Text</span>, <span class="title">BytesWritable</span>, <span class="title">Text</span>, <span class="title">BytesWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Text key, BytesWritable value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        context.write(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-编写Reducer方法"><a href="#6-编写Reducer方法" class="headerlink" title="6. 编写Reducer方法"></a>6. 编写Reducer方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceFileReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">BytesWritable</span>, <span class="title">Text</span>, <span class="title">BytesWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;BytesWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (BytesWritable value : values) &#123;</span><br><span class="line">            context.write(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-编写Driver方法"><a href="#7-编写Driver方法" class="headerlink" title="7. 编写Driver方法"></a>7. 编写Driver方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceFileDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">"/input_path"</span>, <span class="string">"/output_path"</span>&#125;;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJarByClass(SequenceFileDriver.class);</span><br><span class="line">        job.setMapperClass(SequenceFileMapper.class);</span><br><span class="line">        job.setReducerClass(SequenceFileReducer.class);</span><br><span class="line">        <span class="comment">// 设置输入的inputFormat</span></span><br><span class="line">        job.setInputFormatClass(WholeFileInputFormat.class);</span><br><span class="line">        <span class="comment">// 设置输出的outputFormat</span></span><br><span class="line">        job.setOutputFormatClass(SequenceFileOutputFormat.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(BytesWritable.class);</span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="十、-实现自定义Partition分区"><a href="#十、-实现自定义Partition分区" class="headerlink" title="十、 实现自定义Partition分区"></a>十、 实现自定义Partition分区</h3><h4 id="1-需求："><a href="#1-需求：" class="headerlink" title="1. 需求："></a>1. 需求：</h4><p>在之前统计流量的基础上，将统计结果按照手机归属地不同省份输出到不同文件中</p><h4 id="2-在之前的案例中添加一个自定义分区类"><a href="#2-在之前的案例中添加一个自定义分区类" class="headerlink" title="2. 在之前的案例中添加一个自定义分区类"></a>2. 在之前的案例中添加一个自定义分区类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProvincePartitioner</span> <span class="keyword">extends</span> <span class="title">Partitioner</span>&lt;<span class="title">Text</span>, <span class="title">FlowBean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(Text text, FlowBean flowBean, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> partition = <span class="number">4</span>;</span><br><span class="line">        String prePhone = text.toString().substring(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"136"</span>.equals(prePhone)) &#123;</span><br><span class="line">            partition = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"137"</span>.equals(prePhone)) &#123;</span><br><span class="line">            partition = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"138"</span>.equals(prePhone)) &#123;</span><br><span class="line">            partition = <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"139"</span>.equals(prePhone)) &#123;</span><br><span class="line">            partition = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> partition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-在原案例的Driver方法中添加分区配置"><a href="#3-在原案例的Driver方法中添加分区配置" class="headerlink" title="3. 在原案例的Driver方法中添加分区配置"></a>3. 在原案例的Driver方法中添加分区配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowCountDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">"/Users/zhangjia/Desktop/phone.txt"</span>, <span class="string">"/Users/zhangjia/Desktop/result_phone"</span>&#125;;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJarByClass(FlowCountDriver.class);</span><br><span class="line">        job.setMapperClass(FlowCountMapper.class);</span><br><span class="line">        job.setReducerClass(FlowCountReducer.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(FlowBean.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(FlowBean.class);</span><br><span class="line">        <span class="comment">// 设置自定义分区类</span></span><br><span class="line">        job.setPartitionerClass(ProvincePartitioner.class);</span><br><span class="line">        <span class="comment">// 设定Reducer任务数量</span></span><br><span class="line">        job.setNumReduceTasks(<span class="number">5</span>);</span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-执行"><a href="#4-执行" class="headerlink" title="4. 执行"></a>4. 执行</h4><p>发现输出结果已经按照手机号前三位进行分区</p><h4 id="5-注意"><a href="#5-注意" class="headerlink" title="5. 注意"></a>5. 注意</h4><p>对于Driver中设置的Reducer Task任务数量<br>（1）如果ReduceTask的数量&gt; getPartition的结果数，则会多产生几个空的输出文件part-r-000xx；<br>（2）如果1&lt;ReduceTask的数量&lt;getPartition的结果数，则有一部分分区数据无处安放，会Exception；<br>（3）如果ReduceTask的数量=1，则不管MapTask端输出多少个分区文件，最终结果都交给这一个ReduceTask，最终也就只会产生一个结果文件 part-r-00000；<br>（4）分区号必须从零开始，逐一累加。<br>举例：例如：假设自定义分区数为5，则</p><table><thead><tr><th>DriverTask数</th><th>结果</th></tr></thead><tbody><tr><td>1</td><td>会正常运行，只不过会产生一个输出文件</td></tr><tr><td>2</td><td>会报错</td></tr><tr><td>6</td><td>大于5，程序会正常运行，会产生空文件</td></tr></tbody></table><h3 id="十一、-自定义WritableComparable排序"><a href="#十一、-自定义WritableComparable排序" class="headerlink" title="十一、 自定义WritableComparable排序"></a>十一、 自定义WritableComparable排序</h3><h4 id="1-原理分析"><a href="#1-原理分析" class="headerlink" title="1. 原理分析"></a>1. 原理分析</h4><p>bean对象做为key传输，需要实现WritableComparable接口重写compareTo方法，就可以实现排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(FlowBean o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-WritableComparable排序案例实操（全排序）"><a href="#2-WritableComparable排序案例实操（全排序）" class="headerlink" title="2. WritableComparable排序案例实操（全排序）"></a>2. WritableComparable排序案例实操（全排序）</h4><h5 id="1-输入数据为之前流量统计的输出数据"><a href="#1-输入数据为之前流量统计的输出数据" class="headerlink" title="1. 输入数据为之前流量统计的输出数据"></a>1. 输入数据为之前流量统计的输出数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">13470253144180180360</span><br><span class="line">135094687237335110349117684</span><br><span class="line">1356043963891849385856</span><br><span class="line">1356843665635972563529232</span><br><span class="line">1359043966811169542070</span><br><span class="line">1363057799169606907650</span><br><span class="line">13682846555193829104848</span><br><span class="line">137291994892400240</span><br><span class="line">1373623051324812468127162</span><br><span class="line">13768778790120120240</span><br><span class="line">138465441212640264</span><br><span class="line">1395643563613215121644</span><br><span class="line">139662511462400240</span><br><span class="line">13975057813110584824359301</span><br><span class="line">13992314666300837206728</span><br><span class="line">15043685818365935387197</span><br><span class="line">15910133277315629366092</span><br><span class="line">1595900212919381802118</span><br><span class="line">18271575951152721063633</span><br><span class="line">183901737829531241211943</span><br><span class="line">84188413411614325548</span><br></pre></td></tr></table></figure><h5 id="2-期望输出数据"><a href="#2-期望输出数据" class="headerlink" title="2. 期望输出数据"></a>2. 期望输出数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">135094687237335110349117684</span><br><span class="line">13975057813110584824359301</span><br><span class="line">1356843665635972563529232</span><br><span class="line">1373623051324812468127162</span><br><span class="line">183901737829531241211943</span><br><span class="line">1363057799169606907650</span><br><span class="line">15043685818365935387197</span><br><span class="line">13992314666300837206728</span><br><span class="line">15910133277315629366092</span><br><span class="line">1356043963891849385856</span><br><span class="line">84188413411614325548</span><br><span class="line">13682846555193829104848</span><br><span class="line">18271575951152721063633</span><br><span class="line">1595900212919381802118</span><br><span class="line">1359043966811169542070</span><br><span class="line">1395643563613215121644</span><br><span class="line">13470253144180180360</span><br><span class="line">138465441212640264</span><br><span class="line">139662511462400240</span><br><span class="line">13768778790120120240</span><br><span class="line">137291994892400240</span><br></pre></td></tr></table></figure><h5 id="3-编写自定义FlowBean类"><a href="#3-编写自定义FlowBean类" class="headerlink" title="3. 编写自定义FlowBean类"></a>3. 编写自定义FlowBean类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowBean</span> <span class="keyword">implements</span> <span class="title">WritableComparable</span>&lt;<span class="title">FlowBean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上行流量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> upFlow;</span><br><span class="line">    <span class="comment">// 下行流量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> downFlow;</span><br><span class="line">    <span class="comment">// 总流量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sumFlow;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlowBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlowBean</span><span class="params">(<span class="keyword">long</span> upFlow, <span class="keyword">long</span> downFlow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.upFlow = upFlow;</span><br><span class="line">        <span class="keyword">this</span>.downFlow = downFlow;</span><br><span class="line">        <span class="keyword">this</span>.sumFlow = upFlow + downFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(FlowBean o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sumFlow &gt; o.getSumFlow() ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeLong(upFlow);</span><br><span class="line">        dataOutput.writeLong(downFlow);</span><br><span class="line">        dataOutput.writeLong(sumFlow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        upFlow = dataInput.readLong();</span><br><span class="line">        downFlow = dataInput.readLong();</span><br><span class="line">        sumFlow = dataInput.readLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getUpFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> upFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpFlow</span><span class="params">(<span class="keyword">long</span> upFlow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.upFlow = upFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDownFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> downFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDownFlow</span><span class="params">(<span class="keyword">long</span> downFlow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.downFlow = downFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSumFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sumFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSumFlow</span><span class="params">(<span class="keyword">long</span> sumFlow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sumFlow = sumFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> upFlow + <span class="string">"\t"</span> + downFlow + <span class="string">"\t"</span> + sumFlow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-编写Mapper类-1"><a href="#4-编写Mapper类-1" class="headerlink" title="4. 编写Mapper类"></a>4. 编写Mapper类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowCountSortMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">FlowBean</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    FlowBean flowBean = <span class="keyword">new</span> FlowBean();</span><br><span class="line">    Text v = <span class="keyword">new</span> Text();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        String line = value.toString();</span><br><span class="line">        String[] strArr = line.split(<span class="string">"\t"</span>);</span><br><span class="line">        String phoneNum = strArr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">long</span> upFlow = Long.parseLong(strArr[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">long</span> downFlow = Long.parseLong(strArr[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">long</span> sumFlow = Long.parseLong(strArr[<span class="number">3</span>]);</span><br><span class="line">        flowBean.setUpFlow(upFlow);</span><br><span class="line">        flowBean.setDownFlow(downFlow);</span><br><span class="line">        flowBean.setSumFlow(sumFlow);</span><br><span class="line">        v.set(phoneNum);</span><br><span class="line">        context.write(flowBean, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-编写Reducer类-1"><a href="#5-编写Reducer类-1" class="headerlink" title="5. 编写Reducer类"></a>5. 编写Reducer类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowCountSortReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">FlowBean</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">FlowBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(FlowBean key, Iterable&lt;Text&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Text value : values) &#123;</span><br><span class="line">            context.write(value, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-编写Driver方法"><a href="#6-编写Driver方法" class="headerlink" title="6. 编写Driver方法"></a>6. 编写Driver方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowCountSortDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 输入输出路径需要根据自己电脑上实际的输入输出路径设置</span></span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">"/input_path"</span>,<span class="string">"/output_path"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取配置信息，或者job对象实例</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 指定本程序的jar包所在的本地路径</span></span><br><span class="line">        job.setJarByClass(FlowCountSortDriver.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 指定本业务job要使用的mapper/Reducer业务类</span></span><br><span class="line">        job.setMapperClass(FlowCountSortMapper.class);</span><br><span class="line">        job.setReducerClass(FlowCountSortReducer.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 指定mapper输出数据的kv类型</span></span><br><span class="line">        job.setMapOutputKeyClass(FlowBean.class);</span><br><span class="line">        job.setMapOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 指定最终输出的数据的kv类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(FlowBean.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 指定job的输入原始文件所在目录</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7 将job中配置的相关参数，以及job所用的java类所在的jar包， 提交给yarn去运行</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-执行"><a href="#7-执行" class="headerlink" title="7. 执行"></a>7. 执行</h5><p>执行后发现结果与期望数据一致</p><p>注：如果希望实现区内排序，只需要在之前需求的基础上添加一个自定义Partition类即可。</p>]]></content>
    
    <summary type="html">
    
      MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念&quot;Map（映射）&quot;和&quot;Reduce（归约）&quot;，是它们的主要思想，都是从函数式编程语言里借来的，还有从矢量编程语言里借来的特性。它极大地方便了编程人员在不会分布式并行编程的情况下，将自己的程序运行在分布式系统上。 当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。
    
    </summary>
    
      <category term="MapReduce" scheme="http://suiwo.xyz/categories/MapReduce/"/>
    
    
      <category term="Hadoop" scheme="http://suiwo.xyz/tags/Hadoop/"/>
    
      <category term="Flume" scheme="http://suiwo.xyz/tags/Flume/"/>
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="MapReduce" scheme="http://suiwo.xyz/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>Flume自定义Sink</title>
    <link href="http://suiwo.xyz/2020/06/02/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Sink/"/>
    <id>http://suiwo.xyz/2020/06/02/Flume自定义Sink/</id>
    <published>2020-06-02T06:11:17.000Z</published>
    <updated>2023-01-07T16:01:48.173Z</updated>
    
    <content type="html"><![CDATA[<p>本文为尚硅谷Flume课程随堂笔记</p><hr><hr><h3 id="一、-项目介绍"><a href="#一、-项目介绍" class="headerlink" title="一、 项目介绍"></a>一、 项目介绍</h3><p>使用 flume 接收数据，并在 Sink 端给每条数据添加前缀和后缀，输出到控制台。前后 缀可在flume任务配置文件中配置。</p><blockquote><p><a href="https://flume.apache.org/FlumeDeveloperGuide.html#sink" target="_blank" rel="noopener">https://flume.apache.org/FlumeDeveloperGuide.html#sink</a> 根据官方说明自定义 MySink 需要继承 AbstractSink 类并实现 Configurable 接口。</p></blockquote><hr><hr><h3 id="二、-Sink"><a href="#二、-Sink" class="headerlink" title="二、 Sink"></a>二、 Sink</h3><h4 id="1-创建maven项目"><a href="#1-创建maven项目" class="headerlink" title="1.创建maven项目"></a>1.创建maven项目</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flume<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flume-ng-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="2-构建自定义类"><a href="#2-构建自定义类" class="headerlink" title="2. 构建自定义类"></a>2. 构建自定义类</h4><p>根据官方说明自定义 MySink 需要继承 AbstractSink 类并实现 Configurable 接口。<br>具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flume.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.conf.Configurable;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.sink.AbstractSink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> suiwo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span> MySink</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/2 14:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> //todo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySink</span> <span class="keyword">extends</span> <span class="title">AbstractSink</span> <span class="keyword">implements</span> <span class="title">Configurable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String subfix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 获取Channel</span></span><br><span class="line"><span class="comment">     * 2. 从Channel获取事务以及数据</span></span><br><span class="line"><span class="comment">     * 3. 发送数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> EventDeliveryException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 定义返回值</span></span><br><span class="line">        Status status;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取Channel</span></span><br><span class="line">        Channel channel = getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 从Channel中获取事务</span></span><br><span class="line">        Transaction transaction = channel.getTransaction();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 启动事务</span></span><br><span class="line">        transaction.begin();</span><br><span class="line">        Event event;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 5. 从Channel中获取数据</span></span><br><span class="line">            event = channel.take();</span><br><span class="line">        &#125; <span class="keyword">while</span> (event == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 处理事件</span></span><br><span class="line">            String body = <span class="keyword">new</span> String(event.getBody());</span><br><span class="line">            System.out.println(prefix + <span class="string">"--"</span> + body + <span class="string">"--"</span> + subfix);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 提交事务</span></span><br><span class="line">            transaction.commit();</span><br><span class="line">            status = Status.READY;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ChannelException e) &#123;</span><br><span class="line">            transaction.rollback();</span><br><span class="line">            <span class="comment">// 10. 修改状态</span></span><br><span class="line">            status = Status.BACKOFF;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 11. 关闭事务</span></span><br><span class="line">            transaction.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        prefix = context.getString(<span class="string">"prefix"</span>);</span><br><span class="line">        subfix = context.getString(<span class="string">"subfix"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="3-maven打包"><a href="#3-maven打包" class="headerlink" title="3. maven打包"></a>3. maven打包</h4><p>将项目打包，并将项目放至flume的lib目录下</p><hr><hr><h3 id="三、编写Flume相关配置"><a href="#三、编写Flume相关配置" class="headerlink" title="三、编写Flume相关配置"></a>三、编写Flume相关配置</h3><h4 id="1-编写my-sink-conf"><a href="#1-编写my-sink-conf" class="headerlink" title="1. 编写my-sink.conf"></a>1. 编写my-sink.conf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Name the components on this agent</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = localhost</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line">a1.sinks.k1.type = xyz.suiwo.flume.sink.MySink</span><br><span class="line">a1.sinks.k1.prefix = suiwo</span><br><span class="line">a1.sinks.k1.subfix = haha</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><hr><hr><h3 id="四、-启动测试"><a href="#四、-启动测试" class="headerlink" title="四、 启动测试"></a>四、 启动测试</h3><p>执行下面指令启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flume-ng agent -c conf -f job/my-sink.conf -n a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      Sink 是完全事务性的。在从 Channel 批量删除数据之前，每个 Sink 用 Channel 启动一 个事务。批量事件一旦成功写出到存储系统或下一个 Flume Agent，Sink 就利用 Channel 提 交事务。事务一旦被提交，该 Channel 从自己的内部缓冲区删除事件。Sink 组件目的地包括 hdfs、logger、avro、thrift、ipc、file、null、HBase、solr、 自定义。官方提供的 Sink 类型已经很多，但是有时候并不能满足实际开发当中的需求，此 时我们就需要根据实际需求自定义某些 Sink。
    
    </summary>
    
      <category term="Flume" scheme="http://suiwo.xyz/categories/Flume/"/>
    
    
      <category term="Hadoop" scheme="http://suiwo.xyz/tags/Hadoop/"/>
    
      <category term="Flume" scheme="http://suiwo.xyz/tags/Flume/"/>
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Flume自定义Source</title>
    <link href="http://suiwo.xyz/2020/06/01/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Source/"/>
    <id>http://suiwo.xyz/2020/06/01/Flume自定义Source/</id>
    <published>2020-06-01T07:39:00.000Z</published>
    <updated>2023-01-07T16:01:53.556Z</updated>
    
    <content type="html"><![CDATA[<p>本文为尚硅谷Flume课程随堂笔记</p><hr><hr><h3 id="一、-项目介绍"><a href="#一、-项目介绍" class="headerlink" title="一、 项目介绍"></a>一、 项目介绍</h3><p>在本案例中使用flume接收数据，并给每条数据添加前缀，输出到控制台。前缀可从flume配置文件中配置。<br>整个架构大致如下图：</p><p><img src="/images/Flume自定义Source/8E64C481-2E59-4986-B367-98B5A0A28EA1.png" alt="flume"></p><hr><p>官方也提供了自定义<code>source</code>的接口:<br><a href="https://flume.apache.org/FlumeDeveloperGuide.html#source" target="_blank" rel="noopener">https://flume.apache.org/FlumeDeveloperGuide.html#source</a> 根据官方说明自定义<code>MySource</code>需要继承<code>AbstractSource</code>类并实现<code>Configurable</code>和<code>PollableSource</code>接口。</p><hr><hr><h3 id="二、-构建自定义Source代码"><a href="#二、-构建自定义Source代码" class="headerlink" title="二、 构建自定义Source代码"></a>二、 构建自定义Source代码</h3><h4 id="1-创建maven项目"><a href="#1-创建maven项目" class="headerlink" title="1.创建maven项目"></a>1.创建maven项目</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flume<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flume-ng-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="2-构建自定义类"><a href="#2-构建自定义类" class="headerlink" title="2. 构建自定义类"></a>2. 构建自定义类</h4><p>首先创建自定义类继承<code>AbstractSource</code>类并实现<code>Configurable</code>和<code>PollableSource</code>接口。<br>具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flume.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.Event;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.EventDeliveryException;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.PollableSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.conf.Configurable;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.event.SimpleEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.source.AbstractSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> suiwo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span> MySource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/2 13:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> //todo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> <span class="keyword">extends</span> <span class="title">AbstractSource</span> <span class="keyword">implements</span> <span class="title">Configurable</span>, <span class="title">PollableSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String subfix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        prefix = context.getString(<span class="string">"prefix"</span>);</span><br><span class="line">        subfix = context.getString(<span class="string">"sub"</span>,<span class="string">"noSubfix"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 接收数据（for循环造数据）</span></span><br><span class="line"><span class="comment">     * 2. 封装为时间</span></span><br><span class="line"><span class="comment">     * 3. 将时间传给Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> EventDeliveryException </span>&#123;</span><br><span class="line">        Status status = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 1. 接受数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 构建事件对象</span></span><br><span class="line">                SimpleEvent event = <span class="keyword">new</span> SimpleEvent();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 给事件设置值</span></span><br><span class="line">                event.setBody((prefix + <span class="string">"--"</span> + i + <span class="string">"--"</span> + subfix).getBytes());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4. 将时间传递给Channel</span></span><br><span class="line">                getChannelProcessor().processEvent(event);</span><br><span class="line"></span><br><span class="line">                status = Status.READY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            status = Status.BACKOFF;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getBackOffSleepIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxBackOffSleepInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="3-maven打包"><a href="#3-maven打包" class="headerlink" title="3. maven打包"></a>3. maven打包</h4><p>将项目打包，并将项目放至flume的lib目录下</p><hr><hr><h3 id="三、编写Flume相关配置"><a href="#三、编写Flume相关配置" class="headerlink" title="三、编写Flume相关配置"></a>三、编写Flume相关配置</h3><h4 id="1-编写my-source-conf"><a href="#1-编写my-source-conf" class="headerlink" title="1. 编写my-source.conf"></a>1. 编写my-source.conf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Name the components on this agent</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line">a1.sources.r1.type = xyz.suiwo.flume.source.MySource</span><br><span class="line">a1.sources.r1.prefix = suiwo</span><br><span class="line">a1.sources.r1.subfix = zaixian</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><hr><hr><h3 id="四、-启动测试"><a href="#四、-启动测试" class="headerlink" title="四、 启动测试"></a>四、 启动测试</h3><p>执行下面指令启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flume-ng agent -c conf -f job/my-source.conf -n a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure></p><blockquote><p>此时可以发现prefix参数获取成功，subfix因为配置文件中未配置，所以使用默认值</p></blockquote>]]></content>
    
    <summary type="html">
    
      Source是负责接收数据到Flume Agent的组件。Source组件可以处理各种类型、各种 格式的日志数据，包括 avro、thrift、exec、jms、spooling directory、netcat、sequence generator、syslog、http、legacy。官方提供的 source 类型已经很多，但是有时候并不能 满足实际开发当中的需求，此时我们就需要根据实际需求自定义某些 source。
    
    </summary>
    
      <category term="Flume" scheme="http://suiwo.xyz/categories/Flume/"/>
    
    
      <category term="Hadoop" scheme="http://suiwo.xyz/tags/Hadoop/"/>
    
      <category term="Flume" scheme="http://suiwo.xyz/tags/Flume/"/>
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Flume自定义Interceptor</title>
    <link href="http://suiwo.xyz/2020/05/31/Flume%E8%87%AA%E5%AE%9A%E4%B9%89Interceptor/"/>
    <id>http://suiwo.xyz/2020/05/31/Flume自定义Interceptor/</id>
    <published>2020-05-31T06:14:09.000Z</published>
    <updated>2023-01-07T16:01:43.101Z</updated>
    
    <content type="html"><![CDATA[<p>本文为尚硅谷Flume课程随堂笔记</p><hr><h3 id="一、-项目介绍"><a href="#一、-项目介绍" class="headerlink" title="一、 项目介绍"></a>一、 项目介绍</h3><p>在该案例中，我们以端口数据模拟日志，以是否存在“Hello”模拟不同类型的日志，我们需要自定义interceptor区分是否存在，将其分别发往不同的分析系统 (Channel)。<br>整个架构大致如下图：<br><img src="/images/Flume自定义Interceptor/C13A7432-8217-463A-BF50-7BD20C0F81BB.png" alt="Flume"></p><hr><hr><h3 id="二、-构建拦截器代码"><a href="#二、-构建拦截器代码" class="headerlink" title="二、 构建拦截器代码"></a>二、 构建拦截器代码</h3><h4 id="1-创建maven项目"><a href="#1-创建maven项目" class="headerlink" title="1.创建maven项目"></a>1.创建maven项目</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flume<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flume-ng-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="2-创建自定义拦截器"><a href="#2-创建自定义拦截器" class="headerlink" title="2.创建自定义拦截器"></a>2.创建自定义拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flume.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.Event;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.interceptor.Interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> suiwo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span> TypeInterceptor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/31 14:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> //todo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Event&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;Event&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个事件拦截</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">intercept</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取事件中的头信息</span></span><br><span class="line">        Map&lt;String, String&gt; headers = event.getHeaders();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取事件中的body信息</span></span><br><span class="line">        String body = <span class="keyword">new</span> String(event.getBody());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据body中是否有Hello来决定添加怎样的头信息</span></span><br><span class="line">        <span class="keyword">if</span> (body.contains(<span class="string">"Hello"</span>)) &#123;</span><br><span class="line">            <span class="comment">// channel选择器通过type字段中的值向指定的avro发送信息</span></span><br><span class="line">            headers.put(<span class="string">"type"</span>, <span class="string">"suiwo"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            headers.put(<span class="string">"type"</span>, <span class="string">"inc"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> event;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量事件拦截</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Event&gt; <span class="title">intercept</span><span class="params">(List&lt;Event&gt; list)</span> </span>&#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        <span class="keyword">for</span> (Event event : list) &#123;</span><br><span class="line">            result.add(intercept(event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Interceptor <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TypeInterceptor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-maven打包"><a href="#3-maven打包" class="headerlink" title="3. maven打包"></a>3. maven打包</h4><p>将项目打包，并将项目放至flume的lib目录下</p><hr><hr><h3 id="三、编写Flume相关配置"><a href="#三、编写Flume相关配置" class="headerlink" title="三、编写Flume相关配置"></a>三、编写Flume相关配置</h3><h4 id="1-编写flume1"><a href="#1-编写flume1" class="headerlink" title="1. 编写flume1"></a>1. 编写flume1</h4><p>编写flume1的配置文件<code>flume1.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># Name</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.channels = c1 c2</span><br><span class="line">a1.sinks = k1 k2</span><br><span class="line"></span><br><span class="line"># Source</span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = localhost</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line"></span><br><span class="line"># Channel</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line">a1.channels.c2.type = memory</span><br><span class="line">a1.channels.c2.capacity = 1000</span><br><span class="line">a1.channels.c2.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># Sink</span><br><span class="line">a1.sinks.k1.type = avro</span><br><span class="line">a1.sinks.k1.hostname = localhost</span><br><span class="line">a1.sinks.k1.port = 4141</span><br><span class="line">a1.sinks.k2.type= avro</span><br><span class="line">a1.sinks.k2.hostname = localhost</span><br><span class="line">a1.sinks.k2.port = 4142</span><br><span class="line"></span><br><span class="line"># Bind</span><br><span class="line">a1.sources.r1.channels = c1 c2</span><br><span class="line">a1.sinks.k1.channel = c1</span><br><span class="line">a1.sinks.k2.channel = c2</span><br><span class="line"></span><br><span class="line"># Channel Selector</span><br><span class="line">a1.sources.r1.selector.type = multiplexing</span><br><span class="line">a1.sources.r1.selector.header = type</span><br><span class="line">a1.sources.r1.selector.mapping.suiwo = c1</span><br><span class="line">a1.sources.r1.selector.mapping.inc = c2</span><br><span class="line"></span><br><span class="line"># Interceptor</span><br><span class="line">a1.sources.r1.interceptors = i1</span><br><span class="line"># 使用拦截器全类名，$符号后的为Builder内部类名</span><br><span class="line">a1.sources.r1.interceptors.i1.type = xyz.suiwo.flume.interceptor.TypeInterceptor$Builder</span><br></pre></td></tr></table></figure></p><hr><h4 id="2-编写flume2"><a href="#2-编写flume2" class="headerlink" title="2. 编写flume2"></a>2. 编写flume2</h4><p>书写flume2的配置文件<code>flume2.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a2.sources = r2</span><br><span class="line">a2.sinks = k2</span><br><span class="line">a2.channels = c2</span><br><span class="line">a2.sources.r2.type = avro</span><br><span class="line">a2.sources.r2.bind = localhost</span><br><span class="line">a2.sources.r2.port = 4141</span><br><span class="line">a2.sinks.k2.type = logger</span><br><span class="line">a2.channels.c2.type = memory</span><br><span class="line">a2.channels.c2.capacity = 1000</span><br><span class="line">a2.channels.c2.transactionCapacity = 100</span><br><span class="line">a2.sinks.k2.channel = c2</span><br><span class="line">a2.sources.r2.channels = c2</span><br></pre></td></tr></table></figure></p><hr><h4 id="3-编写flume3"><a href="#3-编写flume3" class="headerlink" title="3. 编写flume3"></a>3. 编写flume3</h4><p>书写flume3的配置文件<code>flume3.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a3.sources = r3</span><br><span class="line">a3.sinks = k3</span><br><span class="line">a3.channels = c3</span><br><span class="line">a3.sources.r3.type = avro</span><br><span class="line">a3.sources.r3.bind = localhost</span><br><span class="line">a3.sources.r3.port = 4142</span><br><span class="line">a3.sinks.k3.type = logger</span><br><span class="line">a3.channels.c3.type = memory</span><br><span class="line">a3.channels.c3.capacity = 1000</span><br><span class="line">a3.channels.c3.transactionCapacity = 100</span><br><span class="line">a3.sinks.k3.channel = c3</span><br><span class="line">a3.sources.r3.channels = c3</span><br></pre></td></tr></table></figure></p><hr><hr><h3 id="四、-启动测试"><a href="#四、-启动测试" class="headerlink" title="四、 启动测试"></a>四、 启动测试</h3><ol><li>先启动flume2以及flume3最后启动flume1。</li><li>使用<code>netcat</code>工具向<code>44444</code>端口发送消息。</li><li>经过测试发现，拦截功能已实现。</li></ol>]]></content>
    
    <summary type="html">
    
      在实际的开发中，一台服务器产生的日志类型可能有很多种，不同类型的日志可能需要 发送到不同的分析系统。此时会用到Flume拓扑结构中的Multiplexing结构，Multiplexing的原理是，根据event中Header的某个key的值，将不同的event发送到不同的Channel中，所以我们需要自定义一个 Interceptor，为不同类型的event的Header中的key赋予不同的值。
    
    </summary>
    
      <category term="Flume" scheme="http://suiwo.xyz/categories/Flume/"/>
    
    
      <category term="Hadoop" scheme="http://suiwo.xyz/tags/Hadoop/"/>
    
      <category term="Flume" scheme="http://suiwo.xyz/tags/Flume/"/>
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Flume初识</title>
    <link href="http://suiwo.xyz/2020/05/26/Flume%E5%88%9D%E8%AF%86/"/>
    <id>http://suiwo.xyz/2020/05/26/Flume初识/</id>
    <published>2020-05-26T03:54:21.000Z</published>
    <updated>2023-01-07T16:35:51.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是尚硅谷Flume课程随手笔记，记录课程的一些实战的操作步骤</p></blockquote><hr><h3 id="一、安装Flume并实现一个简易端口监控"><a href="#一、安装Flume并实现一个简易端口监控" class="headerlink" title="一、安装Flume并实现一个简易端口监控"></a>一、安装Flume并实现一个简易端口监控</h3><blockquote><p>实现监控端口案例，通过Flume来监听端口数据，并将数据打印到控制台</p></blockquote><hr><h4 id="1-首先进入官网下载Flume源码包"><a href="#1-首先进入官网下载Flume源码包" class="headerlink" title="1. 首先进入官网下载Flume源码包"></a>1. 首先进入官网下载Flume源码包</h4><hr><h4 id="2-修改flume-env-sh文件"><a href="#2-修改flume-env-sh文件" class="headerlink" title="2. 修改flume-env.sh文件"></a>2. 修改flume-env.sh文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_144</span><br></pre></td></tr></table></figure><hr><h4 id="3-添加配置文件"><a href="#3-添加配置文件" class="headerlink" title="3. 添加配置文件"></a>3. 添加配置文件</h4><p>创建Flume Agent配置文件<code>flume-netcat-logger.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># Name the components on this agent a1:表示agent的名称</span><br><span class="line"># r1:表示a1的Source的名称</span><br><span class="line">a1.sources = r1</span><br><span class="line"># k1:表示a1的Sink的名称</span><br><span class="line">a1.sinks = k1</span><br><span class="line"># c1:表示a1的Channel的名称</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line"># 表示a1的输入源类型为netcat端口类型</span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line"># 表示a1的监听的主机</span><br><span class="line">a1.sources.r1.bind = localhost</span><br><span class="line"># 表示a1的监听的端口号</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line"># 表示a1的输出目的地是控制台logger类型</span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line"># 表示a1的channel类型是memory内存型</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"># 表示a1的channel总容量1000个event</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line"># 表示a1的channel传输时收集到了100条event以后再去提交事务</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line"># 表示将r1和c1连接起来</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line"># 表示将k1和c1连接起来</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure></p><hr><h4 id="4-启动Flume"><a href="#4-启动Flume" class="headerlink" title="4. 启动Flume"></a>4. 启动Flume</h4><p>启动终端，在终端中属于下面的指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf/ --name a1 --conf-file job/flume-netcat-logger.conf -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure></p><p>使用下面的指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc localhost 44444</span><br></pre></td></tr></table></figure></p><p>通过netcat发送数据，发现此时flume日志中显示接收到数据</p><hr><hr><h3 id="二、-实时监控单个追加文件"><a href="#二、-实时监控单个追加文件" class="headerlink" title="二、 实时监控单个追加文件"></a>二、 实时监控单个追加文件</h3><blockquote><p>实时监控 Hive 日志，并上传到 HDFS 中</p></blockquote><hr><h4 id="1-添加配置文件"><a href="#1-添加配置文件" class="headerlink" title="1. 添加配置文件"></a>1. 添加配置文件</h4><p>创建本次程序的配置文件，创建 flume-file-logger.conf 文件，根据官网添加一下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Name the components on this agent a1:表示agent的名称</span><br><span class="line"># r1:表示a1的Source的名称</span><br><span class="line">a1.sources = r1</span><br><span class="line"># k1:表示a1的Sink的名称</span><br><span class="line">a1.sinks = k1</span><br><span class="line"># c1:表示a1的Channel的名称</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line"># 表示a1的输入源类型为exec source类型</span><br><span class="line">a1.sources.r1.type = exec</span><br><span class="line"># 监控文件</span><br><span class="line">a1.sources.r1.command = tail -F /Users/user/Library/Hive/logs/hive.log</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line"># 表示a1的输出目的地是控制台logger类型</span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line"># 表示a1的channel类型是memory内存型</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"># 表示a1的channel总容量1000个event</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line"># 表示a1的channel传输时收集到了100条event以后再去提交事务</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line"># 表示将r1和c1连接起来</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line"># 表示将k1和c1连接起来</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure></p><hr><h4 id="2-启动Flume"><a href="#2-启动Flume" class="headerlink" title="2. 启动Flume"></a>2. 启动Flume</h4><p>在终端中输入下面的指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf --conf-file job/file-flume-logger.conf --name a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure></p><p>之后启动该任务，并且可以监听hive的日志文件</p><hr><hr><h3 id="三、-实时监控单个追加文件到HDFS"><a href="#三、-实时监控单个追加文件到HDFS" class="headerlink" title="三、 实时监控单个追加文件到HDFS"></a>三、 实时监控单个追加文件到HDFS</h3><blockquote><p>Flume监控Hive实时更新日志然后上传到HDFS</p></blockquote><hr><h4 id="1-添加相关依赖包"><a href="#1-添加相关依赖包" class="headerlink" title="1. 添加相关依赖包"></a>1. 添加相关依赖包</h4><p>首先将需要使用的相关Jar包放入Flume的lib目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">commons-configuration-1.6.jar、</span><br><span class="line">hadoop-auth-2.7.2.jar、</span><br><span class="line">hadoop-common-2.7.2.jar、</span><br><span class="line">hadoop-hdfs-2.7.2.jar、</span><br><span class="line">commons-io-2.4.jar、</span><br><span class="line">htrace-core-3.1.0-incubating.jar</span><br></pre></td></tr></table></figure></p><hr><h4 id="2-添加配置文件"><a href="#2-添加配置文件" class="headerlink" title="2.添加配置文件"></a>2.添加配置文件</h4><p>创建本次程序的配置文件，创建 flume-file-hdfs.conf 文件，根据官网添加一下配置，因为这里与上一节区别主要在sink部分，所以只需要在上一节配置的基础上对sink相关的部分进行修改即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"># Name the components on this agent a1:表示agent的名称</span><br><span class="line"># r1:表示a1的Source的名称</span><br><span class="line">a1.sources = r1</span><br><span class="line"># k1:表示a1的Sink的名称</span><br><span class="line">a1.sinks = k1</span><br><span class="line"># c1:表示a1的Channel的名称</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line"># 表示a1的输入源类型为exec source类型</span><br><span class="line">a1.sources.r1.type = exec</span><br><span class="line"># 监控文件</span><br><span class="line">a1.sources.r1.command = tail -F /Users/user/Library/Hive/logs/hive.log</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line"></span><br><span class="line"># 表示a1的输出目的地是控制台logger类型</span><br><span class="line">a1.sinks.k1.type = hdfs</span><br><span class="line">a1.sinks.k1.hdfs.path = hdfs://localhost:9000/flume/%Y%m%d/%H</span><br><span class="line"># 上传文件的前缀</span><br><span class="line">a1.sinks.k1.hdfs.filePrefix = logs- </span><br><span class="line"># 是否按照时间滚动文件夹</span><br><span class="line">a1.sinks.k1.hdfs.round = true </span><br><span class="line"># 多少时间单位创建一个新的文件夹</span><br><span class="line">a1.sinks.k1.hdfs.roundValue = 1</span><br><span class="line"># 重新定义时间单位</span><br><span class="line">a1.sinks.k1.hdfs.roundUnit = hour</span><br><span class="line"># 是否使用本地时间戳</span><br><span class="line">a1.sinks.k1.hdfs.useLocalTimeStamp = true</span><br><span class="line"># 积攒多少个 Event 才 flush 到 HDFS 一次</span><br><span class="line">a1.sinks.k1.hdfs.batchSize = 1000</span><br><span class="line"># 设置文件类型，可支持压缩</span><br><span class="line">a1.sinks.k1.hdfs.fileType = DataStream</span><br><span class="line"># 多久生成一个新的文件</span><br><span class="line">a1.sinks.k1.hdfs.rollInterval = 30</span><br><span class="line"># 设置每个文件的滚动大小</span><br><span class="line">a1.sinks.k1.hdfs.rollSize = 134217700</span><br><span class="line"># 文件的滚动与 Event 数量无关</span><br><span class="line">a1.sinks.k1.hdfs.rollCount = 0</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line"># 表示a1的channel类型是memory内存型</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"># 表示a1的channel总容量1000个event</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line"># 表示a1的channel传输时收集到了100条event以后再去提交事务</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line"># 表示将r1和c1连接起来</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line"># 表示将k1和c1连接起来</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure></p><hr><h4 id="3-启动Flume"><a href="#3-启动Flume" class="headerlink" title="3. 启动Flume"></a>3. 启动Flume</h4><p>在终端中输入下面的指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf --conf-file job/file-file-hdfs.conf --name a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure></p><p>之后启动该任务，并且可以监听文件的追加</p><hr><hr><h3 id="四、-实时监控目录下的多个新文件至HDFS"><a href="#四、-实时监控目录下的多个新文件至HDFS" class="headerlink" title="四、 实时监控目录下的多个新文件至HDFS"></a>四、 实时监控目录下的多个新文件至HDFS</h3><blockquote><p>当监控的目录下有新文件时，进行上传</p></blockquote><hr><h4 id="1-添加配置文件-1"><a href="#1-添加配置文件-1" class="headerlink" title="1. 添加配置文件"></a>1. 添加配置文件</h4><p>写下如下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># Name the components on this agent a1:表示agent的名称</span><br><span class="line"># r1:表示a1的Source的名称</span><br><span class="line">a1.sources = r1</span><br><span class="line"># k1:表示a1的Sink的名称</span><br><span class="line">a1.sinks = k1</span><br><span class="line"># c1:表示a1的Channel的名称</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line"># 表示a1的输入源类型为spooldir类型</span><br><span class="line">a1.sources.r1.type = spooldir</span><br><span class="line"># 监控文件的路径</span><br><span class="line">a1.sources.r1.spoolDir = /Users/user/Library/Flume/upload</span><br><span class="line"># 上传完成文件后缀</span><br><span class="line">a1.sources.r1.fileSuffix = .COMPLETED</span><br><span class="line"># 忽略所有以.tmp 结尾的文件，不上传</span><br><span class="line">a1.sources.r1.ignorePattern = ([^ ]*\.tmp)</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line"></span><br><span class="line"># 表示a1的输出目的地是控制台hdfs类型</span><br><span class="line">a1.sinks.k1.type = hdfs</span><br><span class="line">a1.sinks.k1.hdfs.path = hdfs://localhost:9000/flume/%Y%m%d/%H</span><br><span class="line"># 上传文件的前缀</span><br><span class="line">a1.sinks.k1.hdfs.filePrefix = upload- </span><br><span class="line"># 是否按照时间滚动文件夹</span><br><span class="line">a1.sinks.k1.hdfs.round = true </span><br><span class="line"># 多少时间单位创建一个新的文件夹</span><br><span class="line">a1.sinks.k1.hdfs.roundValue = 1</span><br><span class="line"># 重新定义时间单位</span><br><span class="line">a1.sinks.k1.hdfs.roundUnit = hour</span><br><span class="line"># 是否使用本地时间戳</span><br><span class="line">a1.sinks.k1.hdfs.useLocalTimeStamp = true</span><br><span class="line"># 积攒多少个 Event 才 flush 到 HDFS 一次</span><br><span class="line">a1.sinks.k1.hdfs.batchSize = 1000</span><br><span class="line"># 设置文件类型，可支持压缩</span><br><span class="line">a1.sinks.k1.hdfs.fileType = DataStream</span><br><span class="line"># 多久生成一个新的文件</span><br><span class="line">a1.sinks.k1.hdfs.rollInterval = 30</span><br><span class="line"># 设置每个文件的滚动大小</span><br><span class="line">a1.sinks.k1.hdfs.rollSize = 134217700</span><br><span class="line"># 文件的滚动与 Event 数量无关</span><br><span class="line">a1.sinks.k1.hdfs.rollCount = 0</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line"># 表示a1的channel类型是memory内存型</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"># 表示a1的channel总容量1000个event</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line"># 表示a1的channel传输时收集到了100条event以后再去提交事务</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line"># 表示将r1和c1连接起来</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line"># 表示将k1和c1连接起来</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure></p><hr><h4 id="2-启动Flume-1"><a href="#2-启动Flume-1" class="headerlink" title="2. 启动Flume"></a>2. 启动Flume</h4><p>在终端中输入下面的指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf --conf-file job/file-dir-hdfs.conf --name a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure></p><p>之后我们向upload文件夹添加文件，发现成功上传至HDFS。</p><blockquote><p>注： 但是它并不能监控动态变化的数据，在使用 Spooling Directory Source 时，不要在监控目录中创建并持续修改文件，上传完成的文件会以.COMPLETED 结尾，被监控文件夹每 500 毫秒扫描一次文件变动。</p></blockquote><hr><hr><h3 id="五、-实时监控目录下的多个追加文件"><a href="#五、-实时监控目录下的多个追加文件" class="headerlink" title="五、 实时监控目录下的多个追加文件"></a>五、 实时监控目录下的多个追加文件</h3><blockquote><p>Exec source 适用于监控一个实时追加的文件，但不能保证数据不丢失;Spooldir Source 能够保证数据不丢失，且能够实现断点续传，但延迟较高，不能实时监控;而 Taildir Source 既能够实现断点续传，又可以保证数据不丢失，还能够进行实时监控。</p></blockquote><hr><h4 id="1-添加配置文件-2"><a href="#1-添加配置文件-2" class="headerlink" title="1. 添加配置文件"></a>1. 添加配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># Name the components on this agent a1:表示agent的名称</span><br><span class="line"># r1:表示a1的Source的名称</span><br><span class="line">a1.sources = r1</span><br><span class="line"># k1:表示a1的Sink的名称</span><br><span class="line">a1.sinks = k1</span><br><span class="line"># c1:表示a1的Channel的名称</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line">#表示a1的输入源类型为TAILDIR类型</span><br><span class="line">a1.sources.r1.type = TAILDIR</span><br><span class="line"># 指定position_file位置</span><br><span class="line">a1.sources.r1.positionFile = /Users/user/Library/Flume/upload/tail_dir.json</span><br><span class="line"># 文件组</span><br><span class="line">a1.sources.r1.filegroups = f1 f2</span><br><span class="line"># f1文件组</span><br><span class="line">a1.sources.r1.filegroups.f1 = /Users/user/Library/Flume/upload/dict1/a.log</span><br><span class="line"># f2文件组</span><br><span class="line">a1.sources.r1.filegroups.f2 = /Users/user/Library/Flume/upload/dict2/.*.txt</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line"></span><br><span class="line"># 表示a1的输出目的地是控制台logger类型</span><br><span class="line">a1.sinks.k1.type = hdfs</span><br><span class="line">a1.sinks.k1.hdfs.path = hdfs://localhost:9000/flume/%Y%m%d/%H</span><br><span class="line"># 上传文件的前缀</span><br><span class="line">a1.sinks.k1.hdfs.filePrefix = upload- </span><br><span class="line"># 是否按照时间滚动文件夹</span><br><span class="line">a1.sinks.k1.hdfs.round = true </span><br><span class="line"># 多少时间单位创建一个新的文件夹</span><br><span class="line">a1.sinks.k1.hdfs.roundValue = 1</span><br><span class="line"># 重新定义时间单位</span><br><span class="line">a1.sinks.k1.hdfs.roundUnit = hour</span><br><span class="line"># 是否使用本地时间戳</span><br><span class="line">a1.sinks.k1.hdfs.useLocalTimeStamp = true</span><br><span class="line"># 积攒多少个 Event 才 flush 到 HDFS 一次</span><br><span class="line">a1.sinks.k1.hdfs.batchSize = 1000</span><br><span class="line"># 设置文件类型，可支持压缩</span><br><span class="line">a1.sinks.k1.hdfs.fileType = DataStream</span><br><span class="line"># 多久生成一个新的文件</span><br><span class="line">a1.sinks.k1.hdfs.rollInterval = 30</span><br><span class="line"># 设置每个文件的滚动大小</span><br><span class="line">a1.sinks.k1.hdfs.rollSize = 134217700</span><br><span class="line"># 文件的滚动与 Event 数量无关</span><br><span class="line">a1.sinks.k1.hdfs.rollCount = 0</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line"># 表示a1的channel类型是memory内存型</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"># 表示a1的channel总容量1000个event</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line"># 表示a1的channel传输时收集到了100条event以后再去提交事务</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line"># 表示将r1和c1连接起来</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line"># 表示将k1和c1连接起来</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><hr><h4 id="2-启动Flume-2"><a href="#2-启动Flume-2" class="headerlink" title="2. 启动Flume"></a>2. 启动Flume</h4><p>在终端中输入下面的指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flume-ng agent --conf conf --conf-file job/file-taildir-hdfs.conf --name a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure></p><p>之后我们对监控的文件组中的文件进行追加，发现成功监听。</p><blockquote><p>注： 在查看tail_dir.json中可以发现监听记录，同时每条记录都存在inode字段和pos字段，inode字段为文件唯一标识符，不随文件名称的变化而变化，pos则是上传文件的偏移量，正是通过这个来实现断点续传。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。
    
    </summary>
    
      <category term="Flume" scheme="http://suiwo.xyz/categories/Flume/"/>
    
    
      <category term="Hadoop" scheme="http://suiwo.xyz/tags/Hadoop/"/>
    
      <category term="Flume" scheme="http://suiwo.xyz/tags/Flume/"/>
    
      <category term="大数据" scheme="http://suiwo.xyz/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
</feed>
