<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.ico?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.ico?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="本文是对Java NIO一书中缓冲区这一章节的总结，并将相关源码进行了注释和解读。">
<meta name="keywords" content="Java,NIO">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-NIO-缓冲区相关概念及源码梳理">
<meta property="og:url" content="http://suiwo.xyz/2023/01/07/Java-NIO-缓冲区相关概念及源码梳理/index.html">
<meta property="og:site_name" content="随我的博客">
<meta property="og:description" content="本文是对Java NIO一书中缓冲区这一章节的总结，并将相关源码进行了注释和解读。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-缓冲区相关概念及源码梳理/B207A94E-08FF-45E5-B883-DA7AD86D4D86_4_5005_c.jpeg">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-缓冲区相关概念及源码梳理/CC579E9E-23DC-466E-83E2-E051FE3E5AF4_4_5005_c.jpeg">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-缓冲区相关概念及源码梳理/5FC42548-560C-4B9F-AD13-52F850F724F1_4_5005_c.jpeg">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-缓冲区相关概念及源码梳理/F821CD63-1ED7-473E-AEBA-F1F8D80073D2_4_5005_c.jpeg">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-缓冲区相关概念及源码梳理/604B430D-5619-401D-B352-8125DA7F290C_4_5005_c.jpeg">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-缓冲区相关概念及源码梳理/BE251E19-10DB-4FC9-9532-ED0D564C6796_4_5005_c.jpeg">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-缓冲区相关概念及源码梳理/E9421FD9-DA4B-4E4E-83E1-DABC5017BB6C_4_5005_c.jpeg">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-缓冲区相关概念及源码梳理/370474B0-530E-48AF-B7D3-3AB0235AB516_4_5005_c.jpeg">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-缓冲区相关概念及源码梳理/BD8A5C19-D9A9-4440-B63B-861E9C01091E_4_5005_c.jpeg">
<meta property="og:updated_time" content="2023-01-07T15:41:41.343Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java-NIO-缓冲区相关概念及源码梳理">
<meta name="twitter:description" content="本文是对Java NIO一书中缓冲区这一章节的总结，并将相关源码进行了注释和解读。">
<meta name="twitter:image" content="http://suiwo.xyz/images/Java-NIO-缓冲区相关概念及源码梳理/B207A94E-08FF-45E5-B883-DA7AD86D4D86_4_5005_c.jpeg">
  <link rel="alternate" href="/atom.xml" title="随我的博客" type="application/atom+xml">
  <link rel="canonical" href="http://suiwo.xyz/2023/01/07/Java-NIO-缓冲区相关概念及源码梳理/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java-NIO-缓冲区相关概念及源码梳理 | 随我的博客</title>
  <meta name="generator" content="Hexo 3.7.1">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/ZhangJia97" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">随我的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">记录学习的点滴</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://suiwo.xyz/2023/01/07/Java-NIO-缓冲区相关概念及源码梳理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="随我">
      <meta itemprop="description" content="用心做自己喜欢的事">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随我的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Java-NIO-缓冲区相关概念及源码梳理

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2023-01-07 20:57:09" itemprop="dateCreated datePublished" datetime="2023-01-07T20:57:09+08:00">2023-01-07</time>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <div class="post-description">本文是对Java NIO一书中缓冲区这一章节的总结，并将相关源码进行了注释和解读。</div>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、缓冲区基础"><a href="#一、缓冲区基础" class="headerlink" title="一、缓冲区基础"></a>一、缓冲区基础</h2><h3 id="1-常见概念"><a href="#1-常见概念" class="headerlink" title="1. 常见概念"></a>1. 常见概念</h3><ol>
<li><p>容量(Capacity)<br>缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能被改变。</p>
</li>
<li><p>上界(Limit)<br>缓冲区的第-一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。</p>
</li>
<li><p>位置(Position)<br>下一个要被读或写的元素的索引。位置会自动由相应的get()和put()函数更新。</p>
</li>
<li><p>标记(Mark)<br>一个备忘位置。调用mark()来设定mark = postion。 调用reset()设定position = mark。标记在设定前是未定义的(undefined)。</p>
</li>
</ol>
<p>这四个属性之间总是遵循以下关系:0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p>
<h3 id="2-Buffer类常见API"><a href="#2-Buffer类常见API" class="headerlink" title="2. Buffer类常见API"></a>2. Buffer类常见API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.nio;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span> <span class="params">(<span class="keyword">int</span> newPosition)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span> <span class="params">(<span class="keyword">int</span> newLimit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">( )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见常见的例如clear() 函数返回不是void而是返回this，也就是对象本身的引用。这种设计就允许级联调用的类设计方法。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark( );</span><br><span class="line">buffer.position(<span class="number">5</span>);</span><br><span class="line">buffer.reset( );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写为:</span></span><br><span class="line">buffer.mark().position(<span class="number">5</span>).reset( );</span><br></pre></td></tr></table></figure>
<h3 id="3-存取"><a href="#3-存取" class="headerlink" title="3. 存取"></a>3. 存取</h3><p>为什么Buffer对象中没有定义get以及put函数？</p>
<blockquote>
<p>Buffer API并没有包括get()或put()函数。每一个Buffer类都有这两个函数，但它们所采用的参数类型，以及它们返回的数据类型，对每个子类来说都是唯一的，所以它们不能在顶层 Buffer 类中被抽象地声明。它们的定义必须被特定类型的子类所遵从。</p>
</blockquote>
<p>执行get和put的注意事项</p>
<blockquote>
<p>对于put()，如果运算会导致位置超出上界，就会抛出BufferOverflowException异常。对于get()，如果位置不小于上界，就会抛出BufferUnderflowException异常。绝对存取不会影响缓冲区的位置属性，但是如果您所提供的索引超出范围(负数或不小于上界)，也将抛出IndexOutOfBoundsException异常。</p>
</blockquote>
<h3 id="4-写入"><a href="#4-写入" class="headerlink" title="4. 写入"></a>4. 写入</h3><p>写入到具体位置可以使用<code>buffer.put(0,(byte)&#39;M&#39;)</code>这种方式接入。而<code>buffer.put((byte)&#39;w&#39;)</code>方法不会收到影响，他总是在最后一个位置上写入数据。</p>
<h3 id="5-翻转"><a href="#5-翻转" class="headerlink" title="5. 翻转"></a>5. 翻转</h3><p>对于翻转我们可以使用<code>buffer.limit(buffer.position()).position(0);</code>来进行翻转，<br>他执行的逻辑就是先将buffer的上界设置为当前buffer的容量，同时将标记重置。然后将当前读/写的位置重置为起始位置。</p>
<p>其中<code>buffer.limit(int)</code>方法代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Sets this buffer's limit.  If the position is larger than the new limit</span></span><br><span class="line"><span class="comment">  * then it is set to the new limit.  If the mark is defined and larger than</span></span><br><span class="line"><span class="comment">  * the new limit then it is discarded.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  newLimit</span></span><br><span class="line"><span class="comment">  *         The new limit value; must be non-negative</span></span><br><span class="line"><span class="comment">  *         and no larger than this buffer's capacity</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">  *          If the preconditions on &lt;tt&gt;newLimit&lt;/tt&gt; do not hold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    limit = newLimit;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>buffer.position()</code>代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns this buffer's position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The position of this buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>buffer.position(int)</code>代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets this buffer's position.  If the mark is defined and larger than the</span></span><br><span class="line"><span class="comment"> * new position then it is discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  newPosition</span></span><br><span class="line"><span class="comment"> *         The new position value; must be non-negative</span></span><br><span class="line"><span class="comment"> *         and no larger than the current limit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          If the preconditions on &lt;tt&gt;newPosition&lt;/tt&gt; do not hold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    position = newPosition;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于这种翻转需求十分常见，所以Buffer类为我们提供了一个便利的翻转函数<code>Buffer.flip()</code><br>代码如下。将上界设置为当前读/写位置，读/写位置置0，标志位重置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flips this buffer.  The limit is set to the current position and then</span></span><br><span class="line"><span class="comment"> * the position is set to zero.  If the mark is defined then it is</span></span><br><span class="line"><span class="comment"> * discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke</span></span><br><span class="line"><span class="comment"> * this method to prepare for a sequence of channel-write or relative</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;get&lt;/i&gt; operations.  For example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * buf.put(magic);    // Prepend header</span></span><br><span class="line"><span class="comment"> * in.read(buf);      // Read data into rest of buffer</span></span><br><span class="line"><span class="comment"> * buf.flip();        // Flip buffer</span></span><br><span class="line"><span class="comment"> * out.write(buf);    // Write header + data to channel&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method is often used in conjunction with the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.nio.ByteBuffer#compact compact&#125; method when transferring data from</span></span><br><span class="line"><span class="comment"> * one place to another.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了翻转函数flip()，还有一个常用函数，用来初始化读/写位置<code>Buffer.rewind()</code><br>代码如下，他将当前读/写位置置0，将标记位重置。通过rewind()我们可以对已经读过得缓冲区数据进行重读<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rewinds this buffer.  The position is set to zero and the mark is</span></span><br><span class="line"><span class="comment"> * discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Invoke this method before a sequence of channel-write or &lt;i&gt;get&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * operations, assuming that the limit has already been set</span></span><br><span class="line"><span class="comment"> * appropriately.  For example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * out.write(buf);    // Write remaining data</span></span><br><span class="line"><span class="comment"> * buf.rewind();      // Rewind buffer</span></span><br><span class="line"><span class="comment"> * buf.get(array);    // Copy data into array&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-释放"><a href="#6-释放" class="headerlink" title="6. 释放"></a>6. 释放</h3><p>当我们接收到一个已经被填满的缓冲区的时候，我们可以通过通道的read()操作完成，当然我们需要在调用get()前对这个缓冲区进行翻转之后。<br>我们可以根据<code>hasRemaining()</code>方法来判断当前位置是否超出缓冲区的上界。我们可以通过下面这种方式来轮询获取缓冲区中的数据(在后续中，我们将学到进行批量传输的更高效的方法)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; buffer.hasRemaining(), i++) &#123;</span><br><span class="line">    myByteArray[i] = buffer.get(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>作为选择，<code>remaining()</code>函数将告知您从当前位置到上界还剩余的元素数目。您也可以通过下面的循环来释放缓冲区。<br>使用下面的好处就是不需要在每次循环的时候都进行重复检查。但是坏处就是这个无法在多线程的情况下同时从缓冲区中获取数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = buffer.remaining( );</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count, i++) &#123;</span><br><span class="line">    myByteArray[i] = buffer.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述两个函数的代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of elements between the current position and the</span></span><br><span class="line"><span class="comment"> * limit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The number of elements remaining in this buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> limit - position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tells whether there are any elements between the current position and</span></span><br><span class="line"><span class="comment"> * the limit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &lt;tt&gt;true&lt;/tt&gt; if, and only if, there is at least one element</span></span><br><span class="line"><span class="comment"> *          remaining in this buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在缓冲区中的对象完成读取释放后，他又可以进行重新使用。我们可以调用clear()函数将缓冲区重置为空的状态。<br>当然这个所谓的重置并不是真的将缓冲区中的数据进行删除，而是将数据的上界设置为容量值，同时将位置置0。<br>实际代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clears this buffer.  The position is set to zero, the limit is set to</span></span><br><span class="line"><span class="comment"> * the capacity, and the mark is discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Invoke this method before using a sequence of channel-read or</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;put&lt;/i&gt; operations to fill this buffer.  For example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * buf.clear();     // Prepare buffer for reading</span></span><br><span class="line"><span class="comment"> * in.read(buf);    // Read data&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method does not actually erase the data in the buffer, but it</span></span><br><span class="line"><span class="comment"> * is named as if it did because it will most often be used in situations</span></span><br><span class="line"><span class="comment"> * in which that might as well be the case. &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一段实例代码，演示如果写入以及释放缓冲区<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferFillDrain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] strings = &#123;</span><br><span class="line">            <span class="string">"A random string value"</span>,</span><br><span class="line">            <span class="string">"The product of an infinite number of monkeys"</span>,</span><br><span class="line">            <span class="string">"Hey hey we're the Monkees"</span>,</span><br><span class="line">            <span class="string">"Opening act for the Monkees: Jimi Hendrix"</span>,</span><br><span class="line">            <span class="string">"'Scuse me while I kiss this fly"</span>,</span><br><span class="line">            <span class="string">"Help Me! Help Me!"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CharBuffer buffer = CharBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">while</span> (fillBuffer(buffer)) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            drainBuffer(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drainBuffer</span><span class="params">(CharBuffer charBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (charBuffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.print(charBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">fillBuffer</span><span class="params">(CharBuffer charBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= strings.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String string = strings[index++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string.length(); i++) &#123;</span><br><span class="line">            charBuffer.put(string.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-压缩"><a href="#7-压缩" class="headerlink" title="7. 压缩"></a>7. 压缩</h3><p>当我们希望释放缓冲区的部分数据，然后保留剩余的数据继续进行填充。为了实现这一点，我们需要将未读的数据进行迁移，使未读的第一个数据索引为0。对此，Buffer类为我们提供了<code>compact()</code>函数来实现这一功能，尽管重复这样做会效率低下，但是相较于我们自己进行<code>get()</code>和<code>put()</code>函数来说，使用提供的<code>compact()</code>会高效得多。所以当需要的时候，建议使用<code>compact()</code>。</p>
<p>执行compact前<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/B207A94E-08FF-45E5-B883-DA7AD86D4D86_4_5005_c.jpeg" alt="img"></p>
<p>执行compact后<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/CC579E9E-23DC-466E-83E2-E051FE3E5AF4_4_5005_c.jpeg" alt="img"></p>
<p>我们可以发现执行方法会</p>
<ol>
<li>将2-5的元素复制到0-3的位置上，同时4-5不会有变动。</li>
<li>将postition移到4的位置也就是说，缓冲区现在被定位在缓冲区中最后一个“存活”元素后插入数据的位置。</li>
<li>将缓冲区的上界改为缓冲区的容量大小。</li>
</ol>
<p>下面我们已经<code>HeapByteBuffer</code>类举例，看看如果实现一个<code>compact()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 使用数组拷贝将未读数据拷贝</span></span><br><span class="line">    System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">    <span class="comment">// 2. 将缓冲区的位置放到缓冲区存活的数据后的数据的位置，也就是`limit - position`</span></span><br><span class="line">    <span class="comment">// remaining() 返回的值为limit - position</span></span><br><span class="line">    position(remaining());</span><br><span class="line">    <span class="comment">// 3. 将上界大小设置为缓冲区的容量大小</span></span><br><span class="line">    limit(capacity());</span><br><span class="line">    <span class="comment">// 重置mark为-1</span></span><br><span class="line">    discardMark();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="8-标记"><a href="#8-标记" class="headerlink" title="8. 标记"></a>8. 标记</h3><p>标记的作用是使缓冲区能够记住一个位置并在之后将其返回。<br>缓冲区的标记在调用mark()函数之前是未定义的。调用后会将当前位置赋值给标记。<br>函数代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets this buffer's mark at its position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而reset()方法则会将当前位置移动到标记值的位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resets this buffer's position to the previously-marked position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Invoking this method neither changes nor discards the mark's</span></span><br><span class="line"><span class="comment"> * value. &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InvalidMarkException</span></span><br><span class="line"><span class="comment"> *          If the mark has not been set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此处定义临时变量个人认为主要目的是防止多个线程同时执行时导致的异常</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 如果不用一个局部变量m存储，那就会存在以下这种可能性</span></span><br><span class="line"><span class="comment">     * 1. A线程判断 mark&gt;=0，参数合法</span></span><br><span class="line"><span class="comment">     * 2. B线程执行了类似于rewind()，clear()，flip()等可以将mark重置为-1的方法</span></span><br><span class="line"><span class="comment">     * 3. A线程将mark赋值给position</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 但是如果使用了局部变量m就可以避免由于多个线程修改导致的问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果新设定的值比当前的标记小，调用<code>limit(int)</code>或<code>position(int)</code>带有索引参数的版本会抛弃标记。<br>从代码中可以看到这两个函数在执行的时候都会对remark进行判断，如果不合法则置为-1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets this buffer's position.  If the mark is defined and larger than the</span></span><br><span class="line"><span class="comment"> * new position then it is discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  newPosition</span></span><br><span class="line"><span class="comment"> *         The new position value; must be non-negative</span></span><br><span class="line"><span class="comment"> *         and no larger than the current limit</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          If the preconditions on &lt;tt&gt;newPosition&lt;/tt&gt; do not hold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    position = newPosition;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets this buffer's limit.  If the position is larger than the new limit</span></span><br><span class="line"><span class="comment"> * then it is set to the new limit.  If the mark is defined and larger than</span></span><br><span class="line"><span class="comment"> * the new limit then it is discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  newLimit</span></span><br><span class="line"><span class="comment"> *         The new limit value; must be non-negative</span></span><br><span class="line"><span class="comment"> *         and no larger than this buffer's capacity</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          If the preconditions on &lt;tt&gt;newLimit&lt;/tt&gt; do not hold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    limit = newLimit;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设我们执行下面这个函数，他会做什么操作？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.position(<span class="number">2</span>).mark().position(<span class="number">4</span>);</span><br></pre></td></tr></table></figure></p>
<ol>
<li>将缓冲区的位置置为2</li>
<li>将缓冲区的标记赋值为位置的值2</li>
<li>将缓冲区的位置置为4</li>
</ol>
<p>最终结果如下图<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/5FC42548-560C-4B9F-AD13-52F850F724F1_4_5005_c.jpeg" alt="img"></p>
<h3 id="9-比较"><a href="#9-比较" class="headerlink" title="9. 比较"></a>9. 比较</h3><p>以<code>ByteBuffer</code>类为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>他继承了Comparable接口，我们可以通过实现Comparable接口的compareTo()方法来实现两个Buffer的对比。<br>如果每个缓冲区中剩余的内容相同，那么equals()函数将返回true，否则返回false。因为这个测试是用于严格的相等而且是可换向的。前面的程序清单中的缓冲区名称可以颠倒，并会产生相同的结果。<br>与equals()相似，compareTo()不允许不同对象间进行比较。但compareTo()更为严格:如果您传递一个类型错误的对象，它会抛出ClassCastException异常，但equals()只会返回 false。<br>两个缓冲区被认为相等的充要条件是:</p>
<ul>
<li>两个对象类型相同。包含不同数据类型的buffer永远不会相等，而且buffer绝不会等于非buffer对象。</li>
<li>两个对象都剩余同样数量的元素。Buffer的容量不需要相同，而且缓冲区中剩余数据的索引也不必相同。但每个缓冲区中剩余元素的数目(也就是从位置到上界的元素数量)必须相同。</li>
<li>在每个缓冲区中应被Get()函数返回的剩余数据元素序列必须一致。<br>如果不满足以上任意条件，就会返回false。</li>
</ul>
<p>两个被认为是相等的缓冲区<br>可以看到在position到limit中的数据时一致的（limit位是还未存储的数据位）所以我们可以认为这两个Buffer相同。<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/F821CD63-1ED7-473E-AEBA-F1F8D80073D2_4_5005_c.jpeg" alt="img"></p>
<p>两个被认为不相等的缓冲区<br>虽然缓冲区中所存的数据是完全一致的，但是由于position到limit中的数据不一致，所以两个缓冲区不相等。<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/604B430D-5619-401D-B352-8125DA7F290C_4_5005_c.jpeg" alt="img"></p>
<h3 id="10-批量移动"><a href="#10-批量移动" class="headerlink" title="10. 批量移动"></a>10. 批量移动</h3><p>为了高效传输数据，Buffer类中提供了许多向缓冲区内外批量移动元素的函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">// This is a partial API listing</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span> <span class="params">(<span class="keyword">char</span> [] dst)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">public</span> ByteBuffer <span class="title">get</span> <span class="params">(<span class="keyword">char</span> [] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">char</span>[] src)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">public</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">char</span> [] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">public</span> ByteBuffer <span class="title">put</span> <span class="params">(ByteBuffer src)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>第一种形式的<code>get(char[] dst)</code>只是将缓冲区中的数据复制到传入的数组中。<br>代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Relative bulk &lt;i&gt;get&lt;/i&gt; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method transfers bytes from this buffer into the given</span></span><br><span class="line"><span class="comment"> * destination array.  An invocation of this method of the form</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;src.get(a)&lt;/tt&gt; behaves in exactly the same way as the invocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     src.get(a, 0, a.length) &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   dst</span></span><br><span class="line"><span class="comment"> *          The destination array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  BufferUnderflowException</span></span><br><span class="line"><span class="comment"> *          If there are fewer than &lt;tt&gt;length&lt;/tt&gt; bytes</span></span><br><span class="line"><span class="comment"> *          remaining in this buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 底层实际的调用方法就是第二种get函数</span></span><br><span class="line">    <span class="keyword">return</span> get(dst, <span class="number">0</span>, dst.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种形式<code>get (char [] dst, int offset, int length)</code>使用offset和length参数来指定目标数组的子区间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Relative bulk &lt;i&gt;get&lt;/i&gt; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method transfers bytes from this buffer into the given</span></span><br><span class="line"><span class="comment"> * destination array.  If there are fewer bytes remaining in the</span></span><br><span class="line"><span class="comment"> * buffer than are required to satisfy the request, that is, if</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;length&lt;/tt&gt;&amp;nbsp;&lt;tt&gt;&amp;gt;&lt;/tt&gt;&amp;nbsp;&lt;tt&gt;remaining()&lt;/tt&gt;, then no</span></span><br><span class="line"><span class="comment"> * bytes are transferred and a &#123;<span class="doctag">@link</span> BufferUnderflowException&#125; is</span></span><br><span class="line"><span class="comment"> * thrown.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Otherwise, this method copies &lt;tt&gt;length&lt;/tt&gt; bytes from this</span></span><br><span class="line"><span class="comment"> * buffer into the given array, starting at the current position of this</span></span><br><span class="line"><span class="comment"> * buffer and at the given offset in the array.  The position of this</span></span><br><span class="line"><span class="comment"> * buffer is then incremented by &lt;tt&gt;length&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; In other words, an invocation of this method of the form</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;src.get(dst,&amp;nbsp;off,&amp;nbsp;len)&lt;/tt&gt; has exactly the same effect as</span></span><br><span class="line"><span class="comment"> * the loop</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     for (int i = off; i &lt; off + len; i++)</span></span><br><span class="line"><span class="comment"> *         dst[i] = src.get():</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * except that it first checks that there are sufficient bytes in</span></span><br><span class="line"><span class="comment"> * this buffer and it is potentially much more efficient.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  dst</span></span><br><span class="line"><span class="comment"> *         The array into which bytes are to be written</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  offset</span></span><br><span class="line"><span class="comment"> *         The offset within the array of the first byte to be</span></span><br><span class="line"><span class="comment"> *         written; must be non-negative and no larger than</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;dst.length&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  length</span></span><br><span class="line"><span class="comment"> *         The maximum number of bytes to be written to the given</span></span><br><span class="line"><span class="comment"> *         array; must be non-negative and no larger than</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;dst.length - offset&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  BufferUnderflowException</span></span><br><span class="line"><span class="comment"> *          If there are fewer than &lt;tt&gt;length&lt;/tt&gt; bytes</span></span><br><span class="line"><span class="comment"> *          remaining in this buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> *          If the preconditions on the &lt;tt&gt;offset&lt;/tt&gt; and &lt;tt&gt;length&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *          parameters do not hold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, dst.length);</span><br><span class="line">    <span class="comment">// 判断获取的数据长度是否大于剩余的数据元素长度</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        dst[i] = get();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以我们为了避免获取的数据元素大于剩余的元素的长度可以使用下面这种方式来解决。先获取剩余数据的长度然后在批量移动。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> [] bigArray = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get count of chars remaining in the buffer </span></span><br><span class="line"><span class="keyword">int</span> length = buffer.remaining( );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Buffer is known to contain &lt; 1,000 chars</span></span><br><span class="line">buffer.get(bigArrray, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do something useful with the data</span></span><br><span class="line">processData (bigArray, length);</span><br></pre></td></tr></table></figure></p>
<p>如果缓冲区存有比数组能容纳的数量更多的数据，您可以重复利用如下文所示的程序块进行读取:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] smallArray = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = Math.min(buffer.remaining(), smallArray.length);</span><br><span class="line">    buffer.get(smallArray, <span class="number">0</span>, length);</span><br><span class="line">    processData(smallArray, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>批量移入的逻辑与批量移出类似<br>第一种方式<code>put(char[] src)</code>实际代码如下，底层实际调用的就是第二种put<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Relative bulk &lt;i&gt;put&lt;/i&gt; method&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method transfers the entire content of the given source</span></span><br><span class="line"><span class="comment"> * byte array into this buffer.  An invocation of this method of the</span></span><br><span class="line"><span class="comment"> * form &lt;tt&gt;dst.put(a)&lt;/tt&gt; behaves in exactly the same way as the</span></span><br><span class="line"><span class="comment"> * invocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     dst.put(a, 0, a.length) &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   src</span></span><br><span class="line"><span class="comment"> *          The source array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  BufferOverflowException</span></span><br><span class="line"><span class="comment"> *          If there is insufficient space in this buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ReadOnlyBufferException</span></span><br><span class="line"><span class="comment"> *          If this buffer is read-only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> put(src, <span class="number">0</span>, src.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种方式<code>put (char [] src, int offset, int length)</code>，实际代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Relative bulk &lt;i&gt;put&lt;/i&gt; method&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method transfers bytes into this buffer from the given</span></span><br><span class="line"><span class="comment"> * source array.  If there are more bytes to be copied from the array</span></span><br><span class="line"><span class="comment"> * than remain in this buffer, that is, if</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;length&lt;/tt&gt;&amp;nbsp;&lt;tt&gt;&amp;gt;&lt;/tt&gt;&amp;nbsp;&lt;tt&gt;remaining()&lt;/tt&gt;, then no</span></span><br><span class="line"><span class="comment"> * bytes are transferred and a &#123;<span class="doctag">@link</span> BufferOverflowException&#125; is</span></span><br><span class="line"><span class="comment"> * thrown.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Otherwise, this method copies &lt;tt&gt;length&lt;/tt&gt; bytes from the</span></span><br><span class="line"><span class="comment"> * given array into this buffer, starting at the given offset in the array</span></span><br><span class="line"><span class="comment"> * and at the current position of this buffer.  The position of this buffer</span></span><br><span class="line"><span class="comment"> * is then incremented by &lt;tt&gt;length&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; In other words, an invocation of this method of the form</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;dst.put(src,&amp;nbsp;off,&amp;nbsp;len)&lt;/tt&gt; has exactly the same effect as</span></span><br><span class="line"><span class="comment"> * the loop</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     for (int i = off; i &lt; off + len; i++)</span></span><br><span class="line"><span class="comment"> *         dst.put(a[i]);</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * except that it first checks that there is sufficient space in this</span></span><br><span class="line"><span class="comment"> * buffer and it is potentially much more efficient.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  src</span></span><br><span class="line"><span class="comment"> *         The array from which bytes are to be read</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  offset</span></span><br><span class="line"><span class="comment"> *         The offset within the array of the first byte to be read;</span></span><br><span class="line"><span class="comment"> *         must be non-negative and no larger than &lt;tt&gt;array.length&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  length</span></span><br><span class="line"><span class="comment"> *         The number of bytes to be read from the given array;</span></span><br><span class="line"><span class="comment"> *         must be non-negative and no larger than</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;array.length - offset&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  BufferOverflowException</span></span><br><span class="line"><span class="comment"> *          If there is insufficient space in this buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> *          If the preconditions on the &lt;tt&gt;offset&lt;/tt&gt; and &lt;tt&gt;length&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *          parameters do not hold</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ReadOnlyBufferException</span></span><br><span class="line"><span class="comment"> *          If this buffer is read-only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, src.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        <span class="keyword">this</span>.put(src[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>剩余集中put就不再做展示，整体思路和上面两个put类似。</p>
<h2 id="二、创建缓冲区"><a href="#二、创建缓冲区" class="headerlink" title="二、创建缓冲区"></a>二、创建缓冲区</h2><h3 id="1-相关API"><a href="#1-相关API" class="headerlink" title="1. 相关API"></a>1. 相关API</h3><p>类似于<code>get()</code>和<code>put()</code>函数，因为Buffer是实现类返回和写入类型不同，所以在Buffer类上没有这两个接口。<br>同样Buffer类上也没有创建缓冲区的方法<code>allocate(int)</code>。<br>下面我们以ByteBuffer为例看一下一些创建缓冲区的关键函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// This is a partial API listing</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] <span class="title">array</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-使用allocate-int-创建"><a href="#2-使用allocate-int-创建" class="headerlink" title="2. 使用allocate(int)创建"></a>2. 使用allocate(int)创建</h3><p>缓冲区的创建是由分配或者包装操作来实现的。当我们要分配一个容量为100的<code>ByteBuffer</code>的时候可以执行下面这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<p>函数源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new byte buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer's position will be zero, its limit will be its</span></span><br><span class="line"><span class="comment"> * capacity, its mark will be undefined, and each of its elements will be</span></span><br><span class="line"><span class="comment"> * initialized to zero.  It will have a &#123;<span class="doctag">@link</span> #array backing array&#125;,</span></span><br><span class="line"><span class="comment"> * and its &#123;<span class="doctag">@link</span> #arrayOffset array offset&#125; will be zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  capacity</span></span><br><span class="line"><span class="comment"> *         The new buffer's capacity, in bytes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          If the &lt;tt&gt;capacity&lt;/tt&gt; is a negative integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到他实际创建的是一个以堆为存储方式的<code>ByteBuffer</code>。也就是<code>HeapByteBuffer</code>。<br>通过阅读<code>HeapByteBuffer</code>的构造方法可以发现实际就是创建了一个大小为容量的byte数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HeapByteBuffer(<span class="keyword">int</span> cap, <span class="keyword">int</span> lim) &#123;            <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, lim, cap, <span class="keyword">new</span> <span class="keyword">byte</span>[cap], <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    hb = new byte[cap];</span></span><br><span class="line"><span class="comment">    offset = 0;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-使用warp-创建"><a href="#3-使用warp-创建" class="headerlink" title="3. 使用warp()创建"></a>3. 使用warp()创建</h3><p>当我们自己创建了一个数组作为缓冲区的备份存储器，就可以使用<code>warp()</code>函数进行创建<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> [] myArray = <span class="keyword">new</span> <span class="keyword">byte</span> [<span class="number">100</span>];</span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap(myArray);</span><br></pre></td></tr></table></figure></p>
<p>源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wraps a byte array into a buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer will be backed by the given byte array;</span></span><br><span class="line"><span class="comment"> * that is, modifications to the buffer will cause the array to be modified</span></span><br><span class="line"><span class="comment"> * and vice versa.  The new buffer's capacity will be</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;array.length&lt;/tt&gt;, its position will be &lt;tt&gt;offset&lt;/tt&gt;, its limit</span></span><br><span class="line"><span class="comment"> * will be &lt;tt&gt;offset + length&lt;/tt&gt;, and its mark will be undefined.  Its</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #array backing array&#125; will be the given array, and</span></span><br><span class="line"><span class="comment"> * its &#123;<span class="doctag">@link</span> #arrayOffset array offset&#125; will be zero.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array</span></span><br><span class="line"><span class="comment"> *         The array that will back the new buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  offset</span></span><br><span class="line"><span class="comment"> *         The offset of the subarray to be used; must be non-negative and</span></span><br><span class="line"><span class="comment"> *         no larger than &lt;tt&gt;array.length&lt;/tt&gt;.  The new buffer's position</span></span><br><span class="line"><span class="comment"> *         will be set to this value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  length</span></span><br><span class="line"><span class="comment"> *         The length of the subarray to be used;</span></span><br><span class="line"><span class="comment"> *         must be non-negative and no larger than</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;array.length - offset&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         The new buffer's limit will be set to &lt;tt&gt;offset + length&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> *          If the preconditions on the &lt;tt&gt;offset&lt;/tt&gt; and &lt;tt&gt;length&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *          parameters do not hold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们看看<code>HeapByteBuffer</code>如何创建，源码如下。<br>通过阅读源码可以知道实际上<code>warp()</code>函数并不是将offset开始的长度为length的数据创建。而是将整个数组的数据都写入缓冲区的备份存储器，并且这个缓冲区的位置为offset，上界为offset + length，容量为数组大小，标记未初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HeapByteBuffer(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123; <span class="comment">// package-private</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以看到mark标记位为-1</span></span><br><span class="line"><span class="comment">     * 位置为offset</span></span><br><span class="line"><span class="comment">     * 上界为offset+length</span></span><br><span class="line"><span class="comment">     * 容量为数组的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, off, off + len, buf.length, buf, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    hb = buf;</span></span><br><span class="line"><span class="comment">    offset = 0;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 他的父类构造器如下</span></span><br><span class="line">ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,   <span class="comment">// package-private</span></span><br><span class="line">                 <span class="keyword">byte</span>[] hb, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">    <span class="keyword">this</span>.hb = hb;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>通过 allocate()或者 wrap()函数创建的缓冲区通常都是间接的，直接缓冲区我们会在后续进行讨论。</p>
</blockquote>
<h3 id="4-array-或者arrayOffset-，hasArray-介绍"><a href="#4-array-或者arrayOffset-，hasArray-介绍" class="headerlink" title="4. array()或者arrayOffset()，hasArray()介绍"></a>4. array()或者arrayOffset()，hasArray()介绍</h3><ul>
<li>使用<code>hasArray()</code>函数来判断缓冲区是够有一个可以存取的备份数组，</li>
<li>使用<code>array()</code>函数来获取对应的字节数组，</li>
<li>使用<code>arrayOffset()</code>获取缓冲区第一个元素在这个缓冲区的的偏移量(从数组头 0 开始计算)，如果您使用了带有三个参数的版本的<code>wrap()</code>函数来创建一个缓冲区，则<code>arrayOffset()</code>会一直返回 0，然而，如果 您切分了（可以使用<code>slice()</code>函数）由一个数组提供存储的缓冲区，得到的缓冲区可能会有一个非0的数组偏移量。这个数组偏移量和缓冲区容量值会告诉您数组中哪些元素是被缓冲区使用的。。</li>
</ul>
<blockquote>
<p>在调用<code>array()</code>或者<code>arrayOffset()</code>前应该使用<code>hasArray()</code>来判断数组是否存在，否则会抛出异常<br>下面是三个函数的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tells whether or not this buffer is backed by an accessible byte</span></span><br><span class="line"><span class="comment"> * array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If this method returns &lt;tt&gt;true&lt;/tt&gt; then the &#123;<span class="doctag">@link</span> #array() array&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> #arrayOffset() arrayOffset&#125; methods may safely be invoked.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &lt;tt&gt;true&lt;/tt&gt; if, and only if, this buffer</span></span><br><span class="line"><span class="comment"> *          is backed by an array and is not read-only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (hb != <span class="keyword">null</span>) &amp;&amp; !isReadOnly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the byte array that backs this</span></span><br><span class="line"><span class="comment"> * buffer&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Modifications to this buffer's content will cause the returned</span></span><br><span class="line"><span class="comment"> * array's content to be modified, and vice versa.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #hasArray hasArray&#125; method before invoking this</span></span><br><span class="line"><span class="comment"> * method in order to ensure that this buffer has an accessible backing</span></span><br><span class="line"><span class="comment"> * array.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The array that backs this buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ReadOnlyBufferException</span></span><br><span class="line"><span class="comment"> *          If this buffer is backed by an array but is read-only</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  UnsupportedOperationException</span></span><br><span class="line"><span class="comment"> *          If this buffer is not backed by an accessible array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] array() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> hb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the offset within this buffer's backing array of the first</span></span><br><span class="line"><span class="comment"> * element of the buffer&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If this buffer is backed by an array then buffer position &lt;i&gt;p&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * corresponds to array index &lt;i&gt;p&lt;/i&gt;&amp;nbsp;+&amp;nbsp;&lt;tt&gt;arrayOffset()&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #hasArray hasArray&#125; method before invoking this</span></span><br><span class="line"><span class="comment"> * method in order to ensure that this buffer has an accessible backing</span></span><br><span class="line"><span class="comment"> * array.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The offset within this buffer's array</span></span><br><span class="line"><span class="comment"> *          of the first element of the buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ReadOnlyBufferException</span></span><br><span class="line"><span class="comment"> *          If this buffer is backed by an array but is read-only</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  UnsupportedOperationException</span></span><br><span class="line"><span class="comment"> *          If this buffer is not backed by an accessible array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="三、复制缓冲区"><a href="#三、复制缓冲区" class="headerlink" title="三、复制缓冲区"></a>三、复制缓冲区</h2><p>首先我们先介绍一个概念</p>
<blockquote>
<p>我们可以创建描述从外部存储到数组中的数据元素的缓冲区对象。但是缓冲区不限于管理数组中的外部数据。它们也能管理其他缓冲区中的外部数据。当一个管理其他缓冲器所包含的数据元素的缓冲器被创建时，这个缓冲器被称为<code>视图缓冲器</code>。</p>
</blockquote>
<h3 id="1-相关API-1"><a href="#1-相关API-1" class="headerlink" title="1. 相关API"></a>1. 相关API</h3><p>复制缓冲区就是从当前缓冲区对象中复制出来一个新的缓冲区对象，我们以<code>ByteBuffer</code>为例，相关的api如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// This is a partial API listing</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">slice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-使用duplicate-复制"><a href="#2-使用duplicate-复制" class="headerlink" title="2. 使用duplicate()复制"></a>2. 使用duplicate()复制</h3><p>首先介绍<code>duplicate()</code>函数，他是创建一个共享当前缓冲区内容的新缓冲区，两个缓冲区共享数据元素，一个缓冲区数据的改变也会影响另一个缓冲区中的数据。但是每个缓冲区拥有各自的位置，上界，标记属性。如果原始的缓冲区为只读或者直接缓冲区，新的缓冲区也将继承这些属性（直接缓冲区的内容会在后续进行介绍）。<br>函数源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new byte buffer that shares this buffer's content.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The content of the new buffer will be that of this buffer.  Changes</span></span><br><span class="line"><span class="comment"> * to this buffer's content will be visible in the new buffer, and vice</span></span><br><span class="line"><span class="comment"> * versa; the two buffers' position, limit, and mark values will be</span></span><br><span class="line"><span class="comment"> * independent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer's capacity, limit, position, and mark values will be</span></span><br><span class="line"><span class="comment"> * identical to those of this buffer.  The new buffer will be direct if,</span></span><br><span class="line"><span class="comment"> * and only if, this buffer is direct, and it will be read-only if, and</span></span><br><span class="line"><span class="comment"> * only if, this buffer is read-only.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法的实现以HeapByteBuffer为例实现如下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb,</span><br><span class="line">                            <span class="keyword">this</span>.markValue(),</span><br><span class="line">                            <span class="keyword">this</span>.position(),</span><br><span class="line">                            <span class="keyword">this</span>.limit(),</span><br><span class="line">                            <span class="keyword">this</span>.capacity(),</span><br><span class="line">                            offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-使用asReadOnlyBuffer-复制"><a href="#3-使用asReadOnlyBuffer-复制" class="headerlink" title="3. 使用asReadOnlyBuffer()复制"></a>3. 使用asReadOnlyBuffer()复制</h3><p>我们还可以使用<code>asReadOnlyBuffer()</code>函数来生成一个只读的缓冲区视图。与<code>duplicate()</code>相比，这种方式创建的新缓冲区不允许使用<code>put()</code>，并且其<code>isReadOnly()</code>函数将会返回true。对这一只读缓冲区的<code>put()</code>函数的调用尝试会导致抛出<code>ReadOnlyBufferException</code>异常。<br>函数源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, read-only byte buffer that shares this buffer's</span></span><br><span class="line"><span class="comment"> * content.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The content of the new buffer will be that of this buffer.  Changes</span></span><br><span class="line"><span class="comment"> * to this buffer's content will be visible in the new buffer; the new</span></span><br><span class="line"><span class="comment"> * buffer itself, however, will be read-only and will not allow the shared</span></span><br><span class="line"><span class="comment"> * content to be modified.  The two buffers' position, limit, and mark</span></span><br><span class="line"><span class="comment"> * values will be independent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer's capacity, limit, position, and mark values will be</span></span><br><span class="line"><span class="comment"> * identical to those of this buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If this buffer is itself read-only then this method behaves in</span></span><br><span class="line"><span class="comment"> * exactly the same way as the &#123;<span class="doctag">@link</span> #duplicate duplicate&#125; method.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new, read-only byte buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法的实现以HeapByteBuffer为例实现如下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处创建的是一个只读ByteBuffer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBufferR(hb,</span><br><span class="line">                             <span class="keyword">this</span>.markValue(),</span><br><span class="line">                             <span class="keyword">this</span>.position(),</span><br><span class="line">                             <span class="keyword">this</span>.limit(),</span><br><span class="line">                             <span class="keyword">this</span>.capacity(),</span><br><span class="line">                             offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们来尝试复制一个缓冲区<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">buffer.position(<span class="number">3</span>).limit(<span class="number">6</span>).mark().position(<span class="number">5</span>);</span><br><span class="line">ByteBuffer dupeBuffer = buffer.duplicate();</span><br><span class="line">buffer.clear();</span><br></pre></td></tr></table></figure></p>
<p>执行完后两个缓冲区数据如下图<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/BE251E19-10DB-4FC9-9532-ED0D564C6796_4_5005_c.jpeg" alt="img"></p>
<h3 id="4-使用slice-切片复制"><a href="#4-使用slice-切片复制" class="headerlink" title="4. 使用slice()切片复制"></a>4. 使用slice()切片复制</h3><p>分割缓冲区与复制相似，但是<code>slice()</code>创建了一个从原始缓冲区的当前位置开始的信缓冲区，并且新缓冲区的容量是原始缓冲区的剩余数量也就是(<code>limit-position</code>)。这个新缓冲区与原始缓冲区共享一段数据元素子序列。分割出来的缓冲区也会继承只读和直接属性。<br>源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new byte buffer whose content is a shared subsequence of</span></span><br><span class="line"><span class="comment"> * this buffer's content.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The content of the new buffer will start at this buffer's current</span></span><br><span class="line"><span class="comment"> * position.  Changes to this buffer's content will be visible in the new</span></span><br><span class="line"><span class="comment"> * buffer, and vice versa; the two buffers' position, limit, and mark</span></span><br><span class="line"><span class="comment"> * values will be independent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer's position will be zero, its capacity and its limit</span></span><br><span class="line"><span class="comment"> * will be the number of bytes remaining in this buffer, and its mark</span></span><br><span class="line"><span class="comment"> * will be undefined.  The new buffer will be direct if, and only if, this</span></span><br><span class="line"><span class="comment"> * buffer is direct, and it will be read-only if, and only if, this buffer</span></span><br><span class="line"><span class="comment"> * is read-only.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">slice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法的实现以HeapByteBuffer为例实现如下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="keyword">this</span>.position();</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="keyword">this</span>.limit();</span><br><span class="line">    <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 这里我们可以看到slice创建的ByteBuffer与之前带有三个参数的版本的wrap()函数来创建一个缓冲区不同</span></span><br><span class="line">    <span class="comment">// 这里新缓冲区的offset不是0而是原始缓冲区的pos + offset</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb,</span><br><span class="line">                            -<span class="number">1</span>,</span><br><span class="line">                            <span class="number">0</span>,</span><br><span class="line">                            rem,</span><br><span class="line">                            rem,</span><br><span class="line">                            pos + offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们尝试分割一个缓冲区<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">buffer.position(<span class="number">3</span>).limit(<span class="number">5</span>);</span><br><span class="line">ByteBuffer sliceBuffer = buffer.slice();</span><br></pre></td></tr></table></figure></p>
<p>创建的缓冲区如下<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/E9421FD9-DA4B-4E4E-83E1-DABC5017BB6C_4_5005_c.jpeg" alt="img"></p>
<p>要创建一个映射到位置12-20(9个元素)的 buffer对象，应使用下面的代码实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] myBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">ByteBuffer cb = ByteBuffer.wrap(myBuffer);</span><br><span class="line">cb.position(<span class="number">12</span>).limit(<span class="number">21</span>);</span><br><span class="line">ByteBuffer sliced = cb.slice();</span><br></pre></td></tr></table></figure></p>
<h2 id="四、字节缓冲区"><a href="#四、字节缓冲区" class="headerlink" title="四、字节缓冲区"></a>四、字节缓冲区</h2><p>所有的基本数据类型都有相应的缓冲区类(布尔型除外)，但字节缓冲区有自己的独特之处。字节是操作系统及其 I/O 设备使用的基本数据类型。当在 JVM 和操作系统间传递数据时，将其他的数据类型拆分成构成它们的字节是十分必要的。如我们在后面的章节中将要看到的那样，系统层次的 I/O 面向字节的性质可以在整个缓冲区的设计以及它们互相配合的服务中感受到。</p>
<h3 id="1-ByteBuffer类完整API"><a href="#1-ByteBuffer类完整API" class="headerlink" title="1. ByteBuffer类完整API"></a>1. ByteBuffer类完整API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.nio;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">slice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] <span class="title">array</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(ByteBuffer src)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> ByteOrder <span class="title">order</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">order</span><span class="params">(ByteOrder bo)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> CharBuffer <span class="title">asCharBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ShortBuffer <span class="title">asShortBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IntBuffer <span class="title">asIntBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> LongBuffer <span class="title">asLongBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FloatBuffer <span class="title">asFloatBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DoubleBuffer <span class="title">asDoubleBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putChar</span><span class="params">(<span class="keyword">char</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putChar</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putShort</span><span class="params">(<span class="keyword">short</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putShort</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">short</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putInt</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putLong</span><span class="params">(<span class="keyword">long</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putLong</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">long</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putFloat</span><span class="params">(<span class="keyword">float</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putFloat</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">float</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putDouble</span><span class="params">(<span class="keyword">double</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putDouble</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">double</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">compact</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object ob)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object ob)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-字节顺序"><a href="#2-字节顺序" class="headerlink" title="2. 字节顺序"></a>2. 字节顺序</h3><p>此章忽略</p>
<h3 id="3-直接缓冲区"><a href="#3-直接缓冲区" class="headerlink" title="3. 直接缓冲区"></a>3. 直接缓冲区</h3><p><strong>推荐观看这个up的视频，讲的非常好</strong> <a href="https://www.bilibili.com/video/BV1ar4y1J7mC?p=11" target="_blank" rel="noopener"><strong>视频链接</strong></a></p>
<p>首先简单概括一下什么是直接缓冲区</p>
<blockquote>
<p>在我们之前使用的缓冲区都是堆内的缓冲区，而直接缓冲区则是可以从堆外申请内存来进行数据的保存，采用操作系统本地的I/O会比堆缓冲区更快一些。</p>
</blockquote>
<p>下面我们摘抄一下JAVA NIO一书中的介绍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">操作系统的在内存区域中进行 I/O 操作。这些内存区域，就操作系统方面而言，是相连的字节序列。于是，毫无疑问，只有字节缓冲区有资格参与I/O 操作。也请回想一下操作系统会直接存取进程——在本例中是 JVM 进程的内存空间，以传输数据。这也意味着 I/O 操作的目标内存区域必须是连续的字节序列。在 JVM 中，字节数组可能不会在内存中连续存储，或者无用存储单元收集可能随时对其进行移动。在 Java 中，数组是对象，而数据存储在对象中的方式在不同的 JVM 实现中都各有不同。</span><br><span class="line">出于这一原因，引入了直接缓冲区的概念。直接缓冲区被用于与通道和固有 I/O 例程交互。它们通过使用固有代码来告知操作系统直接释放或填充内存区域，对用于通道直接或原始存取的内存区域中的字节元素的存储尽了最大的努力。</span><br><span class="line"></span><br><span class="line">直接字节缓冲区通常是 I/O 操作最好的选择。在设计方面，它们支持 JVM 可用的最高效 I/O 机制。非直接字节缓冲区可以被传递给通道，但是这样可能导致性能损耗。通常非直接缓冲不可能成为一个本地 I/O 操作的目标。如果您向一个通道中传递一个非直接 ByteBuffer 对象用于写入，通道可能会在每次调用中隐含地进行下面的操作:</span><br><span class="line">1.创建一个临时的直接 ByteBuffer 对象。</span><br><span class="line">2.将非直接缓冲区的内容复制到临时缓冲中。</span><br><span class="line">3.使用临时缓冲区执行低层次 I/O 操作。</span><br><span class="line">4.临时缓冲区对象离开作用域，并最终成为被回收的无用数据。</span><br><span class="line"></span><br><span class="line">这可能导致缓冲区在每个 I/O 上复制并产生大量对象，而这种事都是我们极力避免的。不过，依靠工具，事情可以不这么糟糕。运行时间可能会缓存并重新使用直接缓冲区或者执行其他一些聪明的技巧来提高吞吐量。如果您仅仅为一次使用而创建了一个缓冲区，区别并不是很明显。另一方面，如果您将在一段高性能脚本中重复使用缓冲区，分配直接缓冲区并重新使用它们会使您游刃有余。</span><br><span class="line">直接缓冲区时 I/O 的最佳选择，但可能比创建非直接缓冲区要花费更高的成本。直接缓冲区使用的内存是通过调用本地操作系统方面的代码分配的，绕过了标准 JVM 堆栈。建立和销毁直接缓冲区会明显比具有堆栈的缓冲区更加优秀，这取决于主操作系统以及 JVM 实现。直接缓冲区的内存区域不受无用存储单元收集支配，因为它们位于标准 JVM 堆栈之外。</span><br><span class="line"></span><br><span class="line">使用直接缓冲区或非直接缓冲区的性能权衡会因JVM，操作系统，以及代码设计而产生巨大差异。通过分配堆栈外的内存，您可以使您的应用程序依赖于JVM未涉及的其它力量。当加入其他的移动部分时，确定您正在达到想要的效果。我以一条旧的软件行业格言建议您:先使其工作，再加快其运行。不要一开始就过多担心优化问题;首先要注重正确性。JVM实现可能会执行缓冲区缓存或其他的优化，这会在不需要您参与许多不必要工作的情况下为您提供所需的性能。</span><br></pre></td></tr></table></figure></p>
<h4 id="3-1-创建直接缓冲区"><a href="#3-1-创建直接缓冲区" class="headerlink" title="3.1 创建直接缓冲区"></a>3.1 创建直接缓冲区</h4><p>下面我们从ByteBuffer的allocateDirect()函数中探寻一下他是如何创建一个直接缓冲区<br>下面是函数源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new direct byte buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer's position will be zero, its limit will be its</span></span><br><span class="line"><span class="comment"> * capacity, its mark will be undefined, and each of its elements will be</span></span><br><span class="line"><span class="comment"> * initialized to zero.  Whether or not it has a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #hasArray backing array&#125; is unspecified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  capacity</span></span><br><span class="line"><span class="comment"> *         The new buffer's capacity, in bytes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          If the &lt;tt&gt;capacity&lt;/tt&gt; is a negative integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到到我们创建一个直接缓冲区时，他会去new一个DirectByteBuffer对象<br>下面是DirectByteBuffer类的构造方法，从下面我们可以看到直接缓冲区是使用java的unsafe类直接申请内存。<br>那申请的内存在清除后什么时候被回收，我们可以深入阅读Cleaner类。在里面我们可以看到他其实是一个虚引用的类，当他没有被强引用的情况下就会被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    <span class="comment">// 基础的定义上界，位置，容量，标记位等信息</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="comment">// 是否直接内存分页对齐，操作系统相关信息</span></span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="comment">// 页大小</span></span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="comment">// 计算需要申请的内存大小</span></span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 判断内存是否足够</span></span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试申请内存</span></span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        <span class="comment">// 如果出现OOM将一开始的保留内存进行释放</span></span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将申请的内存中的数据进行置0</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算申请的内存空间的地址并赋值给address</span></span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个cleaner对象</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    <span class="comment">// 这个参数的含义我们会在后面的直接缓冲区的复制那部分降到</span></span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们看看cleaner中的实际如何进行内存的释放<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deallocator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Deallocator</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> size, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (address != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果地址为0，表示已经被释放过了</span></span><br><span class="line">        <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Paranoia</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将内存进行释放</span></span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">        <span class="comment">// 将地址置0</span></span><br><span class="line">        address = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 取消保留内存</span></span><br><span class="line">        Bits.unreserveMemory(size, capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-直接缓冲区如何get"><a href="#3-2-直接缓冲区如何get" class="headerlink" title="3.2 直接缓冲区如何get()"></a>3.2 直接缓冲区如何get()</h4><p>下面是方法源码，从源码中我们可以看到在获取数据的时候，会通过，计算地址所在的位置来获取对应的数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((unsafe.getByte(ix(nextGetIndex()))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> address + ((<span class="keyword">long</span>)i &lt;&lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks the current position against the limit, throwing a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * BufferUnderflowException&#125; if it is not smaller than the limit, and then</span></span><br><span class="line"><span class="comment"> * increments the position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The current position value, before it is incremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">int</span> p = position;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    position = p + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>get(int)函数再次就不再进行介绍，自行阅读源码</p>
</blockquote>
<h4 id="3-3-直接缓冲区如何put"><a href="#3-3-直接缓冲区如何put" class="headerlink" title="3.3 直接缓冲区如何put()"></a>3.3 直接缓冲区如何put()</h4><p>下面是方法源码，从源码中我们可以看到与get逻辑类似，获取到下一步要put数据的地址，然后将数据写入内存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    unsafe.putByte(ix(nextPutIndex()), ((x)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> address + ((<span class="keyword">long</span>)i &lt;&lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks the current position against the limit, throwing a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * BufferOverflowException&#125; if it is not smaller than the limit, and then</span></span><br><span class="line"><span class="comment"> * increments the position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The current position value, before it is incremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">int</span> p = position;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    position = p + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>put(int)函数再次就不再进行介绍，自行阅读源码</p>
</blockquote>
<h4 id="3-4-复制直接缓冲区"><a href="#3-4-复制直接缓冲区" class="headerlink" title="3.4 复制直接缓冲区"></a>3.4 复制直接缓冲区</h4><p>下面我们看看直接缓冲区如何进行复制<br>我们从复制的源码入手<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(<span class="keyword">this</span>,</span><br><span class="line">                              <span class="keyword">this</span>.markValue(),</span><br><span class="line">                              <span class="keyword">this</span>.position(),</span><br><span class="line">                              <span class="keyword">this</span>.limit(),</span><br><span class="line">                              <span class="keyword">this</span>.capacity(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DirectByteBuffer(DirectBuffer db,         <span class="comment">// package-private</span></span><br><span class="line">               <span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,</span><br><span class="line">               <span class="keyword">int</span> off) &#123;</span><br><span class="line">    <span class="comment">// 基础的定义上界，位置，容量，标记位等信息</span></span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">    <span class="comment">// 将被复制对象的内存地址赋值给复制的缓冲区对象</span></span><br><span class="line">    address = db.address() + off;</span><br><span class="line">    <span class="comment">// 这里的cleaner不需要赋值，因为他本身不需要去考虑内存的释放，实际的释放是由被复制的对象进行</span></span><br><span class="line">    cleaner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从这里我们就知道att的作用了，因为我们所谓的复制是和被复制的缓冲区对象使用同一片内存，</span></span><br><span class="line">    <span class="comment">// 假设被复制的缓冲区对象没有被任何对象强引用，这个时候就可能会被JVM的GC删除，所以我们让att强引用了被复制的缓冲区对象，这样哪怕被复制的缓冲区对象被原来强引用的对象断除引用也不会导致这块内存被垃圾回收</span></span><br><span class="line">    att = db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>slice()函数再次就不再进行介绍，自行阅读源码</p>
</blockquote>
<h3 id="4-视图缓冲区"><a href="#4-视图缓冲区" class="headerlink" title="4. 视图缓冲区"></a>4. 视图缓冲区</h3><p>我们之前已经见过了一些的简单例子，在例子中一个缓冲区被复制和切分。ByteBuffer 类允许创建视图来将 byte 型缓冲区字节数据映射为其它的原始数据类型。例如，asLongBuffer()函数 创建一个将八个字节型数据当成一个 long 型数据来存取的视图缓冲区。<br>下面列出的每一个工厂方法都在原有的 ByteBuffer 对象上创建一个视图缓冲区。调用其中的任何一个方法都会创建对应的缓冲区类型，这个缓冲区是基础缓冲区的一个切分，由基 础缓冲区的位置和上界决定。新的缓冲区的容量是字节缓冲区中存在的元素数量除以视图类型中组成一个数据类型的字节数。在切分中任一个超过上界的元素对于这个视图 缓冲区都是不可见的。视图缓冲区的第一个元素从创建它的 ByteBuffer 对象的位置开始 (positon()函数的返回值)。具有能被自然数整除的数据元素个数的视图缓冲区是一种较好的实现。</p>
<h4 id="4-1-视图缓冲区相关API"><a href="#4-1-视图缓冲区相关API" class="headerlink" title="4.1 视图缓冲区相关API"></a>4.1 视图缓冲区相关API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">// This is a partial API listing</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> CharBuffer <span class="title">asCharBuffer</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ShortBuffer <span class="title">asShortBuffer</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IntBuffer <span class="title">asIntBuffer</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> LongBuffer <span class="title">asLongBuffer</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FloatBuffer <span class="title">asFloatBuffer</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DoubleBuffer <span class="title">asDoubleBuffer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-ByteBuffer-gt-CharBuffer"><a href="#4-2-ByteBuffer-gt-CharBuffer" class="headerlink" title="4.2 ByteBuffer -&gt; CharBuffer"></a>4.2 ByteBuffer -&gt; CharBuffer</h4><p>下面我们就医ByteBuffer -&gt; CharBuffer为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">7</span>).order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">CharBuffer charBuffer = byteBuffer.asCharBuffer();</span><br></pre></td></tr></table></figure></p>
<p>下面是复制的charBuffer的视图<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/370474B0-530E-48AF-B7D3-3AB0235AB516_4_5005_c.jpeg" alt="img"></p>
<p>下面我们尝试代码运行一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferCharView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">7</span>).order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">        CharBuffer charBuffer = byteBuffer.asCharBuffer();</span><br><span class="line">        <span class="comment">// Load the ByteBuffer with some bytes</span></span><br><span class="line">        byteBuffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        byteBuffer.put(<span class="number">1</span>, (<span class="keyword">byte</span>) <span class="string">'H'</span>);</span><br><span class="line">        byteBuffer.put(<span class="number">2</span>, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        byteBuffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>) <span class="string">'i'</span>);</span><br><span class="line">        byteBuffer.put(<span class="number">4</span>, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        byteBuffer.put(<span class="number">5</span>, (<span class="keyword">byte</span>) <span class="string">'!'</span>);</span><br><span class="line">        byteBuffer.put(<span class="number">6</span>, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        println(byteBuffer);</span><br><span class="line">        println(charBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print info about a buffer</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"pos="</span> + buffer.position() + <span class="string">", limit="</span> + buffer.limit() + <span class="string">", capacity="</span> + buffer.capacity() </span><br><span class="line">                + <span class="string">": '"</span> + buffer.toString() + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos=<span class="number">0</span>, limit=<span class="number">7</span>, capacity=<span class="number">7</span>: <span class="string">'java.nio.HeapByteBuffer[pos=0 lim=7 cap=7]'</span></span><br><span class="line">pos=<span class="number">0</span>, limit=<span class="number">3</span>, capacity=<span class="number">3</span>: <span class="string">'Hi!'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="5-数据元素视图"><a href="#5-数据元素视图" class="headerlink" title="5. 数据元素视图"></a>5. 数据元素视图</h3><p>ByteBuffer 类提供了一个不太重要的机制来以多字节数据类型的形式存取 byte 数据组。ByteBuffer类为每一种原始数据类型提供了存取的和转化的方法:</p>
<h4 id="5-1-数据元素视图相关API"><a href="#5-1-数据元素视图相关API" class="headerlink" title="5.1 数据元素视图相关API"></a>5.1 数据元素视图相关API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">public</span> <span class="title">abstract</span> <span class="title">char</span> <span class="title">getChar</span>( )</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">getChar</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">getShort</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getInt</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLong</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">getFloat</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">( )</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getDouble</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putChar</span> <span class="params">(<span class="keyword">char</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putChar</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putShort</span> <span class="params">(<span class="keyword">short</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putShort</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">short</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putInt</span> <span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putInt</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putLong</span> <span class="params">(<span class="keyword">long</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putLong</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">long</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putFloat</span> <span class="params">(<span class="keyword">float</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putFloat</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">float</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putDouble</span> <span class="params">(<span class="keyword">double</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">putDouble</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">double</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-从ByteBuffer中获取int或者long类型元素"><a href="#5-2-从ByteBuffer中获取int或者long类型元素" class="headerlink" title="5.2 从ByteBuffer中获取int或者long类型元素"></a>5.2 从ByteBuffer中获取int或者long类型元素</h4><p>假设一个叫 buffer 的 ByteBuffer 对象处于下图的状态。<br><img src="/images/Java-NIO-缓冲区相关概念及源码梳理/BD8A5C19-D9A9-4440-B63B-861E9C01091E_4_5005_c.jpeg" alt="img"></p>
<p>这段代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = buffer.getInt( );</span><br></pre></td></tr></table></figure></p>
<p>由于int为4个字节，会返回一个由缓冲区中位置 1-4 的 byte 数据值组成的 int 型变量的值。实际的返回值取决于缓冲区的当前的比特排序(byte-order)设置。<br>更具体的写法是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = buffer.order (ByteOrder.BIG_ENDIAN).getInt( );</span><br></pre></td></tr></table></figure></p>
<p>这将会返回值 0x3BC5315E，同时:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = buffer.order (ByteOrder.LITTLE_ENDIAN).getInt( );</span><br></pre></td></tr></table></figure></p>
<p>返回值 0x5E31C53B。</p>
<p>如果您试图获取的原始类型需要比缓冲区中存在的字节数更多的字节，会抛出 BufferUnderflowException。如我们执行下面这行代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个 long 型变量是 8 个字节的，但是缓冲区中只有 5 个字节，所以会抛出 BufferUnderflowException</span></span><br><span class="line"><span class="keyword">long</span> value = buffer.getLong( );</span><br></pre></td></tr></table></figure></p>
<h3 id="6-内存映射缓冲区"><a href="#6-内存映射缓冲区" class="headerlink" title="6. 内存映射缓冲区"></a>6. 内存映射缓冲区</h3><p>映射缓冲区是带有存储在文件，通过内存映射来存取数据元素的字节缓冲区。映射缓冲区通常是直接存取内存的，只能通过 FileChannel 类创建。映射缓冲区的用法和直接缓冲区类似，但是 MappedByteBuffer 对象可以处理独立于文件存取形式的的许多特定字符。出于这个原因，我们会在讲内存映射文件的时候讲到这部分内容。</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
            
              <a href="/tags/NIO/" rel="tag"><i class="fa fa-tag"></i> NIO</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2022/08/26/Flink常见知识点/" rel="next" title="Flink常见知识点">
                  <i class="fa fa-chevron-left"></i> Flink常见知识点
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          文章目录
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、缓冲区基础"><span class="nav-number">1.</span> <span class="nav-text">一、缓冲区基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-常见概念"><span class="nav-number">1.1.</span> <span class="nav-text">1. 常见概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Buffer类常见API"><span class="nav-number">1.2.</span> <span class="nav-text">2. Buffer类常见API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-存取"><span class="nav-number">1.3.</span> <span class="nav-text">3. 存取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-写入"><span class="nav-number">1.4.</span> <span class="nav-text">4. 写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-翻转"><span class="nav-number">1.5.</span> <span class="nav-text">5. 翻转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-释放"><span class="nav-number">1.6.</span> <span class="nav-text">6. 释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-压缩"><span class="nav-number">1.7.</span> <span class="nav-text">7. 压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-标记"><span class="nav-number">1.8.</span> <span class="nav-text">8. 标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-比较"><span class="nav-number">1.9.</span> <span class="nav-text">9. 比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-批量移动"><span class="nav-number">1.10.</span> <span class="nav-text">10. 批量移动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、创建缓冲区"><span class="nav-number">2.</span> <span class="nav-text">二、创建缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-相关API"><span class="nav-number">2.1.</span> <span class="nav-text">1. 相关API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-使用allocate-int-创建"><span class="nav-number">2.2.</span> <span class="nav-text">2. 使用allocate(int)创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-使用warp-创建"><span class="nav-number">2.3.</span> <span class="nav-text">3. 使用warp()创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-array-或者arrayOffset-，hasArray-介绍"><span class="nav-number">2.4.</span> <span class="nav-text">4. array()或者arrayOffset()，hasArray()介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、复制缓冲区"><span class="nav-number">3.</span> <span class="nav-text">三、复制缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-相关API-1"><span class="nav-number">3.1.</span> <span class="nav-text">1. 相关API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-使用duplicate-复制"><span class="nav-number">3.2.</span> <span class="nav-text">2. 使用duplicate()复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-使用asReadOnlyBuffer-复制"><span class="nav-number">3.3.</span> <span class="nav-text">3. 使用asReadOnlyBuffer()复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-使用slice-切片复制"><span class="nav-number">3.4.</span> <span class="nav-text">4. 使用slice()切片复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、字节缓冲区"><span class="nav-number">4.</span> <span class="nav-text">四、字节缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ByteBuffer类完整API"><span class="nav-number">4.1.</span> <span class="nav-text">1. ByteBuffer类完整API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-字节顺序"><span class="nav-number">4.2.</span> <span class="nav-text">2. 字节顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-直接缓冲区"><span class="nav-number">4.3.</span> <span class="nav-text">3. 直接缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-创建直接缓冲区"><span class="nav-number">4.3.1.</span> <span class="nav-text">3.1 创建直接缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-直接缓冲区如何get"><span class="nav-number">4.3.2.</span> <span class="nav-text">3.2 直接缓冲区如何get()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-直接缓冲区如何put"><span class="nav-number">4.3.3.</span> <span class="nav-text">3.3 直接缓冲区如何put()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-复制直接缓冲区"><span class="nav-number">4.3.4.</span> <span class="nav-text">3.4 复制直接缓冲区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-视图缓冲区"><span class="nav-number">4.4.</span> <span class="nav-text">4. 视图缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-视图缓冲区相关API"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.1 视图缓冲区相关API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-ByteBuffer-gt-CharBuffer"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.2 ByteBuffer -&gt; CharBuffer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-数据元素视图"><span class="nav-number">4.5.</span> <span class="nav-text">5. 数据元素视图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-数据元素视图相关API"><span class="nav-number">4.5.1.</span> <span class="nav-text">5.1 数据元素视图相关API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-从ByteBuffer中获取int或者long类型元素"><span class="nav-number">4.5.2.</span> <span class="nav-text">5.2 从ByteBuffer中获取int或者long类型元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-内存映射缓冲区"><span class="nav-number">4.6.</span> <span class="nav-text">6. 内存映射缓冲区</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.png"
      alt="随我">
  <p class="site-author-name" itemprop="name">随我</p>
  <div class="site-description" itemprop="description">用心做自己喜欢的事</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">96</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/ZhangJia97" title="GitHub &rarr; https://github.com/ZhangJia97" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:isuiwo@qq.com" title="E-Mail &rarr; mailto:isuiwo@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://wqf1234.github.io/" title="https://wqf1234.github.io/" rel="noopener" target="_blank">AC的博客</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/qq_38542085" title="https://blog.csdn.net/qq_38542085" rel="noopener" target="_blank">随我的CSDN</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">随我</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共164.9k字</span>
</div>

<div class="BbeiAn-info">
    <a target="_blank" href="http://beian.miit.gov.cn" rel="nofollow">豫ICP备18013715号-1</a> <!--a标签中增加nofollow属性，避免爬虫出站。-->
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/pisces.js?v=7.3.0"></script>

<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
