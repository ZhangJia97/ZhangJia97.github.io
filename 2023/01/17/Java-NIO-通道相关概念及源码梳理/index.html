<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.ico?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.ico?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="本文是对Java NIO一书中通道这一章节的总结，并将相关源码进行了注释和解读。">
<meta name="keywords" content="Java,NIO">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-NIO-通道相关概念及源码梳理">
<meta property="og:url" content="http://suiwo.xyz/2023/01/17/Java-NIO-通道相关概念及源码梳理/index.html">
<meta property="og:site_name" content="随我的博客">
<meta property="og:description" content="本文是对Java NIO一书中通道这一章节的总结，并将相关源码进行了注释和解读。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-通道相关概念及源码梳理/68515850-8C3C-4CF9-B2AC-6CAAAD56DF71.jpeg">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-通道相关概念及源码梳理/E94A8AA4-2F34-4C7E-ABD0-F04194E4C276.jpeg">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-通道相关概念及源码梳理/08DAF7F0-873A-4F1C-852E-8944411C8011.jpeg">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-通道相关概念及源码梳理/0BBB2664-D58A-446C-ADB1-14006DEEB9B6.jpeg">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-通道相关概念及源码梳理/8C37260C-D1C7-4776-9304-4FCA04B0E8EA_4_5005_c.jpeg">
<meta property="og:image" content="http://suiwo.xyz/images/Java-NIO-通道相关概念及源码梳理/145F6B47-0548-42C3-B6E3-7647DB4904B0_4_5005_c.jpeg">
<meta property="og:updated_time" content="2023-01-17T15:05:46.585Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java-NIO-通道相关概念及源码梳理">
<meta name="twitter:description" content="本文是对Java NIO一书中通道这一章节的总结，并将相关源码进行了注释和解读。">
<meta name="twitter:image" content="http://suiwo.xyz/images/Java-NIO-通道相关概念及源码梳理/68515850-8C3C-4CF9-B2AC-6CAAAD56DF71.jpeg">
  <link rel="alternate" href="/atom.xml" title="随我的博客" type="application/atom+xml">
  <link rel="canonical" href="http://suiwo.xyz/2023/01/17/Java-NIO-通道相关概念及源码梳理/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java-NIO-通道相关概念及源码梳理 | 随我的博客</title>
  <meta name="generator" content="Hexo 3.7.1">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/ZhangJia97" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">随我的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">记录学习的点滴</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://suiwo.xyz/2023/01/17/Java-NIO-通道相关概念及源码梳理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="随我">
      <meta itemprop="description" content="用心做自己喜欢的事">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随我的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Java-NIO-通道相关概念及源码梳理

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2023-01-17 19:32:19" itemprop="dateCreated datePublished" datetime="2023-01-17T19:32:19+08:00">2023-01-17</time>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            <div class="post-description">本文是对Java NIO一书中通道这一章节的总结，并将相关源码进行了注释和解读。</div>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="一、通道基础概念与使用"><a href="#一、通道基础概念与使用" class="headerlink" title="一、通道基础概念与使用"></a>一、通道基础概念与使用</h3><h4 id="1-1-Channel定义"><a href="#1-1-Channel定义" class="headerlink" title="1.1 Channel定义"></a>1.1 Channel定义</h4><p>首先我们先看一下Channel的接口定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断接口是否打开</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 关闭一个打开的通道。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们来观察一下Channel的两种常见实现。<code>WritableByteChannel</code> 和 <code>ReadableByteChannel</code>。这两种分别表示可写的字节通道以及可读的字节通道。</p>
<h5 id="1-1-1-WritableByteChannel接口和ReadableByteChannel接口"><a href="#1-1-1-WritableByteChannel接口和ReadableByteChannel接口" class="headerlink" title="1.1.1 WritableByteChannel接口和ReadableByteChannel接口"></a>1.1.1 WritableByteChannel接口和ReadableByteChannel接口</h5><p><code>WritableByteChannel</code>接口定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WritableByteChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ReadableByteChannel</code>接口定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadableByteChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-1-2-ByteChannel类"><a href="#1-1-2-ByteChannel类" class="headerlink" title="1.1.2 ByteChannel类"></a>1.1.2 ByteChannel类</h5><p>除此之外，还有一个<code>ByteChannel</code>类，同时实现了上述两个接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ByteChannel</span> <span class="keyword">extends</span> <span class="title">ReadableByteChannel</span>, <span class="title">WritableByteChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ByteChannel</code>接口本身并不定义新的 API 方法，它是一种用来聚集它自己以一个新名称继承的多个接口的便捷接口。根据定义，实现<code>ByteChannel</code>类的通道会同时实现 <code>ReadableByteChannel</code> 和 <code>WritableByteChannel</code> 两个接口，所以此类通道是双向的。这是简化类定义的语法糖(<code>syntactic sugar</code>)，它使得用操作器(<code>operator</code>)实例来测试通道对象变得更加简单。</p>
<p>下面是我们讲到的几个接口的继承关系</p>
<h5 id="1-1-3-InterruptibleChannel接口"><a href="#1-1-3-InterruptibleChannel接口" class="headerlink" title="1.1.3 InterruptibleChannel接口"></a>1.1.3 InterruptibleChannel接口</h5><p>InterruptibleChannel接口表示如果连接可中断通道的线程被中断，则该通道会以一种特别的方式已进行工作。具体我们会在后续进行讨论。</p>
<blockquote>
<p>我们还会发现类层次结构中有两个类位于一个不同的包: java.nio.channels.spi。这两个类是 AbstractInterruptibleChannel 和 AbstractSelectableChannel，它们分别为可中断的(interruptible)和可选择的(selectable)的通道实 现提供所需的常用方法。</p>
</blockquote>
<h4 id="1-2-打开通道"><a href="#1-2-打开通道" class="headerlink" title="1.2 打开通道"></a>1.2 打开通道</h4><p>下面我们尝试创建一个通道，从一个输入流中读取数据然后进行打印。</p>
<h5 id="1-2-1-传统IO方式读取流"><a href="#1-2-1-传统IO方式读取流" class="headerlink" title="1.2.1 传统IO方式读取流"></a>1.2.1 传统IO方式读取流</h5><p>在传统IO的情况下，我们的写法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建数组用于存储读入的输入流数据</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 创建输入流</span></span><br><span class="line">    <span class="keyword">final</span> InputStream in = System.in;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 将流读入数组中并打印</span></span><br><span class="line">        <span class="keyword">if</span> ((len = in.read(bytes)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"读取数据: "</span> + <span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是控制台打印情况，可以看到每次可以读取最多是个10个字节的数据然后进行打印。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; hahahaha</span><br><span class="line"></span><br><span class="line">读取数据: hahahaha</span><br><span class="line"></span><br><span class="line">&gt; this is a long wordddddddddddd!</span><br><span class="line"></span><br><span class="line">读取数据: this is a </span><br><span class="line">读取数据: long wordd</span><br><span class="line">读取数据: dddddddddd</span><br><span class="line">读取数据: !</span><br></pre></td></tr></table></figure></p>
<h5 id="1-2-1-通道方式读取流"><a href="#1-2-1-通道方式读取流" class="headerlink" title="1.2.1 通道方式读取流"></a>1.2.1 通道方式读取流</h5><p>但是如果我们使用通道就可以用下面的方式进行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Byte缓冲区</span></span><br><span class="line">    <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 创建一个可读的通道</span></span><br><span class="line">    <span class="keyword">final</span> ReadableByteChannel channel = Channels.newChannel(System.in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 将通道中的数据读入缓冲区</span></span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        <span class="comment">// 进行翻转</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 将缓冲区的数据进行打印</span></span><br><span class="line">        System.out.println(<span class="string">"读取数据： "</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        <span class="comment">// 将缓冲区的数据进行清空</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是控制台打印情况，可以看到每次可以读取最多是个10个字节的数据然后进行打印。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; hahahaha</span><br><span class="line"></span><br><span class="line">读取数据: hahahaha</span><br><span class="line"></span><br><span class="line">&gt; this is a long wordddddddddddd!</span><br><span class="line"></span><br><span class="line">读取数据: this is a </span><br><span class="line">读取数据: long wordd</span><br><span class="line">读取数据: dddddddddd</span><br><span class="line">读取数据: !</span><br></pre></td></tr></table></figure></p>
<p>从输入输出来看两种方式没有区别，但是，Channel不像流那样是单向的，它就像它的名字一样，一个通道可以从一端走到另一端，也可以从另一端走到这一端，</p>
<h4 id="1-4-Channel拷贝"><a href="#1-4-Channel拷贝" class="headerlink" title="1.4 Channel拷贝"></a>1.4 Channel拷贝</h4><p>我们可以自己从两个channel直接读取写入来实现拷贝。<br>第一种拷贝方式</p>
<blockquote>
<p>为了方便理解，我在每次buffer执行前后都打印了当前的位置和上界</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReadableByteChannel source = Channels.newChannel(System.in);</span><br><span class="line">    <span class="keyword">final</span> WritableByteChannel sink = Channels.newChannel(System.out);</span><br><span class="line">    <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">while</span> (source.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"1. postition: "</span> + buffer.position() + <span class="string">", limit: "</span> + buffer.limit());</span><br><span class="line">        <span class="comment">// 数据翻转，准备读取</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="string">"2. postition: "</span> + buffer.position() + <span class="string">", limit: "</span> + buffer.limit());</span><br><span class="line">        <span class="comment">// 将数据写入sink channel，写完之后buffer的position是当前已经写到的数据的下标的下一位，limit不变</span></span><br><span class="line">        sink.write(buffer);</span><br><span class="line">        System.out.println(<span class="string">"3. postition: "</span> + buffer.position() + <span class="string">", limit: "</span> + buffer.limit());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 由于写到sink channel时，不一定能完全写完buffer中所有的数据</span></span><br><span class="line"><span class="comment">         * 使用compact压缩可以使已经被写入的数据被压缩掉，未读取的数据进行前移</span></span><br><span class="line"><span class="comment">         * 等待下次循环的时候写入sink channel</span></span><br><span class="line"><span class="comment">         * 如果当前的buffer已经全部写完，此时他的效果和clear一致</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        buffer.compact();</span><br><span class="line">        System.out.println(<span class="string">"4. postition: "</span> + buffer.position() + <span class="string">", limit: "</span> + buffer.limit());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"5. postition: "</span> + buffer.position() + <span class="string">", limit: "</span> + buffer.limit());</span><br><span class="line">    <span class="comment">// 翻转，因为在输入EOF后会使buffer处于填充状态</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(<span class="string">"6. postition: "</span> + buffer.position() + <span class="string">", limit: "</span> + buffer.limit());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证buffer中所有的数据全部排出</span></span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"7. postition: "</span> + buffer.position() + <span class="string">", limit: "</span> + buffer.limit());</span><br><span class="line">        sink.write(buffer);</span><br><span class="line">        System.out.println(<span class="string">"8. postition: "</span> + buffer.position() + <span class="string">", limit: "</span> + buffer.limit());</span><br><span class="line">    &#125;</span><br><span class="line">    source.close();</span><br><span class="line">    sink.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; 123</span><br><span class="line">1. postition: 4, <span class="built_in">limit</span>: 16</span><br><span class="line">2. postition: 0, <span class="built_in">limit</span>: 4</span><br><span class="line">123</span><br><span class="line">3. postition: 4, <span class="built_in">limit</span>: 4</span><br><span class="line">4. postition: 0, <span class="built_in">limit</span>: 16</span><br><span class="line"></span><br><span class="line">&gt; 1234567890abcdefghijklmn</span><br><span class="line">1. postition: 16, <span class="built_in">limit</span>: 16</span><br><span class="line">2. postition: 0, <span class="built_in">limit</span>: 16</span><br><span class="line">1234567890abcdef</span><br><span class="line">3. postition: 16, <span class="built_in">limit</span>: 16</span><br><span class="line">4. postition: 0, <span class="built_in">limit</span>: 16</span><br><span class="line">1. postition: 9, <span class="built_in">limit</span>: 16</span><br><span class="line">2. postition: 0, <span class="built_in">limit</span>: 9</span><br><span class="line">ghijklmn</span><br><span class="line">3. postition: 9, <span class="built_in">limit</span>: 9</span><br><span class="line">4. postition: 0, <span class="built_in">limit</span>: 16</span><br><span class="line"></span><br><span class="line">&gt; ^D</span><br><span class="line">5. postition: 0, <span class="built_in">limit</span>: 16</span><br><span class="line">6. postition: 0, <span class="built_in">limit</span>: 0</span><br></pre></td></tr></table></figure></p>
<p>第二种拷贝方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReadableByteChannel source = Channels.newChannel(System.in);</span><br><span class="line">    <span class="keyword">final</span> WritableByteChannel sink = Channels.newChannel(System.out);</span><br><span class="line">    <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">while</span> (source.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 翻转数据，准备读取</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 开始写入，因为写入不一定能一次写完，具体要看实现方式，所以此处使用while保证buffer能完全排出</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            sink.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    source.close();</span><br><span class="line">    sink.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; 123</span><br><span class="line">123</span><br><span class="line"></span><br><span class="line">&gt; 1234567890abcdefghijklmn</span><br><span class="line">1234567890abcdef</span><br><span class="line">ghijklmn</span><br><span class="line"></span><br><span class="line">&gt; ^D</span><br></pre></td></tr></table></figure></p>
<p>上述两种方法的主要区别是什么呢？</p>
<blockquote>
<p>第一种方式使用到<code>compact()</code>方法会牵扯到数据的复制，但是由于它使用了压缩，可以使得<code>write()</code>次数减少(使用压缩可以使每次write的尽可能的多)<br>第二种方式不会牵扯到数据的复制，但是因为使用轮询排光buffer中的数据后才会进行下一次读取，这样会使得<code>write()</code>次数增多(因为很多时候轮询打印的数据会很少)</p>
</blockquote>
<h4 id="1-5-关闭通道"><a href="#1-5-关闭通道" class="headerlink" title="1.5 关闭通道"></a>1.5 关闭通道</h4><p>&emsp;&emsp;调用通道的<code>close()</code>方法时，可能会导致在通道关闭底层I/O服务的过程中线程暂时阻塞，哪怕该通道处于非阻塞模式。通道关闭时的阻塞行为(如果有的话)是高度取决于操作系统或者文件系统的。在一个通道上多次调用<code>close()</code>方法是没有坏处的，但是如果第一个线程在<code>close()</code>方法中阻塞，那么在它完成关闭通道之前，任何其他调用<code>close()</code>方法都会阻塞。后续在该已关闭的通道上调用<code>close()</code>不会产生任何操作，只会立即返回。</p>
<p>&emsp;&emsp;可以通过<code>isOpen()</code>方法来测试通道的开放状态。如果返回<code>true</code>值，那么该通道可以使用。如果返回false值，那么该通道已关闭，不能再被使用。尝试进行任何需要通道处于开放状态作为前提的操作，如读、写等都会导致<code>ClosedChannelException</code>异常。</p>
<p>&emsp;&emsp;通道引入了一些与关闭和中断有关的新行为。如果一个通道实现<code>InterruptibleChannel</code>接口，它的行为以下述语义为准:如果一个线程在一个通道上被阻塞并且同时被中断(由调用该被阻塞线程的<code>interrupt()</code>方法的另一个线程中断)，那么该通道将被关闭，该被阻塞线程也会产生一个<code>ClosedByInterruptException</code>异常。假设此时A线程被阻塞，此时B线程终端了A线程，此时通道会关闭。</p>
<p>&emsp;&emsp;此外，假如一个线程的<code>interrupt status</code>被设置并且该线程试图访问一个通道，那么这个通道将立即被关闭，同时将抛出相同的<code>ClosedByInterruptException</code>异常。线程的<code>interrupt status</code>在线程的<code>interrupt()</code>方法被调用时会被设置。我们可以使用<code>isInterrupted()</code>来测试某个线程当前的<code>interrupt status</code>。当前线程的<code>interrupt status</code>可以通过调用静态的<code>Thread.interrupted()</code>方法清除。</p>
<p>&emsp;&emsp;可中断的通道也是可以异步关闭的。实现<code>InterruptibleChannel</code>接口的通道可以在任何时候被关闭，即使有另一个被阻塞的线程在等待该通道上的一个I/O操作完成。当一个通道被关闭时，休眠在该通道上的所有线程都将被唤醒并接收到一个<code>AsynchronousCloseException</code>异常。接着通道就被关闭并将不再可用。</p>
<p><img src="/images/Java-NIO-通道相关概念及源码梳理/68515850-8C3C-4CF9-B2AC-6CAAAD56DF71.jpeg" alt="img"></p>
<h3 id="二、Scatter-Gather"><a href="#二、Scatter-Gather" class="headerlink" title="二、Scatter/Gather"></a>二、Scatter/Gather</h3><h4 id="2-1-概念介绍"><a href="#2-1-概念介绍" class="headerlink" title="2.1 概念介绍"></a>2.1 概念介绍</h4><p>通道提供了一种被称为<code>Scatter/Gather</code>的重要新功能(有时也被称为矢量 I/O)，它是指在多个缓冲区上实现一个简单的I/O操作。对于一个<code>write</code>操作而言，数据是从几个缓冲区按顺序抽取(称为 gather)并沿着通道发送的。缓冲区本身并不需要具备这种<code>gather</code>的能力(通常它们也没有此能力)。该<code>gather</code>过程的效果就好比全部缓冲区的内容被连结起来，并在发送数据前存放到一个大的缓冲区中。对于<code>read</code>操作而言，从通道读取的数据会按顺序被散布(称为<code>scatter</code>)到多个缓冲区，将每个缓冲区填满直至通道中的数据或者缓冲区的最大空间被消耗完。</p>
<h4 id="2-2-接口定义"><a href="#2-2-接口定义" class="headerlink" title="2.2 接口定义"></a>2.2 接口定义</h4><p>首先我们看一下<code>Scatter/Gather</code>接口分别是什么。他们分别是<code>ScatteringByteChannel</code>和<code>GatheringByteChannel</code>这两个接口。下面是他们的接口代码和依赖关系图<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ScatteringByteChannel</span> <span class="keyword">extends</span> <span class="title">ReadableByteChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span> <span class="params">(ByteBuffer [] dsts)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span> <span class="params">(ByteBuffer [] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GatheringByteChannel</span> <span class="keyword">extends</span> <span class="title">WritableByteChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/Java-NIO-通道相关概念及源码梳理/E94A8AA4-2F34-4C7E-ABD0-F04194E4C276.jpeg" alt="img"></p>
<h4 id="2-3-函数介绍"><a href="#2-3-函数介绍" class="headerlink" title="2.3 函数介绍"></a>2.3 函数介绍</h4><p>我们可以看到两个接口中的方法入参都是<code>BtyeBuffer数组</code>，显然这就是可以对多个<code>ByteBuffer</code>进行操作。<br>以下面的代码为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocateDirect(<span class="number">10</span>);</span><br><span class="line">ByteBuffer body = ByteBuffer.allocateDirect(<span class="number">80</span>);</span><br><span class="line">ByteBuffer[] buffers = &#123;header, body&#125;;</span><br><span class="line"><span class="keyword">int</span> bytesRead = channel.read(buffers);</span><br></pre></td></tr></table></figure></p>
<p>假设我们channel会将48个字节读入buffer中，那header会获取前10个，body获取剩余38个。对写也是同理。</p>
<p>带<code>offset</code>和<code>length</code>参数版本的<code>read()</code>和<code>write()</code>方法使得我们可以使用缓冲区阵列的子集缓冲区。这里的<code>offset</code>值指哪个缓冲区将开始被使用。这里的<code>length</code>参数指示要使用的缓冲区数量。假设我们有一个五元素的buffers阵列，它已经被初始化并引用了五个缓冲区，下面的代码将会写第二个、第三个和第四个缓冲区的内容:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = channel.write(fiveBuffers, <span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="2-4-使用GatheringByteChannel尝试写文件"><a href="#2-4-使用GatheringByteChannel尝试写文件" class="headerlink" title="2.4 使用GatheringByteChannel尝试写文件"></a>2.4 使用GatheringByteChannel尝试写文件</h4><p>下面我们尝试使用<code>GatheringByteChannel</code>来写文件一个代码样例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] col1 = &#123;<span class="string">"Aggregate"</span>, <span class="string">"Enable"</span>, <span class="string">"Leverage"</span>, <span class="string">"Facilitate"</span>, <span class="string">"Synergize"</span>, <span class="string">"Repurpose"</span>, <span class="string">"Strategize"</span>, <span class="string">"Reinvent"</span>, <span class="string">"Harness"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] col2 = &#123;<span class="string">"cross-platform"</span>, <span class="string">"best-of-breed"</span>, <span class="string">"frictionless"</span>, <span class="string">"ubiquitous"</span>, <span class="string">"extensible"</span>, <span class="string">"compelling"</span>, <span class="string">"mission-critical"</span>, <span class="string">"collaborative"</span>, <span class="string">"integrated"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] col3 = &#123;<span class="string">"methodologies"</span>, <span class="string">"infomediaries"</span>, <span class="string">"platforms"</span>, <span class="string">"schemas"</span>, <span class="string">"mindshare"</span>, <span class="string">"paradigms"</span>, <span class="string">"functionalities"</span>, <span class="string">"web services"</span>, <span class="string">"infrastructures"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String newline = System.getProperty(<span class="string">"line.separator"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 定义循环的次数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> reps = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 创建写入的文件</span></span><br><span class="line">        <span class="keyword">final</span> FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"test_1.txt"</span>);</span><br><span class="line">        <span class="keyword">final</span> GatheringByteChannel gatherChannel = fileOutputStream.getChannel();</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer[] bs = utterBS(reps);</span><br><span class="line">        <span class="keyword">while</span> (gatherChannel.write(bs) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 空循环直到写完</span></span><br><span class="line">        &#125;</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成一些ByteBuffer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer[] utterBS(<span class="keyword">int</span> howMany) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ByteBuffer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; howMany; i++) &#123;</span><br><span class="line">            list.add(pickRandom(col1, <span class="string">" "</span>));</span><br><span class="line">            list.add(pickRandom(col2, <span class="string">" "</span>));</span><br><span class="line">            list.add(pickRandom(col3, newline));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer[] bufs = <span class="keyword">new</span> ByteBuffer[list.size()];</span><br><span class="line">        list.toArray(bufs);</span><br><span class="line">        <span class="keyword">return</span> bufs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成ByteBuffer</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer <span class="title">pickRandom</span><span class="params">(String[] strings, String suffix)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String string = strings[rand.nextInt(strings.length)];</span><br><span class="line">        <span class="keyword">int</span> total = string.length() + suffix.length();</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer buf = ByteBuffer.allocate(total);</span><br><span class="line">        buf.put(string.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        buf.put(suffix.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        buf.flip();</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="三、文件通道FileChannel"><a href="#三、文件通道FileChannel" class="headerlink" title="三、文件通道FileChannel"></a>三、文件通道FileChannel</h3><h4 id="3-1-FileChannel简介"><a href="#3-1-FileChannel简介" class="headerlink" title="3.1 FileChannel简介"></a>3.1 FileChannel简介</h4><p>首先我们看一下FileChannel类的继承依赖关系<br><img src="/images/Java-NIO-通道相关概念及源码梳理/08DAF7F0-873A-4F1C-852E-8944411C8011.jpeg" alt="img"></p>
<h5 id="3-1-1-FileChannel是否是阻塞的？"><a href="#3-1-1-FileChannel是否是阻塞的？" class="headerlink" title="3.1.1 FileChannel是否是阻塞的？"></a>3.1.1 FileChannel是否是阻塞的？</h5><p>文件通道总是阻塞式的，因此不能被置于非阻塞模式。现代操作系统都有复杂的缓存和预取机 制，使得本地磁盘 I/O 操作延迟很少。网络文件系统一般而言延迟会多些，不过却也因该优化而受 益。面向流的 I/O 的非阻塞范例对于面向文件的操作并无多大意义，这是由文件 I/O 本质上的不同 性质造成的。</p>
<h5 id="3-1-2-FileInputStream与FileOutputStream获取的文件通道的区别？"><a href="#3-1-2-FileInputStream与FileOutputStream获取的文件通道的区别？" class="headerlink" title="3.1.2 FileInputStream与FileOutputStream获取的文件通道的区别？"></a>3.1.2 FileInputStream与FileOutputStream获取的文件通道的区别？</h5><p>我们知道在打开文件时我们可以以不同的权限打开。从<code>FileInputStream</code>对象中的<code>getChannel()</code>方法获取的<code>FileChannel</code>对象是只读的。从<code>FileOutputStream</code>对象中的<code>getChannel()</code>方法获取的<code>FileChannel</code>对象是只写的，虽然<code>FileChannel</code>类本身是双向的，但是实际进行写和读操作的时候分别会报<code>NonWritableChannelException</code>和<code>NonReadableChannelException</code>。</p>
<h5 id="3-1-3-FileChannel的position"><a href="#3-1-3-FileChannel的position" class="headerlink" title="3.1.3 FileChannel的position"></a>3.1.3 FileChannel的position</h5><p>FileChannel 位置(position)是从底层的文件描述符获得的，该 position 同时被作为通道引用 获取来源的文件对象共享。这也就意味着一个对象对该 position 的更新可以被另一个对象看到:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"filename"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="comment">// Set the file position</span></span><br><span class="line">randomAccessFile.seek(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// Create a channel from the file</span></span><br><span class="line">FileChannel fileChannel = randomAccessFile.getChannel();</span><br><span class="line"><span class="comment">// This will print "1000"</span></span><br><span class="line">System.out.println (<span class="string">"file pos: "</span> + fileChannel.position());</span><br><span class="line"><span class="comment">// Change the position using the RandomAccessFile object</span></span><br><span class="line">randomAccessFile.seek(<span class="number">500</span>);</span><br><span class="line"><span class="comment">// This will print "500"</span></span><br><span class="line">System.out.println (<span class="string">"file pos: "</span> + fileChannel.position());</span><br><span class="line"><span class="comment">// Change the position using the FileChannel object</span></span><br><span class="line">fileChannel.position(<span class="number">200</span>);</span><br><span class="line"><span class="comment">// This will print "200"</span></span><br><span class="line">System.out.println (<span class="string">"file pos: "</span> + randomAccessFile.getFilePointer());</span><br></pre></td></tr></table></figure></p>
<h5 id="3-1-4-FileChannel多线程访问一个文件会出现问题吗？"><a href="#3-1-4-FileChannel多线程访问一个文件会出现问题吗？" class="headerlink" title="3.1.4 FileChannel多线程访问一个文件会出现问题吗？"></a>3.1.4 FileChannel多线程访问一个文件会出现问题吗？</h5><p>多个线程可以并发访问同一个文件而不会相互产生干扰。这是因为每次调用都是原子性的(atomic)，并不依靠调用之间系统所记住的状态。</p>
<h5 id="3-1-5-FileChannel比较重要的方法有哪些？"><a href="#3-1-5-FileChannel比较重要的方法有哪些？" class="headerlink" title="3.1.5 FileChannel比较重要的方法有哪些？"></a>3.1.5 FileChannel比较重要的方法有哪些？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件截断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileChannel <span class="title">truncate</span><span class="params">(<span class="keyword">long</span> size)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制将全部待定的修改都应用到磁盘文件上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">force</span><span class="params">(<span class="keyword">boolean</span> metaData)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个通道间拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count, WritableByteChannel target)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个通道间拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">transferFrom</span><span class="params">(ReadableByteChannel src, <span class="keyword">long</span> position, <span class="keyword">long</span> count)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将此通道文件的区域直接映射到内存中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode mode, <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对从postition开始的size大小的文件数据进行上锁</span></span><br><span class="line"><span class="comment">// 如果已经有其他线程获取了锁，当前线程会阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">lock</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对整个文件数据进行上锁</span></span><br><span class="line"><span class="comment">// 如果已经有其他线程获取了锁，当前线程会阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lock(<span class="number">0L</span>, Long.MAX_VALUE, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试对从postition开始的size大小的文件数据进行上锁，上锁失败返回空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对整个文件数据进行上锁，上锁失败返回空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryLock(<span class="number">0L</span>, Long.MAX_VALUE, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-传统方式读写文件"><a href="#3-2-传统方式读写文件" class="headerlink" title="3.2 传统方式读写文件"></a>3.2 传统方式读写文件</h4><p>下面我们先用传统IO的方式来进行文件的读写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String fileName = <span class="string">"test.txt"</span>;</span><br><span class="line">    <span class="keyword">try</span> (FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(fileName))&#123;</span><br><span class="line">        outputStream.write(<span class="string">"this is a word"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="keyword">final</span> FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inputStream.available()];</span><br><span class="line">        inputStream.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-FileChannel读文件"><a href="#3-3-FileChannel读文件" class="headerlink" title="3.3 FileChannel读文件"></a>3.3 FileChannel读文件</h4><p>从文件中读取数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String fileName = <span class="string">"test.txt"</span>;</span><br><span class="line">    <span class="keyword">final</span> FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">    <span class="keyword">final</span> FileChannel channel = inputStream.getChannel();</span><br><span class="line">    <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span> (channel.read(buffer) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="string">"读取数据： "</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候如果我们尝试写数据会发现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String fileName = <span class="string">"test.txt"</span>;</span><br><span class="line">    <span class="keyword">final</span> FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">    <span class="keyword">final</span> FileChannel channel = inputStream.getChannel();</span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">"this is new word"</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.nio.channels.NonWritableChannelException</span><br><span class="line">	at sun.nio.ch.FileChannelImpl.write(FileChannelImpl.java:<span class="number">201</span>)</span><br><span class="line">	at xyz.suiwo.nio.FileOutputStreamFileChannelTest.main(FileOutputStreamFileChannelTest.java:<span class="number">29</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="3-4-FileChannel写文件"><a href="#3-4-FileChannel写文件" class="headerlink" title="3.4 FileChannel写文件"></a>3.4 FileChannel写文件</h4><p>下面我们尝试一下写文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String fileName = <span class="string">"test.txt"</span>;</span><br><span class="line">    <span class="keyword">final</span> FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(fileName);</span><br><span class="line">    <span class="keyword">final</span> FileChannel channel = outputStream.getChannel();</span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">"this is new word"</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同理假设我们尝试对一个输出流获取到的通道尝试读取的时候也会抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String fileName = <span class="string">"test.txt"</span>;</span><br><span class="line">    <span class="keyword">final</span> FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(fileName);</span><br><span class="line">    <span class="keyword">final</span> FileChannel channel = outputStream.getChannel();</span><br><span class="line">    <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span> (channel.read(buffer) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="string">"读取数据： "</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异常如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.nio.channels.NonReadableChannelException</span><br><span class="line">	at sun.nio.ch.FileChannelImpl.read(FileChannelImpl.java:<span class="number">149</span>)</span><br><span class="line">	at xyz.suiwo.nio.FileOutputStreamFileChannelTest.main(FileOutputStreamFileChannelTest.java:<span class="number">39</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="3-5-创建同时可读可写的FileChannel"><a href="#3-5-创建同时可读可写的FileChannel" class="headerlink" title="3.5 创建同时可读可写的FileChannel"></a>3.5 创建同时可读可写的FileChannel</h4><p>既然<code>FileChannel</code>是双向的，那我们有办法能创建一个可读可写的通道吗？<br>答案是可以的我们可以通过<code>RandomAccessFile</code>来获取通道，我们观察一下<code>RandomAccessFile</code>类的继承实现情况</p>
<p><img src="/images/Java-NIO-通道相关概念及源码梳理/0BBB2664-D58A-446C-ADB1-14006DEEB9B6.jpeg" alt="img"></p>
<p>会发现他同时实现了<code>DataOutput</code>, <code>DataInput</code>两个接口，来实现我们的可读可写<br>下面我们来尝试创建一个可读可写的通道<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">final</span> RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>, <span class="string">"rw"</span>);) &#123;</span><br><span class="line">        <span class="keyword">final</span> FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line">        channel.write(ByteBuffer.wrap(<span class="string">"this is an old word"</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        <span class="comment">// 如果不对位置进行归0，那我们读取的时候就会从当前的channel.position()开始读取</span></span><br><span class="line">        System.out.println(<span class="string">"完成写操作后当前的通道位置为： "</span> + channel.position());</span><br><span class="line">        <span class="comment">// 需要将通道的位置归0，这样我们才能从开头开始读取数据</span></span><br><span class="line">        channel.position(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">while</span> (channel.read(buffer) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">"读取数据： "</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-6-FileChannel截断"><a href="#3-6-FileChannel截断" class="headerlink" title="3.6 FileChannel截断"></a>3.6 FileChannel截断</h4><p>我们也可以使用<code>truncate(int)</code>方法来对文件进行截断<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">final</span> RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>, <span class="string">"rw"</span>);) &#123;</span><br><span class="line">        <span class="keyword">final</span> FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line">        <span class="comment">// 执行完这一行此时文件中的内容变成 'this is an old word'</span></span><br><span class="line">        channel.write(ByteBuffer.wrap(<span class="string">"this is an old word"</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        <span class="comment">// 执行完这一行此时文件中的内容变成 'this' 说明已经成功截断</span></span><br><span class="line">        channel.truncate(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">while</span> (channel.read(buffer) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">"读取数据： "</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-7-FileChannel编辑"><a href="#3-7-FileChannel编辑" class="headerlink" title="3.7 FileChannel编辑"></a>3.7 FileChannel编辑</h4><p>在我们尝试对一个文件进行编辑的时候，可以使用<code>MappedByteBuffer</code>类（这个类的详细我们会在后续讲解）来讲数据映射到内存中进行编辑，编辑结束后将编辑的内容同步到文件中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="keyword">final</span> RandomAccessFile f = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="keyword">final</span> FileChannel channel = f.getChannel())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里需要使用MapMode.READ_WRITE模式，其他模式无法保存数据到文件</span></span><br><span class="line"><span class="comment">         * 假设我们的原文是 'this is a new word'，我们接下来尝试从第2个字节开始，映射4个字节到内存中。</span></span><br><span class="line"><span class="comment">         * 如果设置的映射字节数大于本来文件中的剩余字节长度，多出来的部分将会填空字节</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 我们可以直接对在内存中的数据进行编辑，也就是编辑Buffer中的内容</span></span><br><span class="line"><span class="comment">         * 注意这里写入也是从pos位置开始的，我们当前的开始编辑的位置是第2个字节，但是我们的position当前为0</span></span><br><span class="line"><span class="comment">         * 由于我们映射的字节大小为4，假设这个时候我们写入5个字节则会抛出以下异常</span></span><br><span class="line"><span class="comment">         * Exception in thread "main" java.nio.BufferOverflowException</span></span><br><span class="line"><span class="comment">         * 	at java.nio.ByteBuffer.put(ByteBuffer.java:829)</span></span><br><span class="line"><span class="comment">         * 	at java.nio.DirectByteBuffer.put(DirectByteBuffer.java:376)</span></span><br><span class="line"><span class="comment">         * 	at java.nio.ByteBuffer.put(ByteBuffer.java:859)</span></span><br><span class="line"><span class="comment">         * 	at xxx.xxx.main(Xxxx.java:30)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 	在我们执行完put后只是修改了内存中的数据，文件此时并未进行变更</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        buffer.put(<span class="string">"abcd"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行完force()方法，此时文件完成编辑，文件内容变成 'thabcds a new word'</span></span><br><span class="line">        buffer.force();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-8-FileChannel拷贝-Channel-To-Channel"><a href="#3-8-FileChannel拷贝-Channel-To-Channel" class="headerlink" title="3.8 FileChannel拷贝(Channel To Channel)"></a>3.8 FileChannel拷贝(Channel To Channel)</h4><p>对于FileChannel我们可以使用<code>transferTo()</code>和<code>transferFrom()</code>方法<br>下面我们尝试从从一个输出流的通道拷贝到输入流的通道中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设此时test.txt中存在一份文本，执行结束后会发现成功拷贝到test2.txt文件中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">final</span> FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"test2.txt"</span>);</span><br><span class="line">        <span class="keyword">final</span> FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>)) &#123;</span><br><span class="line">        <span class="keyword">final</span> FileChannel inChannel = in.getChannel();   <span class="comment">//获取到test文件的通道</span></span><br><span class="line">        <span class="comment">// 第一个参数是开始拷贝的起始位置，第二个参数表示拷贝的数量</span></span><br><span class="line">        <span class="comment">// 将test文件通道中的数据拷贝到test2文件的通道中</span></span><br><span class="line">        inChannel.transferTo(<span class="number">0</span>, inChannel.size(), out.getChannel());</span><br><span class="line">        <span class="comment">// 下面这行代码的执行效果与上面一行一直</span></span><br><span class="line">        <span class="comment">// out.getChannel().transferFrom(inChannel, 0, inChannel.size());</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-9-文件锁定"><a href="#3-9-文件锁定" class="headerlink" title="3.9 文件锁定"></a>3.9 文件锁定</h4><p>文件锁分为共享锁和独占锁，而这种锁的具体实现很大程度上都依赖本地操作系统的实现、所以假设某个操作系统和文件系统不支持共享文件锁，那么对于一个共享所得请求会被自动提升为独占锁，这回暗中的影响性能，所以在使用前一定要对操作系统和文件系统的文件锁定行为有详细的认识。</p>
<blockquote>
<p>同时我们要注意，<code>FileChannel</code>锁实现的文件锁定模型锁的对象是文件而不是通道或者线程，这意味着文件锁的判定是服务的进程粒度下的，对于多线程并不适用。</p>
</blockquote>
<h5 id="3-9-1-文件锁定相关的API"><a href="#3-9-1-文件锁定相关的API" class="headerlink" title="3.9.1 文件锁定相关的API"></a>3.9.1 文件锁定相关的API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannel</span> <span class="keyword">extends</span> <span class="title">AbstractChannel</span> <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">ScatteringByteChannel</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个整个文件的独占锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">lock</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 对文件从position开始的size字节大小的文件加一个独占或者共享锁</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">lock</span> <span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 尝试获取锁，获取锁失败将返回null</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">tryLock</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 尝试获取锁，获取失败将返回null</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">tryLock</span> <span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果您正请求的锁定范围是有效的，那么<code>lock()</code>方法会阻塞，它必须等待前面的锁被释放。假如您的线程在此情形下被暂停，该线程的行为受中断语义控制。如果通道被另外一个线程关闭，该暂停线程将恢复并产生一个<code>AsynchronousCloseException</code>异常。假如该暂停线程被直接中断(通过调用它的<code>interrupt()</code>方法)，它将醒来并产生一个<code>FileLockInterruptionException</code>异常。如果在调用<code>lock()</code>方法时线程的<code>interrupt status</code>已经被设置，也会产生<code>FileLockInterruptionException</code>异常。</p>
<h5 id="3-9-2-FileLock介绍"><a href="#3-9-2-FileLock介绍" class="headerlink" title="3.9.2 FileLock介绍"></a>3.9.2 FileLock介绍</h5><p>首先我们看一下FileLock类的重要方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLock</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前锁对应的文件通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileChannel <span class="title">channel</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 获取当前锁的文件位置</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">position</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 获取锁文件的大小</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 返回当前锁是否为共享锁</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 返回从position-size的锁是否和当前所重合</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">overlaps</span> <span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 告知此锁是否有效。锁定对象在释放或关联的文件通道关闭（以先到者为准）之前一直有效。</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="comment">// 释放当前锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管一个FileLock对象是与某个特定的FileChannel实例关联的，它所代表的锁却是与一个底层文件关联的，而不是与通道关联。因此，如果您在使用完一个锁后而不释放它的话，可能会导致冲突或者死锁。请小心管理文件锁以避免出现此问题。一旦您成功地获取了一个文件锁，如果随后在通道上出现错误的话，请务必释放这个锁。<br>下面是推荐使用的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">final</span> RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>, <span class="string">"rw"</span>); </span><br><span class="line">     <span class="keyword">final</span> FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line">     <span class="keyword">final</span> FileLock lock = channel.lock()) &#123;</span><br><span class="line">    <span class="comment">// lock code</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-9-3-尝试进程间使用文件锁"><a href="#3-9-3-尝试进程间使用文件锁" class="headerlink" title="3.9.3 尝试进程间使用文件锁"></a>3.9.3 尝试进程间使用文件锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">    <span class="keyword">final</span> FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date() + <span class="string">" 正在尝试获取文件锁..."</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">final</span> FileLock lock = channel.lock()) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">" 已获取到文件锁！"</span>);</span><br><span class="line">        <span class="comment">//假设要处理5秒钟</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">" 操作完毕，释放文件锁！"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们同时启动两个实例，此时可以在控制台看到在第一个实例释放锁喉第二个实例才获取到锁<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 控制台1</span></span><br><span class="line">Sun Jan 15 15:57:22 CST 2023 正在尝试获取文件锁...</span><br><span class="line">Sun Jan 15 15:57:22 CST 2023 已获取到文件锁！</span><br><span class="line">Sun Jan 15 15:57:27 CST 2023 操作完毕，释放文件锁！</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制台2</span></span><br><span class="line">Sun Jan 15 15:57:24 CST 2023 正在尝试获取文件锁...</span><br><span class="line">Sun Jan 15 15:57:27 CST 2023 已获取到文件锁！</span><br><span class="line">Sun Jan 15 15:57:32 CST 2023 操作完毕，释放文件锁！</span><br></pre></td></tr></table></figure></p>
<p>这是如果我们修改lock方式对同一个文件的不同位置进行上锁就会发现，两个进程不会阻塞对方。</p>
<h3 id="四、内存映射文件"><a href="#四、内存映射文件" class="headerlink" title="四、内存映射文件"></a>四、内存映射文件</h3><p>在FileChannel中提供了一个map()方法，这个方法是可以在一个打开的文件和一个特殊的ByteBuffer之间建立一个虚拟内存映射。在FileChannel上调用map()方法会创建一个由磁盘文件支持的虚拟内存映射(virtual memory mapping)并在那块虚拟内存空间外部封装一个MappedByteBuffer对象。如下图</p>
<p><img src="/images/Java-NIO-通道相关概念及源码梳理/8C37260C-D1C7-4776-9304-4FCA04B0E8EA_4_5005_c.jpeg" alt="img"></p>
<p>通过内存映射机制来访问一个文件会比使用常规方法读写高效得多，甚至比使用通道的效率都高。因为不需要做明确的系统调用，那会很消耗时间。更重要的是，操作系统的虚拟内存可以自动缓存内存页(memory page)。这些页是用系统内存来缓存的，所以不会消耗Java虚拟机内存堆(memory heap)。</p>
<h4 id="4-1-map-方法定义"><a href="#4-1-map-方法定义" class="headerlink" title="4.1 map()方法定义"></a>4.1 map()方法定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannel</span> <span class="keyword">extends</span> <span class="title">AbstractChannel</span> <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">ScatteringByteChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射模式，开始文件位置，读取的文件size</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> MappedByteBuffer <span class="title">map</span> <span class="params">(MapMode mode, <span class="keyword">long</span> position,<span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> class MapMode </span>&#123;</span><br><span class="line">        <span class="comment">// 只读</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MapMode READ_ONLY</span><br><span class="line">        <span class="comment">// 读写模式</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MapMode READ_WRITE</span><br><span class="line">        <span class="comment">// 写时拷贝</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MapMode PRIVATE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们尝试映射100到299位置的字节，代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">100</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure></p>
<p>尝试映射整个文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, fileChannel.size());</span><br></pre></td></tr></table></figure></p>
<h5 id="4-1-1-MapMode介绍"><a href="#4-1-1-MapMode介绍" class="headerlink" title="4.1.1 MapMode介绍"></a>4.1.1 MapMode介绍</h5><p>MapMode.READ_ONLY 和 MapMode.READ_WRITE 意义是很明显的，它们表示您希望获取的映射只读还是允许修改映射的文件。请求的映射模式将受被调用map( )方法的 FileChannel 对象的访问权限所限制。如果通道是以只读的权限打开的而您却请求 MapMode.READ_WRITE 模式，那么 map( )方法会抛出一个 NonWritableChannelException 异常;如果您在一个没有读权限的通道上请求 MapMode.READ_ONLY 映射模式，那么将产生 NonReadableChannelException 异常。不过在以 read/write 权限打开的通道上请求一个 MapMode.READ_ONLY 映射却是允许的。MappedByteBuffer 对象的可变性可以通过对它调用 isReadOnly( )方法来检查。</p>
<p>MapMode.PRIVATE 表示您想要一个写时拷贝(copy-on-write)的映射。这意味着 您通过 put( )方法所做的任何修改都会导致产生一个私有的数据拷贝并且该拷贝中的数据只有 MappedByteBuffer 实例可以看到。该过程不会对底层文件做任何修改，而且一旦缓冲区被施以垃圾 收集动作(garbage collected)，那些修改都会丢失。尽管写时拷贝的映射可以防止底层文件被修 改，您也必须以 read/write 权限来打开文件以建立 MapMode.PRIVATE 映射。只有这样，返回的 MappedByteBuffer 对象才能允许使用 put( )方法。</p>
<p>下面我们对三种类型的MappedByteBuffer进行读写看看互相的影响，各种模式的内存映射如何交互。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建临时文件</span></span><br><span class="line">    <span class="keyword">final</span> File tempFile = File.createTempFile(<span class="string">"mmaptest"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">final</span> RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(tempFile, <span class="string">"rw"</span>);</span><br><span class="line">         <span class="keyword">final</span> FileChannel channel = file.getChannel())&#123;</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer temp = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">        temp.put(<span class="string">"This is the file content"</span>.getBytes());</span><br><span class="line">        temp.flip();</span><br><span class="line">        channel.write(temp, <span class="number">0</span>);</span><br><span class="line">        temp.clear();</span><br><span class="line">        temp.put(<span class="string">"This is more file content"</span>.getBytes());</span><br><span class="line">        temp.flip();</span><br><span class="line">        <span class="comment">// 中间部分都是空</span></span><br><span class="line">        channel.write(temp, <span class="number">8192</span>);</span><br><span class="line">        <span class="comment">// 分别创建只读，读写和copy-on-write的MappedByteBuffer</span></span><br><span class="line">        <span class="keyword">final</span> MappedByteBuffer ro = channel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, channel.size());</span><br><span class="line">        <span class="keyword">final</span> MappedByteBuffer rw = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, channel.size());</span><br><span class="line">        <span class="keyword">final</span> MappedByteBuffer cow = channel.map(FileChannel.MapMode.PRIVATE, <span class="number">0</span>, channel.size());</span><br><span class="line">        System.out.println(<span class="string">"Begin"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此时三种方式的MappedByteBuffer的输出分别是</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * R/O: 'This is the file content|[8168 nulls]|This is more file content'</span></span><br><span class="line"><span class="comment">         * R/W: 'This is the file content|[8168 nulls]|This is more file content'</span></span><br><span class="line"><span class="comment">         * COW: 'This is the file content|[8168 nulls]|This is more file content'</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        showBuffers(ro, rw, cow);</span><br><span class="line">        cow.position(<span class="number">8</span>);</span><br><span class="line">        cow.put(<span class="string">"COW"</span>.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"Change to COW buffer"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此时三种方式的MappedByteBuffer的输出分别是</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * R/O: 'This is the file content|[8168 nulls]|This is more file content'</span></span><br><span class="line"><span class="comment">         * R/W: 'This is the file content|[8168 nulls]|This is more file content'</span></span><br><span class="line"><span class="comment">         * COW: 'This is COW file content|[8168 nulls]|This is more file content'</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        showBuffers(ro, rw, cow);</span><br><span class="line">        rw.position(<span class="number">9</span>);</span><br><span class="line">        rw.put(<span class="string">" R/W "</span>.getBytes());</span><br><span class="line">        rw.position(<span class="number">8194</span>);</span><br><span class="line">        rw.put(<span class="string">" R/W "</span>.getBytes());</span><br><span class="line">        rw.force();</span><br><span class="line">        System.out.println(<span class="string">"Change to R/W buffer"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此时三种方式的MappedByteBuffer的输出分别是</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * R/O: 'This is t R/W le content|[8168 nulls]|Th R/W  more file content'</span></span><br><span class="line"><span class="comment">         * R/W: 'This is t R/W le content|[8168 nulls]|Th R/W  more file content'</span></span><br><span class="line"><span class="comment">         * COW: 'This is COW file content|[8168 nulls]|This is more file content'</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        showBuffers(ro, rw, cow);</span><br><span class="line">        <span class="comment">// Write to the file through the channel; hit both pages</span></span><br><span class="line">        temp.clear();</span><br><span class="line">        temp.put(<span class="string">"Channel write "</span>.getBytes());</span><br><span class="line">        temp.flip();</span><br><span class="line">        channel.write(temp, <span class="number">0</span>);</span><br><span class="line">        temp.rewind();</span><br><span class="line">        channel.write(temp, <span class="number">8202</span>);</span><br><span class="line">        System.out.println(<span class="string">"Write on channel"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此时三种方式的MappedByteBuffer的输出分别是</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * R/O: 'Channel write le content|[8168 nulls]|Th R/W  moChannel write t'</span></span><br><span class="line"><span class="comment">         * R/W: 'Channel write le content|[8168 nulls]|Th R/W  moChannel write t'</span></span><br><span class="line"><span class="comment">         * COW: 'This is COW file content|[8168 nulls]|This is more file content'</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        showBuffers(ro, rw, cow);</span><br><span class="line">        <span class="comment">// Modify the copy-on-write buffer again</span></span><br><span class="line">        cow.position(<span class="number">8207</span>);</span><br><span class="line">        cow.put(<span class="string">" COW2 "</span>.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"Second change to COW buffer"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此时三种方式的MappedByteBuffer的输出分别是</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * R/O: 'Channel write le content|[8168 nulls]|Th R/W  moChannel write t'</span></span><br><span class="line"><span class="comment">         * R/W: 'Channel write le content|[8168 nulls]|Th R/W  moChannel write t'</span></span><br><span class="line"><span class="comment">         * COW: 'This is COW file content|[8168 nulls]|This is more fi COW2 tent'</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        showBuffers(ro, rw, cow);</span><br><span class="line">        <span class="comment">// Modify the read/write buffer</span></span><br><span class="line">        rw.position(<span class="number">0</span>);</span><br><span class="line">        rw.put(<span class="string">" R/W2 "</span>.getBytes());</span><br><span class="line">        rw.position(<span class="number">8210</span>);</span><br><span class="line">        rw.put(<span class="string">" R/W2 "</span>.getBytes());</span><br><span class="line">        rw.force();</span><br><span class="line">        System.out.println(<span class="string">"Second change to R/W buffer"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此时三种方式的MappedByteBuffer的输出分别是</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * R/O: ' R/W2 l write le content|[8168 nulls]|Th R/W  moChannel  R/W2 t'</span></span><br><span class="line"><span class="comment">         * R/W: ' R/W2 l write le content|[8168 nulls]|Th R/W  moChannel  R/W2 t'</span></span><br><span class="line"><span class="comment">         * COW: 'This is COW file content|[8168 nulls]|This is more fi COW2 tent'</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        showBuffers(ro, rw, cow);</span><br><span class="line">    &#125;</span><br><span class="line">    tempFile.delete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对三种形式的ByteBuffer进行打印</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showBuffers</span><span class="params">(ByteBuffer ro, ByteBuffer rw, ByteBuffer cow)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    dumpBuffer(<span class="string">"R/O"</span>, ro);</span><br><span class="line">    dumpBuffer(<span class="string">"R/W"</span>, rw);</span><br><span class="line">    dumpBuffer(<span class="string">"COW"</span>, cow);</span><br><span class="line">    System.out.println(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印ByteBuffer中的内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dumpBuffer</span><span class="params">(String prefix, ByteBuffer buffer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.print(prefix + <span class="string">": '"</span>);</span><br><span class="line">    <span class="keyword">int</span> nulls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> limit = buffer.limit();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = (<span class="keyword">char</span>) buffer.get(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\u0000'</span>) &#123;</span><br><span class="line">            nulls++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nulls != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">"|["</span> + nulls + <span class="string">" nulls]|"</span>);</span><br><span class="line">            nulls = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(c);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-2-MappedByteBuffer介绍"><a href="#4-2-MappedByteBuffer介绍" class="headerlink" title="4.2 MappedByteBuffer介绍"></a>4.2 MappedByteBuffer介绍</h4><p>首先我们看一下MappedByteBuffer和其他ByteBuffer相比不同的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBuffer</span> <span class="keyword">extends</span> <span class="title">ByteBuffer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// load( )方法会加载整个文件以使它常驻内存。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title">load</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 我们可以通过调用 isLoaded()方法来判断一个被映射的文件是否完全常驻内存了。如果该方法返回 true 值，那么很大概率是映射缓冲区的访问延迟很少或者根本没有延迟。不过，这也是不能保证的。</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLoaded</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 强制将对此缓冲区内容所做的任何更改写入包含映射文件的存储设备。</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 如果映射是以 MapMode.READ_ONLY 或 MAP_MODE.PRIVATE 模式建立的，那么调用 force() 方法将不起任何作用，因为永远不会有更改需要应用到磁盘上(但是这样做也是没有害处的)。</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title">force</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="五、Socket通道"><a href="#五、Socket通道" class="headerlink" title="五、Socket通道"></a>五、Socket通道</h3><h4 id="5-1-阻塞I-O的socket实现"><a href="#5-1-阻塞I-O的socket实现" class="headerlink" title="5.1 阻塞I/O的socket实现"></a>5.1 阻塞I/O的socket实现</h4><p>在学习Socket通道之前我们先重温一下，在JAVA传统的阻塞I/O中Socket通信是如何实现的<br>服务端代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">final</span> ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">"等待客户端连接。。。。"</span>);</span><br><span class="line">        <span class="keyword">final</span> Socket socket = server.accept();</span><br><span class="line">        System.out.println(<span class="string">"客户端已连接，IP地址为: "</span> + socket.getInetAddress().getHostAddress());</span><br><span class="line">        <span class="keyword">final</span> BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        System.out.println(<span class="string">"开始接收客户端消息。。。。"</span>);</span><br><span class="line">        System.out.println(<span class="string">"收到客户端请求: "</span> + reader.readLine());</span><br><span class="line">        <span class="keyword">final</span> OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream());</span><br><span class="line">        writer.write(<span class="string">"已收到，服务端IP为: "</span> + server.getInetAddress().getHostAddress());</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">final</span> Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8080</span>);</span><br><span class="line">         <span class="keyword">final</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in)) &#123;</span><br><span class="line">        System.out.println(<span class="string">"已连接到服务端!"</span>);</span><br><span class="line">        <span class="keyword">final</span> OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream());</span><br><span class="line">        System.out.print(<span class="string">"请输入要发送的数据 &gt; "</span>);</span><br><span class="line">        <span class="keyword">final</span> String text = scanner.nextLine();</span><br><span class="line">        writer.write(text + <span class="string">"\n"</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        <span class="keyword">final</span> BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        <span class="keyword">final</span> String line = reader.readLine();</span><br><span class="line">        System.out.println(<span class="string">"收到服务端返回: "</span> + line);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出日志如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端日志</span></span><br><span class="line">等待客户端连接。。。。</span><br><span class="line">客户端已连接，IP地址为: 127.0.0.1</span><br><span class="line">开始接收客户端消息。。。。</span><br><span class="line">收到客户端请求: hello socket server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端日志</span></span><br><span class="line">已连接到服务端!</span><br><span class="line">请输入要发送的数据 &gt; hello socket server</span><br><span class="line">收到服务端返回: 已收到，服务端IP为: 0.0.0.0</span><br></pre></td></tr></table></figure></p>
<h4 id="5-2-非阻塞I-O的实现"><a href="#5-2-非阻塞I-O的实现" class="headerlink" title="5.2 非阻塞I/O的实现"></a>5.2 非阻塞I/O的实现</h4><p>服务端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">final</span> ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"等待客户端连接。。。。"</span>);</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">final</span> SocketChannel socket = server.accept();</span><br><span class="line">        System.out.println(<span class="string">"客户端已连接，IP地址为: "</span> + socket.getRemoteAddress());</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        socket.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">final</span> String text = <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining());</span><br><span class="line">        System.out.println(<span class="string">"接收到客户端消息: "</span> + text);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        socket.write(ByteBuffer.wrap((<span class="string">"已收到消息，当前服务IP为: "</span> + server.getLocalAddress().toString()).getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">final</span> SocketChannel socket = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8080</span>)); <span class="keyword">final</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in)) &#123;</span><br><span class="line">        System.out.println(<span class="string">"已连接到服务端!"</span>);</span><br><span class="line">        System.out.print(<span class="string">"请输入要发送的数据 &gt; "</span>);</span><br><span class="line">        <span class="keyword">final</span> String text = scanner.nextLine();</span><br><span class="line">        socket.write(ByteBuffer.wrap(text.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        System.out.println(<span class="string">"收到服务端返回: "</span>);</span><br><span class="line">        socket.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出日志如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端日志</span></span><br><span class="line">Connected to the target VM, address: <span class="string">'127.0.0.1:54206'</span>, transport: <span class="string">'socket'</span></span><br><span class="line">等待客户端连接。。。。</span><br><span class="line">客户端已连接，IP地址为: /127.0.0.1:54216</span><br><span class="line">接收到客户端消息: haha</span><br><span class="line">Disconnected from the target VM, address: <span class="string">'127.0.0.1:54206'</span>, transport: <span class="string">'socket'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端日志</span></span><br><span class="line">Connected to the target VM, address: <span class="string">'127.0.0.1:54214'</span>, transport: <span class="string">'socket'</span></span><br><span class="line">已连接到服务端!</span><br><span class="line">请输入要发送的数据 &gt; haha</span><br><span class="line">收到服务端返回: </span><br><span class="line">已收到消息，当前服务IP为: /0:0:0:0:0:0:0:0:8080</span><br><span class="line">Disconnected from the target VM, address: <span class="string">'127.0.0.1:54214'</span>, transport: <span class="string">'socket'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="5-3-Socket通道常用类介绍"><a href="#5-3-Socket通道常用类介绍" class="headerlink" title="5.3 Socket通道常用类介绍"></a>5.3 Socket通道常用类介绍</h4><ol>
<li>Socket通道类有三个，分别是<code>SocketChannle</code>,<code>ServerSocketChannel</code>和<code>DatagramChannel</code>。这三个通道都是由<code>AbstractSelectableChannel</code>类引申而来。这意味着我们可以使用一个<code>Selector</code>对象来执行有条件的选择。</li>
<li>当我们实例化<code>DatagramChannel</code>,<code>SocketChannel</code>,<code>ServerSocketChannel</code>后，会发现都可以通过<code>socket()</code>方法获取我们所熟悉的<code>java.net</code>包下的对等对象<code>DatagramSocket</code>,<code>Socket</code>,<code>ServerSocket</code>。通过通过对等的socket的<code>getChannel()</code>方法我们也可以获取到他所关联的通道。当然并非所有的socket都可以获取的对应的channel，当我们使用传统方式实例化一个Socket对象是，此时调用<code>getChannel()</code>返回将为null。</li>
<li>通过继承关系我们会发现<code>DatagramChannel</code>和<code>SocketChannel</code>实现定义读和写功能的接口而<code>ServerSocketChannel</code>不实现。<code>ServerSocketChannel</code>负责监听传入的连接和创建新的<code>SocketChannel</code>对象，它本身从不传输数据。</li>
</ol>
<h5 id="5-3-1-非阻塞模式"><a href="#5-3-1-非阻塞模式" class="headerlink" title="5.3.1 非阻塞模式"></a>5.3.1 非阻塞模式</h5><p>传统的Java Socket的阻塞曾是Java程序可伸缩性的重要制约之一。非阻塞I/O是许多复杂、高性能的程序构建的基础。要把一个Socket通道置于非阻塞模式，我们要依靠所有Socket通道类的共有超级类<code>SelectableChannel</code>。<br>下面我们对<code>SelectableChannel</code>进行分析。<br>我们本章只看和阻塞相关的方法，剩余的方法将会在降到选择器的时候再进行介绍。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectableChannel</span> <span class="keyword">extends</span> <span class="title">AbstractChannel</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调整此通道的阻塞模式。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">configureBlocking</span> <span class="params">(<span class="keyword">boolean</span> block)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">// 获取当前block状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isBlocking</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取锁对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">blockingLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们尝试shi用伪代码来实现修改阻塞模式，判断阻塞默认然后执行对应的操作的行为。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel sc = SocketChannel.open();</span><br><span class="line"><span class="comment">// 设置为非阻塞</span></span><br><span class="line">sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// doSomething (cs);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sc.isBlocking()) &#123;</span><br><span class="line">    <span class="comment">// doSomething (cs);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有的时候我们也需要避免执行部分代码的时候socket通道的阻塞模式被修改，这个时候我们可以使用<code>blockingLock()</code>方法，该方法会返回一个非透明的对象引用。通过对这个对象上锁，防止其他线程对阻塞模式的修改。对于确保在执行代码的关键部分时socket通道的阻塞模式不会改变以及在不影响其他线程的前提下暂时改变阻塞模式来说，这个方法都是非常方便的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = <span class="keyword">null</span>;</span><br><span class="line">Object lockObj = serverChannel.blockingLock();</span><br><span class="line"><span class="comment">// 对获取的锁对象加synchronize</span></span><br><span class="line">synchronize (lockObj) &#123;</span><br><span class="line">    <span class="comment">// 当前线程获取了锁，其他线程无法修改阻塞模式</span></span><br><span class="line">    <span class="keyword">boolean</span> prevState = serverChannel.isBlocking();</span><br><span class="line">    serverChannel.configureBlocking (<span class="keyword">false</span>);</span><br><span class="line">    socket = serverChannel.accept();</span><br><span class="line">    serverChannel.configureBlocking(prevState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前线程释放了锁，其他线程可以修改阻塞模式</span></span><br><span class="line"><span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// doSomethingWithTheSocket(socket);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-4-ServerSocketChannel"><a href="#5-4-ServerSocketChannel" class="headerlink" title="5.4 ServerSocketChannel"></a>5.4 ServerSocketChannel</h4><h5 id="5-4-1-ServerSocketChannel类方法介绍"><a href="#5-4-1-ServerSocketChannel类方法介绍" class="headerlink" title="5.4.1 ServerSocketChannel类方法介绍"></a>5.4.1 ServerSocketChannel类方法介绍</h5><p>首先我们看一下ServerSocketChannel的完成方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span> <span class="keyword">implements</span> <span class="title">NetworkChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个ServerSocket通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SelectorProvider.provider().openServerSocketChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回标识此通道支持的操作的操作集。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SelectionKey.OP_ACCEPT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- 下面是ServerSocket特有的一些方法 --</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前通道绑定到一个本地端口地址，backlog是最大连接数，如果backlog参数的值为0或负值，则使用特定于实现的默认值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bind(local, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前通道绑定到一个本地端口地址，backlog是最大连接数，如果backlog参数的值为0或负值，则使用特定于实现的默认值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">ServerSocketChannel <span class="title">setOption</span><span class="params">(SocketOption&lt;T&gt; name, T value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前通道的对应java.net的socket对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ServerSocket <span class="title">socket</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受一个当前通道的Socket连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketChannel <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此通道的套接字所绑定的套接字地址。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketAddress <span class="title">getLocalAddress</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-4-2-实现非阻塞的ServerSocketChannel"><a href="#5-4-2-实现非阻塞的ServerSocketChannel" class="headerlink" title="5.4.2 实现非阻塞的ServerSocketChannel"></a>5.4.2 实现非阻塞的ServerSocketChannel</h5><p>当我们打开了一个通道并且完成了端口服务绑定，就可以通过<code>accept()</code>方法来获取一个socket。同时返回的socket对象可以在非阻塞模式下运行。<br>如果ServerSocketChannel是以非阻塞模式被调用，<code>ServerSocketChannel.accept()</code>会立即返回 null。正是这种检查连接而不阻塞的能力实现了可伸缩性并降低了复杂性。可选择性也因此得到实现。我们可以使用一个选择器实例来注册一个<code>ServerSocketChannel</code>对象以实现新连接到达时自动通知的功能。<br>下面我们来尝试一下非阻塞的<code>accept()</code>方法。</p>
<p>服务端代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">final</span> ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"---- 等待客户端连接, 当前时间: "</span> + format.format(<span class="keyword">new</span> Date()) + <span class="string">" ----\n"</span>);</span><br><span class="line">            <span class="keyword">final</span> SocketChannel socket = server.accept();</span><br><span class="line">            <span class="keyword">if</span> (socket == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"客户端进行连接，客户端信息: "</span> + socket.getRemoteAddress().toString());</span><br><span class="line">                socket.read(buffer);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                System.out.println(<span class="string">"客户端内容为 &gt; "</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining(), StandardCharsets.UTF_8));</span><br><span class="line">                buffer.clear();</span><br><span class="line">                <span class="keyword">final</span> String text = <span class="string">"收到您的请求， 服务器信息如下: "</span> + server.getLocalAddress().toString() + <span class="string">", 当前接收时间为: "</span> + format.format(<span class="keyword">new</span> Date());</span><br><span class="line">                System.out.println(<span class="string">"发送消息到客户端，消息内容为 &gt; "</span> + text + <span class="string">"\n"</span>);</span><br><span class="line">                socket.write(ByteBuffer.wrap(text.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"------ 创建第 "</span> + i + <span class="string">" 次连接 ------"</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="keyword">final</span> SocketChannel socket = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8080</span>))) &#123;</span><br><span class="line">            <span class="keyword">final</span> String text = <span class="string">"客户端的第 "</span> + i + <span class="string">" 条消息, 当前发送时间为: "</span> + format.format(<span class="keyword">new</span> Date());</span><br><span class="line">            System.out.print(<span class="string">"发送消息到服务端，消息内容为 &gt; "</span> + text);</span><br><span class="line">            socket.write(ByteBuffer.wrap(text.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">            <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            socket.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">"收到服务端返回 &gt; "</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"------ 断开第 "</span> + i + <span class="string">" 次连接 ------\n"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line">---- 等待客户端连接, 当前时间: 2023-01-16 15:47:23 ----</span><br><span class="line"></span><br><span class="line">---- 等待客户端连接, 当前时间: 2023-01-16 15:47:25 ----</span><br><span class="line"></span><br><span class="line">---- 等待客户端连接, 当前时间: 2023-01-16 15:47:27 ----</span><br><span class="line"></span><br><span class="line">客户端进行连接，客户端信息: /127.0.0.1:59505</span><br><span class="line">客户端内容为 &gt; 客户端的第 1 条消息, 当前发送时间为: 2023-01-16 15:47:26</span><br><span class="line">发送消息到客户端，消息内容为 &gt; 收到您的请求， 服务器信息如下: /0:0:0:0:0:0:0:0:8080, 当前接收时间为: 2023-01-16 15:47:27</span><br><span class="line"></span><br><span class="line">---- 等待客户端连接, 当前时间: 2023-01-16 15:47:27 ----</span><br><span class="line"></span><br><span class="line">---- 等待客户端连接, 当前时间: 2023-01-16 15:47:29 ----</span><br><span class="line"></span><br><span class="line">---- 等待客户端连接, 当前时间: 2023-01-16 15:47:31 ----</span><br><span class="line"></span><br><span class="line">客户端进行连接，客户端信息: /127.0.0.1:59524</span><br><span class="line">客户端内容为 &gt; 客户端的第 2 条消息, 当前发送时间为: 2023-01-16 15:47:30</span><br><span class="line">发送消息到客户端，消息内容为 &gt; 收到您的请求， 服务器信息如下: /0:0:0:0:0:0:0:0:8080, 当前接收时间为: 2023-01-16 15:47:31</span><br><span class="line"></span><br><span class="line">---- 等待客户端连接, 当前时间: 2023-01-16 15:47:31 ----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line">------ 创建第 1 次连接 ------</span><br><span class="line">发送消息到服务端，消息内容为 &gt; 客户端的第 1 条消息, 当前发送时间为: 2023-01-16 15:47:26</span><br><span class="line">收到服务端返回 &gt; 收到您的请求， 服务器信息如下: /0:0:0:0:0:0:0:0:8080, 当前接收时间为: 2023-01-16 15:47:27</span><br><span class="line">------ 断开第 1 次连接 ------</span><br><span class="line"></span><br><span class="line">------ 创建第 2 次连接 ------</span><br><span class="line">发送消息到服务端，消息内容为 &gt; 客户端的第 2 条消息, 当前发送时间为: 2023-01-16 15:47:30</span><br><span class="line">收到服务端返回 &gt; 收到您的请求， 服务器信息如下: /0:0:0:0:0:0:0:0:8080, 当前接收时间为: 2023-01-16 15:47:31</span><br><span class="line">------ 断开第 2 次连接 ------</span><br></pre></td></tr></table></figure></p>
<h4 id="5-5-SocketChannel"><a href="#5-5-SocketChannel" class="headerlink" title="5.5 SocketChannel"></a>5.5 SocketChannel</h4><h5 id="5-5-1-SocketChannel类方法介绍"><a href="#5-5-1-SocketChannel类方法介绍" class="headerlink" title="5.5.1 SocketChannel类方法介绍"></a>5.5.1 SocketChannel类方法介绍</h5><p>首先我们看一下<code>SocketChannel</code>的类方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span> <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">NetworkChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个SocketChannel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SelectorProvider.provider().openSocketChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个SocketChannel并可连接到远程服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">(SocketAddress remote)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SocketChannel sc = open();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sc.connect(remote);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sc.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable suppressed) &#123;</span><br><span class="line">                x.addSuppressed(suppressed);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> sc.isConnected();</span><br><span class="line">        <span class="keyword">return</span> sc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回标识此通道支持的操作的操作集。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (SelectionKey.OP_READ</span><br><span class="line">                | SelectionKey.OP_WRITE</span><br><span class="line">                | SelectionKey.OP_CONNECT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- Socket-specific operations --</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定到本地服务地址</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketChannel <span class="title">bind</span><span class="params">(SocketAddress local)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">SocketChannel <span class="title">setOption</span><span class="params">(SocketOption&lt;T&gt; name, T value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在不关闭通道的情况下关闭读取连接。一旦关闭读取，那么在通道上的进一步读取将返回-1，流结束指示。如果连接的输入端已经关闭，那么调用此方法将不起作用。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketChannel <span class="title">shutdownInput</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在不关闭通道的情况下关闭写入连接。一旦关闭用于写入，那么进一步尝试写入通道将抛出ClosedChannelException。如果连接的输出端已经关闭，那么调用此方法将不起作用。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketChannel <span class="title">shutdownOutput</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前通道的对应java.net的socket对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Socket <span class="title">socket</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明该通道的socket是否已连接。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告知该通道上的连接操作是否正在进行。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isConnectionPending</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到远程的socket地址</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(SocketAddress remote)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成连接套接字通道的过程。</span></span><br><span class="line"><span class="comment">     * 非阻塞连接操作是通过将套接字通道置于非阻塞模式，然后调用其连接方法来启动的。一旦建立了连接，或者尝试失败，套接字通道将变得可连接，并且可以调用此方法来完成连接序列。</span></span><br><span class="line"><span class="comment">     * 如果连接操作失败，则调用此方法将导致抛出适当的IOException。 </span></span><br><span class="line"><span class="comment">     * 如果该通道已经连接，则该方法不会阻塞，并将立即返回true。</span></span><br><span class="line"><span class="comment">     * 如果此通道处于非阻塞模式，则如果连接过程尚未完成，则此方法将返回false。</span></span><br><span class="line"><span class="comment">     * 如果该通道处于阻塞模式，则该方法将阻塞，直到连接完成或失败，并且总是返回true或抛出描述失败的checked异常。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取远端服务器地址</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketAddress <span class="title">getRemoteAddress</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- ByteChannel 特有的方法 --</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将通道内的数据读入buffer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将通道内的数据读入buffer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将通道内的数据读入buffer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(dsts, <span class="number">0</span>, dsts.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将buffer的信息写入通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将buffer的信息写入通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将buffer的信息写入通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> write(srcs, <span class="number">0</span>, srcs.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本机地址信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketAddress <span class="title">getLocalAddress</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-5-2-SocketChannel重要方法知识点"><a href="#5-5-2-SocketChannel重要方法知识点" class="headerlink" title="5.5.2 SocketChannel重要方法知识点"></a>5.5.2 SocketChannel重要方法知识点</h5><p>在socketChannel中没有指定超时时间的<code>connect()</code>方法，当<code>connect()</code>方法在非阻塞模式下被调用时<code>SocketChannel</code>提供并发连接:它发起对请求地址的连接并且立即返回值。如果返回值是true，说明连接立即建立了(这可能是本地环回连接);如果连接不能立即建立，<code>connect()</code>方法会返回false且并发地继续连接建立过程。假如某个<code>SocketChannel</code>上当前正由一个并发连接，<code>isConnectPending()</code>方法就会返回true值。</p>
<p>调用<code>finishConnect()</code>方法来完成连接过程，该方法任何时候都可以安全地进行调用。假如在一个非阻塞模式的<code>SocketChannel</code>对象上调用<code>finishConnect()</code>方法，将可能出现下列情形之一:</p>
<ul>
<li><code>connect()</code>方法尚未被调用。那么将产生<code>NoConnectionPendingException</code>异常。 </li>
<li>连接建立过程正在进行，尚未完成。那么什么都不会发生，<code>finishConnect()</code>方法会立即返回false值。</li>
<li>在非阻塞模式下调用<code>connect()</code>方法之后，<code>SocketChannel</code>又被切换回了阻塞模式。那么如果有必要的话，调用线程会阻塞直到连接建立完成，<code>finishConnect()</code>方法接着就会返回true值。</li>
<li>在初次调用connect()或最后一次调用<code>finishConnect()</code>之后，连接建立过程已经完成。那么<code>SocketChannel</code>对象的内部状态将被更新到已连接状态，<code>finishConnect()</code>方法会返回true值，然后<code>SocketChannel</code>对象就可以被用来传输数据了。</li>
<li>连接已经建立。那么什么都不会发生，<code>finishConnect()</code>方法会返回 true 值。</li>
</ul>
<p>当通道处于中间的连接等待(connection-pending)状态时，您只可以调用<code>finishConnect()</code>、<code>isConnectPending()</code>或<code>isConnected()</code>方法。一旦连接建立过程成功完成，<code>isConnected()</code>将返回 true 值。</p>
<p>下面我们使用一段伪代码来模拟连接<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InetSocketAddress addr = <span class="keyword">new</span> InetSocketAddress(host, port);</span><br><span class="line">SocketChannel sc = SocketChannel.open( );</span><br><span class="line">sc.configureBlocking (<span class="keyword">false</span>);</span><br><span class="line">sc.connect(addr);</span><br><span class="line"><span class="keyword">while</span> (!sc.finishConnect()) &#123;</span><br><span class="line">    <span class="comment">// 执行一些等待的操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行socketChannel相关的操作</span></span><br><span class="line">sc.close();</span><br></pre></td></tr></table></figure></p>
<p>如果尝试异步连接失败，那么下次调用<code>finishConnect()</code>方法会产生一个适当的经检查的异常以指出问题的性质。通道然后就会被关闭并将不能被连接或再次使用。</p>
<p><code>connect()</code>和<code>finishConnect()</code>方法是互相同步的，并且只要其中一个操作正在进行，任何读或写的方法调用都会阻塞，即使是在非阻塞模式下。如果此情形下您有疑问或不能承受一个读或写操作在某个通道上阻塞，请用<code>isConnected()</code>方法测试一下连接状态。</p>
<h4 id="5-6-DatagramChannel"><a href="#5-6-DatagramChannel" class="headerlink" title="5.6 DatagramChannel"></a>5.6 DatagramChannel</h4><h5 id="5-6-1-DatagramChannel类方法介绍"><a href="#5-6-1-DatagramChannel类方法介绍" class="headerlink" title="5.6.1 DatagramChannel类方法介绍"></a>5.6.1 DatagramChannel类方法介绍</h5><p>SocketChannel模拟的是连接导向的流协议(TCP/IP)，DatagramChannel模拟的是包导向的无连接协议(UDP/IP)<br>首先我们看一下DatagramChannel的类方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DatagramChannel</span> <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span> <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">MulticastChannel</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开一个DatagramChannel并可连接到远程服务器，通过调用系统范围默认SelectorProvider对象的openDatagramChannel方法创建新通道。通道将无法连接。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DatagramChannel <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SelectorProvider.provider().openDatagramChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个DatagramChannel并可连接到远程服务器，family参数用于指定协议族</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DatagramChannel <span class="title">open</span><span class="params">(ProtocolFamily family)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SelectorProvider.provider().openDatagramChannel(family);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回标识此通道支持的操作的操作集。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (SelectionKey.OP_READ</span><br><span class="line">                | SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- Socket-specific operations --</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定到本地服务地址</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DatagramChannel <span class="title">bind</span><span class="params">(SocketAddress local)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置配置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">DatagramChannel <span class="title">setOption</span><span class="params">(SocketOption&lt;T&gt; name, T value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前通道的对应java.net的socket对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DatagramSocket <span class="title">socket</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否连接,数据报socket的无状态性质不需要同远程系统进行对话来建立连接状态。没有实际的连接，只有用来指定允许的远程地址的本地状态信息。</span></span><br><span class="line">    <span class="comment">// DatagramChannel上没有单独的finishConnect()方法。我们可以使用isConnected()方法来测试一个数据报通道的连 接状态。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接远程服务器</span></span><br><span class="line">    <span class="comment">// DatagramChannel对数据报socket的连接语义不同于对流socket的连接语义。</span></span><br><span class="line">    <span class="comment">// 有时候，将数据报对话限制为两方是很可取的。将DatagramChannel置于已连接的状态可以使除了它所“连接”到的地址之外的任何其他源地址的数据报被忽略。</span></span><br><span class="line">    <span class="comment">// 当DatagramChannel已连接时，使用同样的令牌，您不可以发送包到除了指定给connect()方法的目的地址以外的任何其他地址。试图一定要这样做的话会导致一个SecurityException异常。</span></span><br><span class="line">    <span class="comment">// 之后，每次send/receive时就不会再有安全检查了，因为来自或去到任何其他地址的包都是不允许的。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DatagramChannel <span class="title">connect</span><span class="params">(SocketAddress remote)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开此通道的socket</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DatagramChannel <span class="title">disconnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取远端服务器地址</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketAddress <span class="title">getRemoteAddress</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过此通道接收数据报</span></span><br><span class="line">    <span class="comment">// 在阻塞模式下，receive()可能无限的休眠直到有包到达。</span></span><br><span class="line">    <span class="comment">// 在非阻塞模式下没有可接收的包则会返回null。如果包内的数据超出缓冲区承受范围，多余的数据则会直接丢弃。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketAddress <span class="title">receive</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过此通道发送数据报   src-包含要发送的数据报的缓冲区, target-数据报要发送到的地址。</span></span><br><span class="line">    <span class="comment">// 调用send()方法会从当前的position开始到末尾处结束。在阻塞模式下，调用线程可能会休眠直到数据报被加入传输队列。</span></span><br><span class="line">    <span class="comment">// 在非阻塞情况下，返回值要么是字节缓冲区的字节数，要么是0。</span></span><br><span class="line">    <span class="comment">// 发送数据报是一个全有或者全无的行为。如果传输队列没有足够的空间承载整个数据报，那什么内容都不会被发送。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">send</span><span class="params">(ByteBuffer src, SocketAddress target)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- ByteChannel operations --</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将通道内的数据读入buffer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将通道内的数据读入buffer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将通道内的数据读入buffer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(dsts, <span class="number">0</span>, dsts.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将buffer的信息写入通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将buffer的信息写入通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将buffer的信息写入通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> write(srcs, <span class="number">0</span>, srcs.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本机地址信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketAddress <span class="title">getLocalAddress</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-6-2-启动DatagramChannel"><a href="#5-6-2-启动DatagramChannel" class="headerlink" title="5.6.2 启动DatagramChannel"></a>5.6.2 启动DatagramChannel</h5><p>DatagramSocketCHannel对象既可以充当服务端也可以充当客户端。如果我们需要创建一个通道来进行监听，那通道必须绑定到一个端口或者地址/端口的组合上。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">final</span> DatagramChannel datagram = DatagramChannel.open())&#123;</span><br><span class="line">    datagram.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-6-3-数据报与流socket对比"><a href="#5-6-3-数据报与流socket对比" class="headerlink" title="5.6.3 数据报与流socket对比"></a>5.6.3 数据报与流socket对比</h5><p>数据报通道不同于流socket。由于它们的有序而可靠的数据传输特性，流socket非常得有用。大多数网络连接都是流socket(TCP/IP就是一个显著的例子)。但是，像TCP/IP这样面向流的的 协议为了在包导向的互联网基础设施上维护流语义必然会产生巨大的开销，并且流隐喻不能适用所有的情形。数据报的吞吐量要比流协议高很多，并且数据报可以做很多流无法完成的事情。<br>下面列出了一些选择数据报socket而非流socket的理由:</p>
<ul>
<li>您的程序可以承受数据丢失或无序的数据。</li>
<li>您希望“发射后不管”(fire and forget)而不需要知道您发送的包是否已接收。</li>
<li>数据吞吐量比可靠性更重要。</li>
<li>您需要同时发送数据给多个接受者(多播或者广播)。</li>
<li>包隐喻比流隐喻更适合手边的任务。</li>
</ul>
<h5 id="5-6-4-DatagramChannel知识点"><a href="#5-6-4-DatagramChannel知识点" class="headerlink" title="5.6.4 DatagramChannel知识点"></a>5.6.4 DatagramChannel知识点</h5><ol>
<li><code>DatagramChannel</code>是无连接的，每个数据包都是一个自包含的实体，拥有它自己的目的地址。与面向流的socket不同，<code>DatagramChannel</code>可以发送单独的数据到不同的目的地址。同样也可以接受来自任意地址的数据。</li>
<li>假设一个<code>DatagramChannel</code>没有绑定，他也仍然能接收数据包。因为当底层创建socket的时候会动态生成一个端口号分配给它。当进行数据发送的时候，发送的数据包中会含有<code>DatagramChannel</code>的源地址数据（带端口）。</li>
<li>数据之间的实际发送和接收是通过<code>send()</code>和<code>receive()</code>方法来实现的。</li>
<li>如果安装了安全管理器，那么每次调用<code>send()</code>或<code>receive()</code>时安全管理器的<code>checkConnect()</code>方法都会被调用以验证目的地址，除非通道处于已连接的状态。</li>
<li>数据报协议的不可靠性是固有的，它们不对数据传输做保证。send()方法返回的非零值并不表示数据报到达了目的地，仅代表数据报被成功加到本地网络层的传输队列。</li>
<li><code>DatagramChannel</code>对象可以任意次数地进行连接或断开连接。每次连接都可以到一个不同的远程地址。调用<code>disconnect()</code>方法可以配置通道，以便它能再次接收来自安全管理器(如果已安装)所允许的任意远程地址的数据或发送数据到这些地址上。</li>
<li><code>DatagramChannel</code>处于已连接状态时，发送数据将不用提供目的地址而且接收时的源地址也是已知的。这意味着<code>DatagramChannel</code>已连接时可以使用常规的<code>read()</code>和<code>write()</code>方法，包括<code>scatter/gather</code>形式的读写来组合或分拆包的数据:</li>
</ol>
<h5 id="5-6-5-DatagramChannel实现时间服务器"><a href="#5-6-5-DatagramChannel实现时间服务器" class="headerlink" title="5.6.5 DatagramChannel实现时间服务器"></a>5.6.5 DatagramChannel实现时间服务器</h5><p>服务端代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatagramChannelTimeServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DatagramChannel channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_PORT = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DIFF_1900 = <span class="number">2208988800L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DatagramChannelTimeServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = DatagramChannel.open();</span><br><span class="line">        <span class="keyword">this</span>.channel.bind(<span class="keyword">new</span> InetSocketAddress(DEFAULT_PORT));</span><br><span class="line">        System.out.println(<span class="string">"Listening on port "</span> + DEFAULT_PORT + <span class="string">" for time requests"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DatagramChannelTimeServer server = <span class="keyword">new</span> DatagramChannelTimeServer();</span><br><span class="line">        server.listen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用8字节中的后4字节有两个好处</span></span><br><span class="line"><span class="comment">     * 1. 节省网络传输空间</span></span><br><span class="line"><span class="comment">     * 2. 因为在 2106-02-07 14:28:15 前只需要四字节就能存储当前的时间，只传递4字节也能避免不同操作系统的大端或者小端转换的问题。只要将4位放到对应位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer longBuffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        longBuffer.order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">        longBuffer.putLong(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        longBuffer.position(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer buffer = longBuffer.slice();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">final</span> SocketAddress socketAddress = <span class="keyword">this</span>.channel.receive(buffer);</span><br><span class="line">            <span class="keyword">if</span> (socketAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Time request from "</span> + socketAddress);</span><br><span class="line">            <span class="comment">// 将接受到的数据清空</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            longBuffer.putLong(<span class="number">0</span>, (System.currentTimeMillis() / <span class="number">1000</span>) + DIFF_1900);</span><br><span class="line">            <span class="keyword">this</span>.channel.send(buffer, socketAddress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatagramChannelTimeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; remoteHosts;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DatagramChannel channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_PORT = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DIFF_1900 = <span class="number">2208988800L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DatagramChannelTimeClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.remoteHosts = Arrays.asList(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="keyword">this</span>.channel = DatagramChannel.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DatagramChannelTimeClient service = <span class="keyword">new</span> DatagramChannelTimeClient();</span><br><span class="line">        service.sendRequests();</span><br><span class="line">        service.getPipelines();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRequests</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String remoteHost : <span class="keyword">this</span>.remoteHosts) &#123;</span><br><span class="line">            <span class="comment">// 用于发送一个空数据请求</span></span><br><span class="line">            buffer.clear().flip();</span><br><span class="line">            channel.send(buffer, <span class="keyword">new</span> InetSocketAddress(remoteHost, DEFAULT_PORT));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取返回的响应数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPipelines</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 申请一个8字节的buffer用于存储long类型的数据</span></span><br><span class="line">        <span class="keyword">final</span> ByteBuffer longBuffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 使用大端模式</span></span><br><span class="line">        longBuffer.order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">        <span class="comment">// 给整个buffer置空</span></span><br><span class="line">        longBuffer.putLong(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将位置移动到小端的32字节的第一个字节</span></span><br><span class="line">        longBuffer.position(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 切片缓冲;给出低阶32位的视图</span></span><br><span class="line">        <span class="keyword">final</span> ByteBuffer buffer = longBuffer.slice();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expect = remoteHosts.size();</span><br><span class="line">        <span class="keyword">int</span> replies = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            InetSocketAddress sa;</span><br><span class="line">            sa = <span class="keyword">this</span>.receivePacket(channel, buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            replies++;</span><br><span class="line">            <span class="keyword">this</span>.printTime(longBuffer.getLong(<span class="number">0</span>), sa);</span><br><span class="line">            <span class="keyword">if</span> (replies == expect) &#123;</span><br><span class="line">                System.out.println (<span class="string">"All packets answered"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println (<span class="string">"Received "</span> + replies + <span class="string">" of "</span> + expect + <span class="string">" replies"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printTime</span><span class="params">(<span class="keyword">long</span> remote1900, InetSocketAddress sa)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// local time as seconds since Jan 1, 1970</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> local = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// remote time as seconds since Jan 1, 1970</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> remote = remote1900 - DIFF_1900;</span><br><span class="line">        <span class="keyword">final</span> Date remoteDate = <span class="keyword">new</span> Date(remote * <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">final</span> Date localDate = <span class="keyword">new</span> Date(local * <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> skew = remote - local;</span><br><span class="line">        System.out.println(<span class="string">"Reply from "</span> + sa.getHostName() + <span class="string">":"</span> + sa.getPort());</span><br><span class="line">        System.out.println(<span class="string">" there: "</span> + remoteDate);</span><br><span class="line">        System.out.println(<span class="string">" here: "</span> + localDate);</span><br><span class="line">        System.out.print(<span class="string">" skew: "</span>);</span><br><span class="line">        <span class="keyword">if</span> (skew == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"none"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skew &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(skew + <span class="string">" seconds ahead"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println((-skew) + <span class="string">" seconds behind"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> InetSocketAddress <span class="title">receivePacket</span><span class="params">(DatagramChannel channel, ByteBuffer buffer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="comment">// Receive an unsigned 32-bit, big-endian value</span></span><br><span class="line">        <span class="keyword">return</span> ((InetSocketAddress) channel.receive(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="六、管道"><a href="#六、管道" class="headerlink" title="六、管道"></a>六、管道</h3><h4 id="6-1-Pipe类介绍"><a href="#6-1-Pipe类介绍" class="headerlink" title="6.1 Pipe类介绍"></a>6.1 Pipe类介绍</h4><p><code>java.nio.channels</code>包中含有一个名为<code>Pipe</code>(管道)的类。广义上讲，管道就是一个用来在两个实体之间单向传输数据的导管。Unix系统中，管道被用来连接一个进程的输出和另一个进程的输入。<code>Pipe</code>类实现一 个管道范例，不过它所创建的管道是进程内(在Java虚拟机进程内部)而非进程间使用的。<br>我们看一下Pipe类的核心方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pipe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 作为数据输入源的可读通道</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceChannel</span> <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span> <span class="keyword">implements</span> <span class="title">ReadableByteChannel</span>, <span class="title">ScatteringByteChannel</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">SourceChannel</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(provider);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回标识此通道支持的操作的操作集。管道源通道只支持读取，因此该方法返回SelectionKey.OP_READ。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SelectionKey.OP_READ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 作为数据输出源的可写通道</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SinkChannel</span> <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span> <span class="keyword">implements</span> <span class="title">WritableByteChannel</span>, <span class="title">GatheringByteChannel</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">SinkChannel</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(provider);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回标识此通道支持的操作的操作集。管道源通道只支持写入，因此该方法返回SelectionKey.OP_WRITE。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SelectionKey.OP_WRITE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Pipe</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输入源通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SourceChannel <span class="title">source</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输出源通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SinkChannel <span class="title">sink</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个管道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pipe <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SelectorProvider.provider().openPipe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下图描述了管道的读写关系，可以往<code>sinkChannel</code>中写入数据，然后通过<code>sourceChannel</code>读取写入的数据。这两个通道实例是在<code>Pipe</code>对象创建的同时被创建的，可以通过在 Pipe对象上分别调用<code>source()</code>和<code>sink()</code>方法来取回。<br>请注意，<code>SinkChannel</code>和<code>SourceChannel</code>都由<code>AbstractSelectableChannel</code>引申而来(所以也是从<code>SelectableChannel</code>引申而来)，这意味着<code>pipe</code>通道可以同选择器一起使用。<br>管路所能承载的数据量是依赖实现的(implementation-dependent)。唯一可保证的是写到<code>SinkChannel</code>中的字节都能按照同样的顺序在<code>SourceChannel</code>上重现。</p>
<p><img src="/images/Java-NIO-通道相关概念及源码梳理/145F6B47-0548-42C3-B6E3-7647DB4904B0_4_5005_c.jpeg" alt="img"></p>
<h4 id="6-2-使用Pipe类实现通道输入输出"><a href="#6-2-使用Pipe类实现通道输入输出" class="headerlink" title="6.2 使用Pipe类实现通道输入输出"></a>6.2 使用Pipe类实现通道输入输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> WritableByteChannel out = Channels.newChannel(System.out);</span><br><span class="line">        <span class="keyword">final</span> Pipe pipe = Pipe.open();</span><br><span class="line">        <span class="keyword">final</span> Worker worker = <span class="keyword">new</span> Worker(pipe.sink());</span><br><span class="line">        <span class="comment">// 启动线程往sinkChannel中写入数据</span></span><br><span class="line">        worker.start();</span><br><span class="line">        ReadableByteChannel workerChannel = pipe.source();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">while</span> (workerChannel.read(buffer) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            out.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] products = &#123;</span><br><span class="line">                <span class="string">"No good deed goes unpunished"</span>,</span><br><span class="line">                <span class="string">"To be, or what?"</span>,</span><br><span class="line">                <span class="string">"No matter where you go, there you are"</span>,</span><br><span class="line">                <span class="string">"Just say \"Yo\""</span>,</span><br><span class="line">                <span class="string">"My karma ran over my dogma"</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WritableByteChannel channel;</span><br><span class="line"></span><br><span class="line">        Worker(WritableByteChannel channel) &#123;</span><br><span class="line">            <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> product = rand.nextInt(products.length);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    buffer.put(products[product].getBytes());</span><br><span class="line">                    buffer.put(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="comment">// 写入可能不会一次性成功，所以while循环直至全部成功</span></span><br><span class="line">                    <span class="keyword">while</span> (channel.write(buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="七、通道工具类"><a href="#七、通道工具类" class="headerlink" title="七、通道工具类"></a>七、通道工具类</h3><table>
<thead>
<tr>
<th>方法</th>
<th>返回</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>newChannel(InputStream in)</td>
<td>ReadableByteChannel</td>
<td>返回一个将从给定的输入流读取数据的通道。</td>
</tr>
<tr>
<td>newChannel(OutputStream out)</td>
<td>WritableByteChannel</td>
<td>返回一个将向给定的输出流写入数据的通道。</td>
</tr>
<tr>
<td>newInputStream(ReadableByteChannel ch)</td>
<td>InputStream</td>
<td>返回一个将从给定的通道读取字节的流。</td>
</tr>
<tr>
<td>newOutputStream(WritableByteChannel ch)</td>
<td>OutputStream</td>
<td>返回一个将向给定的通道写入字节的流。</td>
</tr>
<tr>
<td>newReader(ReadableByteChannel ch, CharsetDecoder dec, int minBufferCap)</td>
<td>Reader</td>
<td>返回一个reader，它将从给定的通道读取字节并依据提供的CharsetDecoder对读取到的字节进行解码。</td>
</tr>
<tr>
<td>newReader(ReadableByteChannel ch, String csName)</td>
<td>Reader</td>
<td>返回一个reader，它将从给定的 通道读取字节并依据提供的字符集名称将读取到的字节解码成字符。</td>
</tr>
<tr>
<td>newWriter(WritableByteChannel ch, CharsetEncoder dec, int minBufferCap)</td>
<td>Writer</td>
<td>返回一个writer，它将使用提供的CharsetEncoder对象对字符编码并写到给定的通道中。</td>
</tr>
<tr>
<td>newWriter(WritableByteChannel ch, String csName)</td>
<td>Writer</td>
<td>返回一个writer它将依据提供的字符集名称对字符编码并写到给定的通道中。</td>
</tr>
</tbody>
</table>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
            
              <a href="/tags/NIO/" rel="tag"><i class="fa fa-tag"></i> NIO</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2023/01/07/Java-NIO-缓冲区相关概念及源码梳理/" rel="next" title="Java-NIO-缓冲区相关概念及源码梳理">
                  <i class="fa fa-chevron-left"></i> Java-NIO-缓冲区相关概念及源码梳理
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          文章目录
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、通道基础概念与使用"><span class="nav-number">1.</span> <span class="nav-text">一、通道基础概念与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-Channel定义"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 Channel定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-1-WritableByteChannel接口和ReadableByteChannel接口"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1 WritableByteChannel接口和ReadableByteChannel接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-2-ByteChannel类"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2 ByteChannel类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-3-InterruptibleChannel接口"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.1.3 InterruptibleChannel接口</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-打开通道"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 打开通道</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-传统IO方式读取流"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 传统IO方式读取流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-通道方式读取流"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.1 通道方式读取流</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-Channel拷贝"><span class="nav-number">1.3.</span> <span class="nav-text">1.4 Channel拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-关闭通道"><span class="nav-number">1.4.</span> <span class="nav-text">1.5 关闭通道</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、Scatter-Gather"><span class="nav-number">2.</span> <span class="nav-text">二、Scatter/Gather</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-概念介绍"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 概念介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-接口定义"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 接口定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-函数介绍"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 函数介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-使用GatheringByteChannel尝试写文件"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 使用GatheringByteChannel尝试写文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、文件通道FileChannel"><span class="nav-number">3.</span> <span class="nav-text">三、文件通道FileChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-FileChannel简介"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 FileChannel简介</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-1-FileChannel是否是阻塞的？"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 FileChannel是否是阻塞的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-FileInputStream与FileOutputStream获取的文件通道的区别？"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 FileInputStream与FileOutputStream获取的文件通道的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-3-FileChannel的position"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3 FileChannel的position</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-4-FileChannel多线程访问一个文件会出现问题吗？"><span class="nav-number">3.1.4.</span> <span class="nav-text">3.1.4 FileChannel多线程访问一个文件会出现问题吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-5-FileChannel比较重要的方法有哪些？"><span class="nav-number">3.1.5.</span> <span class="nav-text">3.1.5 FileChannel比较重要的方法有哪些？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-传统方式读写文件"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 传统方式读写文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-FileChannel读文件"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 FileChannel读文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-FileChannel写文件"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 FileChannel写文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-创建同时可读可写的FileChannel"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 创建同时可读可写的FileChannel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-FileChannel截断"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 FileChannel截断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-FileChannel编辑"><span class="nav-number">3.7.</span> <span class="nav-text">3.7 FileChannel编辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-FileChannel拷贝-Channel-To-Channel"><span class="nav-number">3.8.</span> <span class="nav-text">3.8 FileChannel拷贝(Channel To Channel)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-文件锁定"><span class="nav-number">3.9.</span> <span class="nav-text">3.9 文件锁定</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-9-1-文件锁定相关的API"><span class="nav-number">3.9.1.</span> <span class="nav-text">3.9.1 文件锁定相关的API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-9-2-FileLock介绍"><span class="nav-number">3.9.2.</span> <span class="nav-text">3.9.2 FileLock介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-9-3-尝试进程间使用文件锁"><span class="nav-number">3.9.3.</span> <span class="nav-text">3.9.3 尝试进程间使用文件锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、内存映射文件"><span class="nav-number">4.</span> <span class="nav-text">四、内存映射文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-map-方法定义"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 map()方法定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-1-MapMode介绍"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1 MapMode介绍</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-MappedByteBuffer介绍"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 MappedByteBuffer介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、Socket通道"><span class="nav-number">5.</span> <span class="nav-text">五、Socket通道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-阻塞I-O的socket实现"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 阻塞I/O的socket实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-非阻塞I-O的实现"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 非阻塞I/O的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-Socket通道常用类介绍"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 Socket通道常用类介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-1-非阻塞模式"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 非阻塞模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-ServerSocketChannel"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 ServerSocketChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-1-ServerSocketChannel类方法介绍"><span class="nav-number">5.4.1.</span> <span class="nav-text">5.4.1 ServerSocketChannel类方法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-2-实现非阻塞的ServerSocketChannel"><span class="nav-number">5.4.2.</span> <span class="nav-text">5.4.2 实现非阻塞的ServerSocketChannel</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-SocketChannel"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 SocketChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-1-SocketChannel类方法介绍"><span class="nav-number">5.5.1.</span> <span class="nav-text">5.5.1 SocketChannel类方法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-2-SocketChannel重要方法知识点"><span class="nav-number">5.5.2.</span> <span class="nav-text">5.5.2 SocketChannel重要方法知识点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-DatagramChannel"><span class="nav-number">5.6.</span> <span class="nav-text">5.6 DatagramChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-1-DatagramChannel类方法介绍"><span class="nav-number">5.6.1.</span> <span class="nav-text">5.6.1 DatagramChannel类方法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-2-启动DatagramChannel"><span class="nav-number">5.6.2.</span> <span class="nav-text">5.6.2 启动DatagramChannel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-3-数据报与流socket对比"><span class="nav-number">5.6.3.</span> <span class="nav-text">5.6.3 数据报与流socket对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-4-DatagramChannel知识点"><span class="nav-number">5.6.4.</span> <span class="nav-text">5.6.4 DatagramChannel知识点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-5-DatagramChannel实现时间服务器"><span class="nav-number">5.6.5.</span> <span class="nav-text">5.6.5 DatagramChannel实现时间服务器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、管道"><span class="nav-number">6.</span> <span class="nav-text">六、管道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-Pipe类介绍"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 Pipe类介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-使用Pipe类实现通道输入输出"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 使用Pipe类实现通道输入输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、通道工具类"><span class="nav-number">7.</span> <span class="nav-text">七、通道工具类</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.png"
      alt="随我">
  <p class="site-author-name" itemprop="name">随我</p>
  <div class="site-description" itemprop="description">用心做自己喜欢的事</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">131</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">101</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/ZhangJia97" title="GitHub &rarr; https://github.com/ZhangJia97" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:isuiwo@qq.com" title="E-Mail &rarr; mailto:isuiwo@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://wqf1234.github.io/" title="https://wqf1234.github.io/" rel="noopener" target="_blank">AC的博客</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/qq_38542085" title="https://blog.csdn.net/qq_38542085" rel="noopener" target="_blank">随我的CSDN</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">随我</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共183.4k字</span>
</div>

<div class="BbeiAn-info">
    <a target="_blank" href="http://beian.miit.gov.cn" rel="nofollow">豫ICP备18013715号-1</a> <!--a标签中增加nofollow属性，避免爬虫出站。-->
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/pisces.js?v=7.3.0"></script>

<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
